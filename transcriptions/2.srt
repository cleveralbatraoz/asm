1
00:00:00,000 --> 00:00:18,720
намного. Но есть особенность. Память состоит из страничек, о чём вы, наверное, помните, но о них, конечно, поговорим более подробно, но позже.

2
00:00:18,720 --> 00:00:30,120
И вот, в связи с особенностями каждой такой конфликционной системы, они стараются выделять физическую память только по мере необходимости.

3
00:00:31,580 --> 00:00:41,120
То, что у вас выделено под стек, на самом деле оно, в прямом смысле этого слова, не выделено.

4
00:00:42,320 --> 00:00:47,840
Оно только зарезервировано. В смысле, диапазон адресов зарезервирован под стек.

5
00:00:47,840 --> 00:00:47,880
Так.

6
00:00:47,880 --> 00:00:51,880
А физической памяти туда не сопоставлено.

7
00:00:53,080 --> 00:00:55,900
И в камере линкарных работают.

8
00:00:57,080 --> 00:00:59,240
В зрении памяти происходит следующее.

9
00:00:59,640 --> 00:01:10,320
Когда вы обращаетесь на одну страничку ближе, чем последняя выделенная, то у вас происходит фетч-фолл.

10
00:01:11,320 --> 00:01:13,000
Управление получает система.

11
00:01:13,000 --> 00:01:17,000
Система видит, что это фетч-фолл на стеке, где...

12
00:01:17,880 --> 00:01:21,260
Место быть должно, но оно еще не выделено.

13
00:01:21,780 --> 00:01:26,340
Выделяет и опускает вот эту вот гард-страничку на одну нишу.

14
00:01:27,440 --> 00:01:30,080
В итоге выделение происходит по одной страничке.

15
00:01:30,960 --> 00:01:36,420
Поэтому, если вы опустите стек-поинтер там, например, на 10 килобайт,

16
00:01:38,420 --> 00:01:44,140
то это означает, что у вас есть реальные шансы пропустить эту гард-страничку.

17
00:01:44,140 --> 00:01:47,140
И если вы обратитесь по вот этому новому значению,

18
00:01:47,880 --> 00:01:51,880
ESP, которое на 10 килобайт ниже,

19
00:01:51,880 --> 00:01:59,880
вы можете просто перешагнуть страничку, по которой операционка определяет, что стек нужно расширить.

20
00:02:00,880 --> 00:02:04,880
Соответственно, при удалении памяти больше странички,

21
00:02:04,880 --> 00:02:12,880
на стеке следует пройтись по каждой страничке, то есть с шагом 4 килобайта,

22
00:02:12,880 --> 00:02:15,880
и просто ее потрогать как-нибудь.

23
00:02:15,880 --> 00:02:17,580
Прочитать оттуда байтик, закрепить,

24
00:02:17,580 --> 00:02:19,580
записать туда байтик, неважно.

25
00:02:19,580 --> 00:02:24,580
Ну вот, совершив какое-то действие с шагом 4 килобайта,

26
00:02:24,580 --> 00:02:28,580
что, да, начиная, конечно, сверху, сверху по прорисовке,

27
00:02:28,580 --> 00:02:35,580
то у вас не могла произойти ситуация, что стек вот такой вот не выделен.

28
00:02:39,580 --> 00:02:41,580
Вот такая ситуация.

29
00:02:41,580 --> 00:02:45,580
В принципе, в первой лаборатории вы на этом и снизу шли,

30
00:02:45,580 --> 00:02:50,580
потому что нифига вам больше 4 килобайта данных.

31
00:02:50,580 --> 00:02:52,580
И вообще не надо.

32
00:02:53,580 --> 00:03:00,580
Но в следующих лабораторных это может быть критично.

33
00:03:00,580 --> 00:03:02,580
Понятно?

34
00:03:02,580 --> 00:03:06,580
Сейчас, еще раз. А чем грозит, если не пощупать странички?

35
00:03:06,580 --> 00:03:09,580
Если не пощупать, то, еще раз, выделение происходит,

36
00:03:09,580 --> 00:03:14,580
когда происходит падение на карт странички, вот на которой сразу за концом,

37
00:03:15,580 --> 00:03:20,580
если ты обходишь ее и обращаешься в следующую страничку,

38
00:03:20,580 --> 00:03:25,580
то оно не обрабатывается специальным образом, и программа просто падает.

39
00:03:25,580 --> 00:03:29,580
Нет, а пока со стороны программы или со стороны рисунка?

40
00:03:29,580 --> 00:03:33,580
Ну, вообще со стороны программы, потому что операционка постулирует такое поведение,

41
00:03:33,580 --> 00:03:37,580
поэтому это как бы метод документации.

42
00:03:37,580 --> 00:03:43,580
Так что у нас было на архитектуре, кто помнит еще,

43
00:03:43,580 --> 00:03:49,580
вот это задокументированное поведение, поэтому, если вы так не делаете,

44
00:03:49,580 --> 00:03:51,580
то виноваты вы.

45
00:03:53,580 --> 00:03:55,580
Это про Винду, да, было?

46
00:03:55,580 --> 00:03:59,580
Ну, про Винду это точно, про другие операционки я не уверен.

47
00:03:59,580 --> 00:04:02,580
Правильно сказать, специальные операционки.

48
00:04:02,580 --> 00:04:08,580
То есть они тоже так же лениво выделяют память, это точно.

49
00:04:08,580 --> 00:04:12,580
Но вот такие особенности этого ленивого выделения памяти,

50
00:04:12,580 --> 00:04:16,580
я не могу вам сказать настолько подробно.

51
00:04:20,580 --> 00:04:26,580
Ну, про эти странички еще раз, у нас это будет, но там, в конце курса.

52
00:04:26,580 --> 00:04:33,580
Потому что это такая чистая теория, никакие факты на это не предполагаются.

53
00:04:33,580 --> 00:04:40,580
Поэтому пока, пока имеет смысл представлять что-то более полезное.

54
00:04:40,580 --> 00:04:45,580
И на самом деле, можно пойти в две стороны.

55
00:04:45,580 --> 00:04:53,580
Можно либо пойти в 64 бита, либо пойти в плавающую точку.

56
00:04:53,580 --> 00:04:56,580
Вот, что вам больше нравится.

57
00:04:56,580 --> 00:04:59,580
Плавающая точка.

58
00:04:59,580 --> 00:05:04,580
Все, я говорю, плавающая точка, кто хочет.

59
00:05:04,580 --> 00:05:08,580
Раз, два, три, четыре, пять.

60
00:05:08,580 --> 00:05:10,580
Четыре бита.

61
00:05:10,580 --> 00:05:13,580
Раз, два, три, четыре, пять.

62
00:05:13,580 --> 00:05:14,580
Серьезно?

63
00:05:14,580 --> 00:05:16,580
А, шесть.

64
00:05:16,580 --> 00:05:19,580
Ну, вы же поднимайте руки, я могу считать.

65
00:05:19,580 --> 00:05:22,580
Раз, два, три, четыре, пять.

66
00:05:22,580 --> 00:05:24,580
Пять.

67
00:05:24,580 --> 00:05:25,580
Половина.

68
00:05:25,580 --> 00:05:26,580
Ты куда?

69
00:05:26,580 --> 00:05:27,580
Половина.

70
00:05:27,580 --> 00:05:30,580
Ну, вот половина победила.

71
00:05:30,580 --> 00:05:33,580
Значит, мы идем в 64 бита.

72
00:05:33,580 --> 00:05:36,580
В принципе, через два будет шутка.

73
00:05:36,580 --> 00:05:43,580
В принципе, через два будет шутка идти более исторически правильно.

74
00:05:43,580 --> 00:05:49,580
А через 64 бита идти, наверное, более практически полезно.

75
00:05:49,580 --> 00:05:54,580
Потому что 64 бита – это текущее состояние.

76
00:05:54,580 --> 00:06:04,580
И тогда можно рассчитывать, например, что в следующей лаборатории вы можете делать 32 или 64 бита.

77
00:06:04,580 --> 00:06:05,580
По вашим условиям.

78
00:06:06,580 --> 00:06:09,580
И первая лабораторная – это 32 бита.

79
00:06:09,580 --> 00:06:10,580
Да.

80
00:06:10,580 --> 00:06:13,580
Первая лабораторная – это 132 бита.

81
00:06:13,580 --> 00:06:19,580
И конвенция вызова – 7.

82
00:06:19,580 --> 00:06:22,580
Итак, 64 бита – что это такое?

83
00:06:22,580 --> 00:06:28,580
Это очередное 100-тысячное расширение архитектуры ИЦ-86.

84
00:06:28,580 --> 00:06:34,580
Во-первых, мы еще раз вспоминаем, что ИЦ-86 от рождения была какой архитектурой?

85
00:06:34,580 --> 00:06:35,580
16 битой.

86
00:06:35,580 --> 00:06:36,580
16 битой, да.

87
00:06:36,580 --> 00:06:48,580
Потом в супердалекий атлас времена процессора И-80386 добавилось 32-битное расширение в режим работы,

88
00:06:48,580 --> 00:06:50,580
а режим это тоже, как говорится, почек,

89
00:06:50,580 --> 00:07:01,580
который позволил использовать 32-битные регистры, 32-битную арифметику и, самое главное, 32-битную адресацию.

90
00:07:01,580 --> 00:07:05,580
Вы очень счастливы, что не застали 16-битный мир.

91
00:07:05,580 --> 00:07:10,580
Адресация в 16-битном мире была полным адом.

92
00:07:10,580 --> 00:07:22,580
Немножко, что там происходило, мы рассмотрим тоже попозже, но, чтобы не наказать вашу плохую психику, мы это поверхностно рассмотрим.

93
00:07:22,580 --> 00:07:24,580
Это было реально больно.

94
00:07:24,580 --> 00:07:31,580
Так вот, 32-битный мир позволил адресацию сильно упростить.

95
00:07:31,580 --> 00:07:41,580
И вот то, что происходит сегодня, 64 битов, не так уж принципиально изменилось.

96
00:07:41,580 --> 00:07:46,580
То есть 16-32 битов был очень существенный переход.

97
00:07:46,580 --> 00:07:54,580
32-64 такой существенно менее крупный, заметный и так далее.

98
00:07:54,580 --> 00:07:56,580
Но отчасти почему?

99
00:07:56,580 --> 00:08:00,580
Отчасти потому, что уже было намного больше состав.

100
00:08:00,580 --> 00:08:11,580
И поэтому соображения об обратной совместимости, о упрощении, портировании и так далее, также были намного более сильны.

101
00:08:11,580 --> 00:08:19,580
Если при переходе 16-32 народ прям ломал всё подряд ради светлого будущего,

102
00:08:19,580 --> 00:08:26,580
то вот 32-64 уже ломали, честно говоря, меньше, чем нужно было бы поломать.

103
00:08:26,580 --> 00:08:28,580
И поэтому наше будущее местами страдает на самом деле.

104
00:08:28,580 --> 00:08:30,580
И поэтому наше будущее местами страдает на самом деле.

105
00:08:30,580 --> 00:08:40,580
Это от того, что, не знаю, конечно, не доломали, но можно было бы лучше.

106
00:08:40,580 --> 00:08:44,580
Итак, 64-битный режим.

107
00:08:44,580 --> 00:08:47,580
Это специальный режим работы процессора.

108
00:08:47,580 --> 00:08:54,580
И особенность его, что всякие расширения, которые добавили в 64-битный режим,

109
00:08:54,580 --> 00:08:58,580
их сумели заковырять через специальную форму кодирования,

110
00:08:58,580 --> 00:09:00,580
через специальные префиксы,

111
00:09:00,580 --> 00:09:04,920
которые вы можете поставить перед командами, и в 16-битный режим.

112
00:09:05,760 --> 00:09:12,960
То есть, если ваш процессор умеет 32 бита, то 32-битные регистры и так далее

113
00:09:12,960 --> 00:09:16,980
доступны вам даже из 16-битного режима.

114
00:09:16,980 --> 00:09:32,280
Более того, честно говоря, внутри команды вида ADD, EAX, ECX и ADD, AX, CX

115
00:09:32,280 --> 00:09:38,540
это одна и та же команда, один и тот же код, и отличаются они только тем,

116
00:09:39,100 --> 00:09:44,260
что в каком режиме вы интерпретируете этот код.

117
00:09:44,260 --> 00:09:46,260
Если процессор работает...

118
00:09:46,980 --> 00:09:51,320
В 32-битном режиме, то он интерпретирует как EAX.

119
00:09:51,900 --> 00:09:55,500
Если в 16-битном режиме, то он интерпретирует как AX.

120
00:09:57,200 --> 00:10:03,380
И у вас есть специальный байтик, префикс изменения битности данных,

121
00:10:04,560 --> 00:10:09,560
который позволяет переключить на противоположную интерпретацию.

122
00:10:11,560 --> 00:10:15,720
Ну да, противоположная интерпретация.

123
00:10:16,140 --> 00:10:16,560
Поэтому...

124
00:10:16,980 --> 00:10:21,440
Когда вы пишете команду ADD, AX, CX в 32-битном режиме,

125
00:10:21,760 --> 00:10:26,800
она навалит длиннее, чем команда ADD, EAX, ECX.

126
00:10:27,860 --> 00:10:31,120
Но содержит тот же самый код, просто дополнительный префикс,

127
00:10:31,540 --> 00:10:34,080
что мы переключаемся в 16-битный режим.

128
00:10:34,640 --> 00:10:39,860
То есть 32-битное расширение, оно было добавлено вот так вот фактически везде.

129
00:10:40,720 --> 00:10:44,740
Через дополнительный префикс вы оказываетесь вот в противоположной битности.

130
00:10:45,540 --> 00:10:46,740
В 64-битном режиме...

131
00:10:46,980 --> 00:10:48,980
То есть 32-битное расширение, оно не такое.

132
00:10:49,980 --> 00:10:54,980
Вот так вот просто взять и добавить префикс, к сожалению, там уже набор...

133
00:10:55,980 --> 00:11:01,980
Это префикс вашей следующей команды в 16-битном режиме или префикс вашей следующей команды в 16-битном режиме?

134
00:11:02,980 --> 00:11:03,980
Нет, это именно на одну команду есть.

135
00:11:04,980 --> 00:11:09,980
То есть это как будто расширение кода команды.

136
00:11:10,980 --> 00:11:12,980
Это не переключение режима процесса.

137
00:11:13,980 --> 00:11:15,980
Это переключение интерпретации вот одной команды.

138
00:11:16,980 --> 00:11:17,980
Это не переключение этой команды.

139
00:11:18,980 --> 00:11:19,980
Да.

140
00:11:20,980 --> 00:11:22,980
То есть в другом режиме это тоже надо использовать?

141
00:11:23,980 --> 00:11:26,980
То есть еще раз, если ты хочешь команду ADD AXCX,

142
00:11:27,980 --> 00:11:31,980
то единственный способ ее закодировать, это использовать ADD.

143
00:11:32,980 --> 00:11:37,980
То есть это одна и та же команда с точки зрения кода.

144
00:11:38,980 --> 00:11:43,980
А интерпретация этого кода зависит а от режима работы процессора,

145
00:11:43,980 --> 00:11:48,980
б от наличия префикса переключения битности данных.

146
00:11:49,980 --> 00:11:52,980
То есть в 16-битном режиме вы можете переключить битность данных?

147
00:11:53,980 --> 00:11:54,980
Да.

148
00:11:55,980 --> 00:11:57,980
То есть если вы захотите проверить цель...

149
00:11:58,980 --> 00:12:01,980
8-битные регистры имеют свой собственный код,

150
00:12:02,980 --> 00:12:06,980
и они этим префиксом изменения битности не управляют.

151
00:12:07,980 --> 00:12:12,980
То есть вы можете добавить этот префикс, но он ничего не сделает с этой командой.

152
00:12:13,980 --> 00:12:17,980
Этот префикс переключает вам 16 или 32 бит.

153
00:12:18,980 --> 00:12:22,980
Если команда не использует 16 или 32 бит,

154
00:12:23,980 --> 00:12:26,980
то тогда этот префикс делает ничего.

155
00:12:29,980 --> 00:12:31,980
Большинство вот этих вот физических префиксов,

156
00:12:32,980 --> 00:12:37,980
они безобидны в плане того, что если вы ставите их в команду,

157
00:12:38,980 --> 00:12:42,980
которая неосмысленно взаимодействует с этим префиксом,

158
00:12:43,980 --> 00:12:45,980
то из-за этого ничего не происходит.

159
00:12:46,980 --> 00:12:50,980
Не все префиксы безобидны, но большинство вот так сидит.

160
00:12:52,980 --> 00:13:00,980
Окей. Будет ли вот команда x и x добавить префикс 67, 66 и дальше выход команды?

161
00:13:01,980 --> 00:13:02,980
Еще раз.

162
00:13:03,980 --> 00:13:05,980
То, что вы говорите, это префикс?

163
00:13:06,980 --> 00:13:07,980
66.

164
00:13:08,980 --> 00:13:10,980
А для адресов из плюсов 67?

165
00:13:11,980 --> 00:13:12,980
Да.

166
00:13:12,980 --> 00:13:13,980
Для команды вот этого надо.

167
00:13:14,980 --> 00:13:15,980
С регистрации давай 66.

168
00:13:16,980 --> 00:13:17,980
Ну, 67, 66.

169
00:13:18,980 --> 00:13:19,980
То есть даже два байта.

170
00:13:20,980 --> 00:13:21,980
А оно проразное?

171
00:13:22,980 --> 00:13:23,980
Другого не включают?

172
00:13:24,980 --> 00:13:28,980
Ну да, здесь как бы хотел опустить.

173
00:13:29,980 --> 00:13:31,980
На самом деле, с адресацией даже самое интересное,

174
00:13:32,980 --> 00:13:33,980
если команда обращается к памяти,

175
00:13:34,980 --> 00:13:36,980
у вас есть такой 16-битный режим адресации

176
00:13:37,980 --> 00:13:39,980
и 30-битный режим адресации.

177
00:13:39,980 --> 00:13:44,980
И опять-таки используется дефолт соответствующей битности,

178
00:13:45,980 --> 00:13:49,980
и вы можете при помощи другого префикса переключить,

179
00:13:50,980 --> 00:13:52,980
какого вида у вас адресация в команде.

180
00:13:53,980 --> 00:13:57,980
Адресация через вот 16-битный способ или адресация через 30-битный.

181
00:13:58,980 --> 00:13:59,980
Префикс кодировки.

182
00:14:00,980 --> 00:14:02,980
Префикс изменения битности адреса.

183
00:14:03,980 --> 00:14:04,980
Кодировки.

184
00:14:05,980 --> 00:14:06,980
В смысле?

185
00:14:06,980 --> 00:14:08,980
Еще раз, у нас здесь команда, она как-то закодирована.

186
00:14:09,980 --> 00:14:10,980
Да.

187
00:14:11,980 --> 00:14:13,980
Префикс, он как бы считается частью кода команды.

188
00:14:14,980 --> 00:14:15,980
Да, да, вот я правильно.

189
00:14:16,980 --> 00:14:17,980
А если у нас есть ADD формы,

190
00:14:18,980 --> 00:14:19,980
когда у нас одно слагаемое,

191
00:14:20,980 --> 00:14:21,980
и там появление определенного регистратора,

192
00:14:22,980 --> 00:14:23,980
однобайтное ADD?

193
00:14:24,980 --> 00:14:26,980
Ты что, про IELTS, ICH?

194
00:14:27,980 --> 00:14:32,980
Нет, нет, имеется в виду однобайтная длина команды 1 байт.

195
00:14:33,980 --> 00:14:34,980
Ну и что?

196
00:14:34,980 --> 00:14:35,980
Имеет один оперант, ADD.

197
00:14:36,980 --> 00:14:38,980
И она этот оперант прибавляет и не помнит какой-то регистр.

198
00:14:39,980 --> 00:14:40,980
По-моему, в IELTS всегда.

199
00:14:41,980 --> 00:14:44,980
Ну это типа как оптимизация, что мы в основном какой-то регистр часто что-то прибавляем,

200
00:14:45,980 --> 00:14:46,980
и мы хотим закодировать это в один байт.

201
00:14:47,980 --> 00:14:48,980
Нет, смотри.

202
00:14:49,980 --> 00:14:50,980
Нет, нет, погоди.

203
00:14:51,980 --> 00:14:52,980
Однобайтного прибавления нет,

204
00:14:53,980 --> 00:14:54,980
потому что просто чтобы закодировать константу,

205
00:14:55,980 --> 00:14:56,980
тебе нужно хотя бы один байт.

206
00:14:57,980 --> 00:14:58,980
Нет, нет, там...

207
00:14:59,980 --> 00:15:00,980
Есть команда ингредиентов.

208
00:15:01,980 --> 00:15:02,980
Нет, нет, есть именно ADD,

209
00:15:02,980 --> 00:15:05,980
там закодированный регистр куда-то добавляет,

210
00:15:06,980 --> 00:15:09,980
а мы указываем регистр, который добавляется к этому регистру.

211
00:15:10,980 --> 00:15:16,980
То есть, ну, условно ADD, IELTS, IELTS, он будет делать IELTS плюс равно IELTS.

212
00:15:17,980 --> 00:15:20,980
Вот, а как ты вот 16 и 32 бита?

213
00:15:21,980 --> 00:15:22,980
Хорошо.

214
00:15:23,980 --> 00:15:24,980
Вот у тебя эта команда, она вот какая?

215
00:15:25,980 --> 00:15:26,980
Ну да.

216
00:15:27,980 --> 00:15:31,980
Она работает с исходным, 16 битным регистром.

217
00:15:32,980 --> 00:15:35,980
Если она работает с 16 битным регистром как с данными,

218
00:15:36,980 --> 00:15:41,980
то в 32 битном мире она будет интерпретироваться как команда,

219
00:15:42,980 --> 00:15:44,980
работающая с аналогичным 32 битным регистром.

220
00:15:45,980 --> 00:15:47,980
Если ты ничего не делаешь, то этот код означает вот это.

221
00:15:48,980 --> 00:15:53,980
Если ты ставишь перед этим кодом префикс 0x66,

222
00:15:54,980 --> 00:16:00,980
то интерпретация, да, кто это, изменяется на противоположную.

223
00:16:00,980 --> 00:16:07,980
То есть, в 16 битном мире оно интерпретирует это как работу с 32 битным регистром,

224
00:16:08,980 --> 00:16:10,980
а с 32 битным как с 16 битным.

225
00:16:11,980 --> 00:16:14,980
То есть, еще раз, это интерпретация именно вот смысла команды.

226
00:16:15,980 --> 00:16:19,980
Сколько там байтиков команда образует, это неважно.

227
00:16:20,980 --> 00:16:26,980
Команда логически работает вот с этим регистром и процессором интерпретирует с таким образом.

228
00:16:26,980 --> 00:16:32,980
И все эти дефолтные регистры, они тоже ведут себя аналогично.

229
00:16:33,980 --> 00:16:38,980
То есть, переключается вот такой смысл битности команды.

230
00:16:39,980 --> 00:16:43,980
А можно ли мы в рантайме менять битность?

231
00:16:44,980 --> 00:16:45,980
Что, это в рантайме происходит?

232
00:16:46,980 --> 00:16:47,980
Не-не, не битность.

233
00:16:48,980 --> 00:16:49,980
Я понимаю, что там ссорятся.

234
00:16:50,980 --> 00:16:53,980
Я имею в виду, можем ли мы в рантайме, особенно если мы исполняем все это в битном режиме,

235
00:16:53,980 --> 00:16:55,980
если просто, типа, начать?

236
00:16:56,980 --> 00:16:57,980
А, ну да, все ровно.

237
00:16:58,980 --> 00:17:05,980
Переключить режим можно, но переключение режима, как режим работает, это при виде ровных действий.

238
00:17:06,980 --> 00:17:08,980
То есть, на это нужна права ядра системы.

239
00:17:09,980 --> 00:17:14,980
И если вы переключите режим, то система будет очень удивлена.

240
00:17:15,980 --> 00:17:18,980
Поэтому, если только не вы сами себе, а операционная система,

241
00:17:19,980 --> 00:17:22,980
даже если вы добудете себе эти права,

242
00:17:23,980 --> 00:17:24,980
вы не хотите это сделать.

243
00:17:25,980 --> 00:17:27,980
Потому что это покрашит операционную систему.

244
00:17:28,980 --> 00:17:30,980
Ну, если виртуальный 16-битный режим.

245
00:17:31,980 --> 00:17:32,980
Да?

246
00:17:33,980 --> 00:17:37,980
Ну, если режим работы процессора похожий, пока мы их можем благополучно игнорировать,

247
00:17:38,980 --> 00:17:43,980
я вам просто пока рассказываю ту часть, которая необходима для понимания происходящего.

248
00:17:44,980 --> 00:17:50,980
То есть, первый важный факт, что 3D-битное расширение, оно было такое вот покрывающее все.

249
00:17:50,980 --> 00:17:58,980
И возможность использования 32-бит связана с тем, ваш процессор 32-битный или нет.

250
00:17:59,980 --> 00:18:06,980
Из другого режима, ну, только небольшие усилия, и вы получаете все, что там имеет ваш процессор.

251
00:18:07,980 --> 00:18:12,980
В отличие от этого, 64-битный режим, это было совсем по-другому сделано.

252
00:18:13,980 --> 00:18:15,980
Оно было сделано следующим образом.

253
00:18:16,980 --> 00:18:19,980
Что вот эти всякие новые штучки, которые я вам расскажу сейчас,

254
00:18:20,980 --> 00:18:23,980
они все работают только в 64-битном режиме.

255
00:18:24,980 --> 00:18:27,980
То есть, то, что процессор умеет 64-бит,

256
00:18:29,980 --> 00:18:33,980
все это видно только из 64-битного режима.

257
00:18:36,980 --> 00:18:41,980
Из 32-битного и 16-ти вы никак не достучитесь до этих новых вещей.

258
00:18:43,980 --> 00:18:49,980
Поэтому вот 64-битные штучки, они привязаны к 64-битному режиму.

259
00:18:51,980 --> 00:18:53,980
Понятно?

260
00:18:54,980 --> 00:19:00,980
Вот. А 32-битные и 16-битные работают в режиме такой жесткой обратной совместимости,

261
00:19:01,980 --> 00:19:04,980
как они работали раньше, вот один в один и работают.

262
00:19:05,980 --> 00:19:08,980
Также небольшая историческая исправка по происходящему.

263
00:19:09,980 --> 00:19:13,980
Вообще, 64-битное расширение называется...

264
00:19:20,980 --> 00:19:22,980
Он D64.

265
00:19:22,980 --> 00:19:24,980
Потому что это AMD-шный расширение.

266
00:19:25,980 --> 00:19:29,980
Большинство расширений, которые мы рассматривали, они Intel-ские.

267
00:19:29,980 --> 00:19:34,980
Ну, потому что Intel создает такие структуры и так далее.

268
00:19:34,980 --> 00:19:39,980
Но вот в 64-битном мире ситуация изменилась.

269
00:19:39,980 --> 00:19:43,980
А именно, были времена N64.

270
00:19:44,980 --> 00:19:47,980
И Intel хотели...

271
00:19:47,980 --> 00:19:53,980
Было понимание, что надо переходить на 64-битную архитектуру.

272
00:19:53,980 --> 00:19:55,980
Почему, кстати говоря?

273
00:19:59,980 --> 00:20:02,980
Да. Проблемы с адресами.

274
00:20:03,980 --> 00:20:13,980
И были всякие докладки, которые позволяли операционной системе использовать больше, чем 4 гигабайта памяти.

275
00:20:13,980 --> 00:20:16,980
Но вот без страданий...

276
00:20:16,980 --> 00:20:20,980
Прикладному софту доступно максимум 4 гигабайта.

277
00:20:21,980 --> 00:20:27,980
Притом, по факту, вам даже, скорее всего, доступны не 4 гигабайта, а 2.

278
00:20:28,980 --> 00:20:33,980
В связи с тем, как обычно устроены операционные системы...

279
00:20:34,980 --> 00:20:40,980
Операционные системы любят резервировать половину адресного пространства под себя.

280
00:20:41,980 --> 00:20:44,980
Поэтому из 4 гигабайт возможных адресов...

281
00:20:44,980 --> 00:20:50,980
Система резервирует под себя половину. Обычно это верхняя половина.

282
00:20:50,980 --> 00:20:57,980
То есть у вас доступно вашему ходу 2 гигабайта адресов.

283
00:20:58,980 --> 00:21:05,980
И всякие способы, как нарызать эти 2 гигабайта, они, конечно, были и существуют.

284
00:21:05,980 --> 00:21:07,980
Но это откровенно больно.

285
00:21:09,980 --> 00:21:12,980
Поэтому, чтобы не страдать...

286
00:21:12,980 --> 00:21:17,980
И чтобы можно было пользоваться все возрастающими объемами оперативки...

287
00:21:18,980 --> 00:21:24,980
Всем была понятна необходимость перехода на 64-битную арифметику.

288
00:21:25,980 --> 00:21:27,980
И изменение размера указателя...

289
00:21:27,980 --> 00:21:33,980
Это достаточно фундаментальное изменение, чтобы сказать, что это новый режим работы.

290
00:21:33,980 --> 00:21:36,980
Потому что, ну, все сломается.

291
00:21:36,980 --> 00:21:39,980
Здесь все сломается, поэтому...

292
00:21:39,980 --> 00:21:41,980
Это несовместимо.

293
00:21:41,980 --> 00:21:44,980
Почему верхняя?

294
00:21:44,980 --> 00:21:47,980
Ну, так выбрали.

295
00:21:47,980 --> 00:21:49,980
И, типа, нижние адреса...

296
00:21:49,980 --> 00:21:53,980
Там точно, вот, пацаны, около нуля что-то резервируют.

297
00:21:53,980 --> 00:22:00,980
Нет, около нуля резервируются ради облегчения поиска ошибок.

298
00:22:00,980 --> 00:22:07,980
Исключительно ради того, чтобы 0-пойнтеры не обращались четко узнать куда, а обладали впадением.

299
00:22:07,980 --> 00:22:09,980
Там тоже летом гигабайты не было?

300
00:22:09,980 --> 00:22:10,980
Нет, не лучше.

301
00:22:10,980 --> 00:22:12,980
Там порядка 64-ки добавились.

302
00:22:12,980 --> 00:22:15,980
Ну, опять-таки, от системы зависит.

303
00:22:15,980 --> 00:22:18,980
И вот это вообще не принципиально.

304
00:22:18,980 --> 00:22:26,980
На самом деле, если вы явно попросите операционку, то вы можете выделить память в нуле.

305
00:22:26,980 --> 00:22:29,980
То есть, она по диполу так не делает.

306
00:22:29,980 --> 00:22:37,980
Но, к примеру, раньше можно было сказать, вот, на низкоуровневыми командами операционки...

307
00:22:37,980 --> 00:22:39,980
Давай, вот, отобразим.

308
00:22:39,980 --> 00:22:42,980
Кусок вот этих вот адресов куда-нибудь.

309
00:22:42,980 --> 00:22:48,980
И можно было сделать 0-пойнтер, через который все работает.

310
00:22:48,980 --> 00:22:50,980
Но, еще раз.

311
00:22:50,980 --> 00:22:55,980
Это было очень такое неожиданное поведение.

312
00:22:55,980 --> 00:23:02,980
И работало в одной недочери в плане того, что компиляторы, еще раз не забывайте, проявляют всякий нездоровый цвет.

313
00:23:02,980 --> 00:23:08,980
А именно, компиляторы знают, что по 0-пойнтеру ничего быть не может.

314
00:23:09,980 --> 00:23:16,980
Поэтому, в тех местах, где компиляторы не используют интеллект в этом месте,

315
00:23:16,980 --> 00:23:21,980
после такого выделения памяти, у вас действительно, сквозь 0-пойнтер работает.

316
00:23:21,980 --> 00:23:28,980
Но, в тех местах, где компиляторы проявляют интеллект, у вас сломается.

317
00:23:28,980 --> 00:23:33,980
То есть, этот адрес, он будет посчитан как невалидный.

318
00:23:33,980 --> 00:23:38,980
Более того, 0-пойнтеры, они нередко используются как значение для вот такого...

319
00:23:39,980 --> 00:23:45,980
несуществующего результата или аргумента.

320
00:23:45,980 --> 00:23:54,980
Поэтому, даже если вы выделите там память, это значение просто будет сигнализировать и проверяться как несуществующее значение.

321
00:23:54,980 --> 00:24:05,980
Поэтому, чтобы не заморачиваться с подобным, и чтобы облегчить оплавку, операционки в районе 0 не выделяют память.

322
00:24:05,980 --> 00:24:07,980
Но это не какая-то техническая особенность.

323
00:24:07,980 --> 00:24:08,980
Это вот...

324
00:24:09,980 --> 00:24:12,980
когда я полностью сорву...

325
00:24:12,980 --> 00:24:14,980
0 и больше.

326
00:24:14,980 --> 00:24:15,980
Да.

327
00:24:15,980 --> 00:24:17,980
На XF6 умолчание в 0-м текст на лице.

328
00:24:17,980 --> 00:24:18,980
В 0-м?

329
00:24:18,980 --> 00:24:21,980
На XF6 умолчание в 0-м районе становится текстом.

330
00:24:21,980 --> 00:24:23,980
С 0-го и выше.

331
00:24:23,980 --> 00:24:25,980
Еще раз. Какой? 086, что ли?

332
00:24:25,980 --> 00:24:30,980
XF6. Это операционная система учебная под респект.

333
00:24:30,980 --> 00:24:32,980
А, ну, может быть.

334
00:24:32,980 --> 00:24:35,980
Учебная операционная система может делать что угодно.

335
00:24:35,980 --> 00:24:38,980
Но вот реальные операционки в 0 стараются не мать.

336
00:24:39,980 --> 00:24:41,980
Потому что они не могут мать.

337
00:24:41,980 --> 00:24:45,980
Но они стараются так не делать, чтобы не удивлять слов.

338
00:24:45,980 --> 00:24:48,980
Потому что вот про ньюпоинтеры.

339
00:24:48,980 --> 00:24:50,980
А, есть соглашение.

340
00:24:50,980 --> 00:24:53,980
И Б, это помощь в оплавке.

341
00:24:53,980 --> 00:25:01,980
То есть, если вы там забежали, лучше упасть, чем тихо писать непонятно какие-то бреда.

342
00:25:01,980 --> 00:25:04,980
Это все отсутствие прикосновений?

343
00:25:04,980 --> 00:25:06,980
Нет, это только другое собственно.

344
00:25:06,980 --> 00:25:07,980
Но это еще раз.

345
00:25:07,980 --> 00:25:10,980
Это оплавка.

346
00:25:10,980 --> 00:25:13,980
Вот.

347
00:25:13,980 --> 00:25:15,980
Так, что мы куда-то ушли?

348
00:25:15,980 --> 00:25:17,980
Что у вас осталось?

349
00:25:17,980 --> 00:25:21,980
Хотя, 4664.

350
00:25:21,980 --> 00:25:23,980
Битный режим.

351
00:25:23,980 --> 00:25:24,980
Зачем ему это?

352
00:25:24,980 --> 00:25:26,980
А, нет, парадочное пространство.

353
00:25:26,980 --> 00:25:28,980
То есть, еще раз.

354
00:25:28,980 --> 00:25:33,980
Несмотря на то, что у вас адресного пространства 4 гигабайта,

355
00:25:33,980 --> 00:25:36,980
фактически в программе доступно порядка двух.

356
00:25:36,980 --> 00:25:40,980
Ну, при помощи некоторого количества страданий и извращений,

357
00:25:40,980 --> 00:25:44,980
вы можете выбить в операционке 3 гигабайта.

358
00:25:44,980 --> 00:25:47,980
Но вот больше вряд ли.

359
00:25:47,980 --> 00:25:51,980
Нет, это опять-таки нужно включить режим гидрат,

360
00:25:51,980 --> 00:25:59,980
для того, чтобы операционка просто по-другому разделила адресное пространство между ведром и визуалом.

361
00:25:59,980 --> 00:26:04,980
Поэтому, ну, стала понятна необходимость того,

362
00:26:04,980 --> 00:26:09,980
чтобы перейти на 64-битную адресацию.

363
00:26:09,980 --> 00:26:12,980
И Intel решили сделать следующее.

364
00:26:12,980 --> 00:26:16,980
Они решили, что, ну, хватит уже пинать x86,

365
00:26:16,980 --> 00:26:21,980
надо сделать новую, крутую, прогрессивную,

366
00:26:21,980 --> 00:26:24,980
а самое главное, такую архитектуру,

367
00:26:24,980 --> 00:26:28,980
на которую лицензии будет только у нас, ни у кого больше.

368
00:26:28,980 --> 00:26:33,980
Чтобы всякие AMD и прочие не портили,

369
00:26:33,980 --> 00:26:36,980
не портили им бизнес.

370
00:26:36,980 --> 00:26:41,980
И сделали штуку под названием Itanium.

371
00:26:41,980 --> 00:26:50,980
Itanium, которая в сокращении называется IA64,

372
00:26:50,980 --> 00:26:52,980
если вы увидите.

373
00:26:52,980 --> 00:26:57,980
Вот такое название. Это Itanium.

374
00:26:57,980 --> 00:27:01,980
Но Itanium оказался Итаником.

375
00:27:01,980 --> 00:27:03,980
Народ его так окрестил.

376
00:27:03,980 --> 00:27:08,980
А именно, там были разного рода проблемы.

377
00:27:08,980 --> 00:27:12,980
И технические, и всякие логические, и маркетинговые.

378
00:27:12,980 --> 00:27:16,980
Ну, в общем, оно не взлетело.

379
00:27:16,980 --> 00:27:21,980
Да, еще раз, это была другая совершенно архитектура,

380
00:27:21,980 --> 00:27:24,980
несовместимая с x86.

381
00:27:24,980 --> 00:27:31,980
Там были некоторые возможности по аппаратной помощи в эмуляции x86,

382
00:27:31,980 --> 00:27:34,980
но они работали настолько плохо,

383
00:27:34,980 --> 00:27:39,980
что чисто программная эмуляция, которую допилили там через некоторое время,

384
00:27:39,980 --> 00:27:45,980
работала быстрее, чем через эти аппаратные команды поддержки.

385
00:27:45,980 --> 00:27:48,980
То есть настолько там было все плохо.

386
00:27:48,980 --> 00:27:57,980
Вот. И всякую там youtube и подобное портировали на Itanium очень быстро.

387
00:27:57,980 --> 00:28:00,980
Но вот портировать этот прикладной стоп,

388
00:28:00,980 --> 00:28:04,980
это удовольствие дорогое, медленное.

389
00:28:04,980 --> 00:28:09,980
И в режиме эмуляции оно работало, как я уже сказал, весьма пошире.

390
00:28:09,980 --> 00:28:13,980
А стоило, о буй, господи.

391
00:28:13,980 --> 00:28:20,980
И там всякие дедлайны они тоже многократно нарушали.

392
00:28:20,980 --> 00:28:24,980
Поэтому все это, ну, не взлетело.

393
00:28:24,980 --> 00:28:27,980
А почему эмуляция быстрее была?

394
00:28:27,980 --> 00:28:29,980
Ну, там криво было сделано.

395
00:28:29,980 --> 00:28:31,980
Оно работало как медленно.

396
00:28:31,980 --> 00:28:32,980
Ну, железки.

397
00:28:32,980 --> 00:28:34,980
Там были и всякие принципиальные проблемы.

398
00:28:34,980 --> 00:28:37,980
Например, размер страничек там был любой.

399
00:28:37,980 --> 00:28:39,980
Там были странички 8-килобайтные,

400
00:28:39,980 --> 00:28:42,980
тогда их, по-моему, существует 6-4-килобайтные.

401
00:28:42,980 --> 00:28:44,980
И через большие странички и меньшие,

402
00:28:44,980 --> 00:28:48,980
они вылились по щекам, по щекам.

403
00:28:48,980 --> 00:28:53,980
То есть там было много всяких технических и маркетинговых,

404
00:28:53,980 --> 00:28:55,980
и всяких других проблем.

405
00:28:55,980 --> 00:28:58,980
В итоге оно не взлетело.

406
00:28:58,980 --> 00:29:00,980
Когда народ, конечно, не было, что испугался.

407
00:29:00,980 --> 00:29:04,980
Вот, сейчас тут и все выпустят, захватят.

408
00:29:04,980 --> 00:29:07,980
Новая такая фута-архитектура.

409
00:29:09,980 --> 00:29:14,980
И где-то через год, ну так, не очень далеко от ИА-64,

410
00:29:14,980 --> 00:29:20,980
АМДшники выпустили свою попытку 64-бит,

411
00:29:20,980 --> 00:29:22,980
которая называлась АМД-64,

412
00:29:22,980 --> 00:29:26,980
и заключалась в том, что давайте закостылим

413
00:29:26,980 --> 00:29:30,980
новый режим к x86,

414
00:29:30,980 --> 00:29:37,980
где вы можете держать процессор в старом 64-битном режиме,

415
00:29:37,980 --> 00:29:41,980
и оно будет работать прямо как раньше, один в один,

416
00:29:41,980 --> 00:29:43,980
с полной скоростью,

417
00:29:43,980 --> 00:29:45,980
никаких проблем,

418
00:29:45,980 --> 00:29:48,980
а можете перейти в 64-битный режим,

419
00:29:48,980 --> 00:29:50,980
там у вас будут новые вкусняшки,

420
00:29:50,980 --> 00:29:55,980
и даже из 64-битного режима есть режим совместимости,

421
00:29:56,980 --> 00:30:00,980
для, вот, юзерспейса прикладного софта,

422
00:30:00,980 --> 00:30:05,980
который также работает прямо вот практически один в один,

423
00:30:05,980 --> 00:30:06,980
как и раньше.

424
00:30:06,980 --> 00:30:10,980
То есть, чтобы перейти вот на АМД-64,

425
00:30:10,980 --> 00:30:13,980
не нужно ничего прикомпилировать,

426
00:30:13,980 --> 00:30:18,980
вы можете использовать вообще этот процессор в x86-битном режиме,

427
00:30:18,980 --> 00:30:20,980
он будет работать с полной скоростью,

428
00:30:20,980 --> 00:30:24,980
захотите 64-бита, вам нужна 64-битная операционка,

429
00:30:24,980 --> 00:30:26,980
64-битные дрова,

430
00:30:26,980 --> 00:30:29,980
а юзерспейс вы можете продолжить использовать

431
00:30:29,980 --> 00:30:32,980
рассеянный 2-битный вместе с 64-битным,

432
00:30:32,980 --> 00:30:35,980
ну, то есть максимально удобный переход,

433
00:30:35,980 --> 00:30:38,980
не больный ни с какой точки зрения.

434
00:30:38,980 --> 00:30:44,980
И вот всё это, оно одновременно совпало

435
00:30:44,980 --> 00:30:49,980
с выходом очень удачной архитектуры АМД-шной,

436
00:30:49,980 --> 00:30:52,980
это был процессор Athlon 64,

437
00:30:52,980 --> 00:30:55,980
который был технически просто очень удачный.

438
00:30:56,980 --> 00:30:58,980
Он и сам по себе хорошо работал,

439
00:30:58,980 --> 00:31:03,980
и там случились довольно существенные изменения архитектурные,

440
00:31:03,980 --> 00:31:06,980
что контроллер памяти встроили в ядро,

441
00:31:06,980 --> 00:31:09,980
раньше он находился в отдельной мехосхеме Северный мост,

442
00:31:09,980 --> 00:31:12,980
то есть там ещё доступ к памяти сильно ускорился,

443
00:31:12,980 --> 00:31:15,980
поэтому вот эти вот процессоры АМД-64,

444
00:31:15,980 --> 00:31:18,980
они в клочья рвали всё интеловское,

445
00:31:18,980 --> 00:31:21,980
и по цене в том числе.

446
00:31:21,980 --> 00:31:24,980
Поэтому народ, конечно же,

447
00:31:24,980 --> 00:31:27,980
вообще не хотел покупать эти ПИА,

448
00:31:27,980 --> 00:31:30,980
и массово покупал у рабочих.

449
00:31:30,980 --> 00:31:33,980
То есть там был период времени,

450
00:31:33,980 --> 00:31:36,980
когда все топовые процессы, они были АМД-шными,

451
00:31:36,980 --> 00:31:39,980
ну, что, собственно говоря, наблюдается, честно говоря, и сегодня.

452
00:31:39,980 --> 00:31:46,980
И у него снова такая полоса страданий и фигней.

453
00:31:46,980 --> 00:31:53,980
Вот. Поэтому, если вы увидите название АМД-64,

454
00:31:54,980 --> 00:32:01,980
то вот это вот просто название 64-х битвы архитектуры ПИА-86.

455
00:32:01,980 --> 00:32:08,980
И потом, когда стало понятно, что Даня вернулся,

456
00:32:08,980 --> 00:32:11,980
АМД-64 действительно успешно,

457
00:32:11,980 --> 00:32:16,980
им, по-моему, пришлось поддержать АМД-64-решение.

458
00:32:16,980 --> 00:32:19,980
Конечно, они не могли его назвать АМД-64,

459
00:32:19,980 --> 00:32:23,980
это, по-моему, в какой-то документации обозначается.

460
00:32:24,980 --> 00:32:27,980
Но, в смысле, вот это не меняется.

461
00:32:27,980 --> 00:32:30,980
Хотя потом такое более нейтральное название,

462
00:32:30,980 --> 00:32:38,980
как Х-86-64 и даже еще, короче, Х-64.

463
00:32:38,980 --> 00:32:40,980
Вот это вот все полные синонимы.

464
00:32:40,980 --> 00:32:43,980
Вот это — это совсем другое,

465
00:32:43,980 --> 00:32:46,980
а вот это — это полные синонимы.

466
00:32:46,980 --> 00:32:48,980
— А у них права были у АМД?

467
00:32:48,980 --> 00:32:52,980
— Знаешь, что делать? С правами там интересная вещь.

468
00:32:52,980 --> 00:32:58,980
Современная Х-86-архитектура, она покрыта патентами,

469
00:32:58,980 --> 00:33:01,980
и она покрыта патентами весьма плотно

470
00:33:01,980 --> 00:33:04,980
и со стороны Intel, и со стороны АМД.

471
00:33:04,980 --> 00:33:07,980
Если любая из этих компашек объявит,

472
00:33:07,980 --> 00:33:11,980
что мы не разрешаем пользоваться нашими патентами,

473
00:33:11,980 --> 00:33:17,980
то другой не сможет сделать современный процессор на Х-86.

474
00:33:17,980 --> 00:33:21,980
То есть у них там сейчас полная взаимозависимость,

475
00:33:22,980 --> 00:33:25,980
и мирная договоренность о том,

476
00:33:25,980 --> 00:33:29,980
что другая компашка может пользоваться без проблем

477
00:33:29,980 --> 00:33:31,980
патентами другой компашки.

478
00:33:31,980 --> 00:33:35,980
— Так у них же изначально вот...

479
00:33:35,980 --> 00:33:36,980
— Нет, еще раз.

480
00:33:36,980 --> 00:33:41,980
Исходно Intel выдала разрешение на использование Х-86,

481
00:33:41,980 --> 00:33:44,980
ну, базовое для Х-86,

482
00:33:44,980 --> 00:33:47,980
всякие расширения и прочее.

483
00:33:47,980 --> 00:33:50,980
Там, конечно же, Intel пытались отсудить по максимуму,

484
00:33:50,980 --> 00:33:52,980
если бы они тут не лезли,

485
00:33:52,980 --> 00:33:54,980
и решали бы убить.

486
00:33:54,980 --> 00:33:56,980
Но вот в современном мире

487
00:33:56,980 --> 00:34:00,980
там у них полная взаимная зависимость.

488
00:34:00,980 --> 00:34:03,980
То есть если АМДшный патент убрать,

489
00:34:03,980 --> 00:34:09,980
то он не сможет сделать Х-86 процессор, и наоборот.

490
00:34:09,980 --> 00:34:12,980
А вот техническое решение только подчеркивает.

491
00:34:12,980 --> 00:34:16,980
То есть это вообще чисто АМДшный решение.

492
00:34:16,980 --> 00:34:18,980
Почему, ну, по крайней мере, раньше,

493
00:34:18,980 --> 00:34:21,980
когда еще и А-64, и А-97 все забыли,

494
00:34:21,980 --> 00:34:24,980
там всякие графа еще включаются,

495
00:34:24,980 --> 00:34:27,980
народ, наверное, редко выбирал

496
00:34:27,980 --> 00:34:30,980
всякие парики из папочки А-64,

497
00:34:30,980 --> 00:34:33,980
потому что у меня не АМД процессор,

498
00:34:33,980 --> 00:34:36,980
а АМД-64 и А-64.

499
00:34:36,980 --> 00:34:38,980
Правильный выбор — АМД-64.

500
00:34:38,980 --> 00:34:41,980
И, важно, у вас там Intel процессоры не Intel,

501
00:34:41,980 --> 00:34:44,980
потому что это название 64-метрового режима.

502
00:34:44,980 --> 00:34:47,980
Но сейчас уже так редко встречается,

503
00:34:47,980 --> 00:34:50,980
сейчас уже на ноль встречается либо Х-64,

504
00:34:50,980 --> 00:34:52,980
такая самая короткая форма,

505
00:34:52,980 --> 00:34:55,980
либо Х-86.

506
00:34:55,980 --> 00:34:59,980
Почему 64, если реально адресуется 48?

507
00:34:59,980 --> 00:35:02,980
Потому что указателем у вас используются

508
00:35:02,980 --> 00:35:06,980
шестничные узлы числа.

509
00:35:06,980 --> 00:35:09,980
Там есть, конечно, особенности,

510
00:35:09,980 --> 00:35:11,980
сколько из них используется,

511
00:35:11,980 --> 00:35:14,980
и некоторые специальные правила,

512
00:35:14,980 --> 00:35:18,980
но, честно говоря, адреса шестничные нет.

513
00:35:18,980 --> 00:35:22,980
Поэтому 64 — это нормальное название.

514
00:35:22,980 --> 00:35:26,980
И вот эти вот особенности, они не принципиальные.

515
00:35:26,980 --> 00:35:28,980
Это такие технические ограничения,

516
00:35:28,980 --> 00:35:32,980
но ничто не мешает выпустить процессор,

517
00:35:32,980 --> 00:35:35,980
который имеет полную поддержку

518
00:35:35,980 --> 00:35:38,980
всех 64-бит адресов

519
00:35:38,980 --> 00:35:41,980
и ничего не сломает их со всех.

520
00:35:41,980 --> 00:35:43,980
Понятно?

521
00:35:43,980 --> 00:35:47,980
То есть это нормально, совершенно правильно,

522
00:35:47,980 --> 00:35:50,980
вызывать это 64-бит адрес.

523
00:35:50,980 --> 00:35:51,980
— Ну, это, кстати, не проблема,

524
00:35:51,980 --> 00:35:53,980
кстати, соц, который будет работать только на одном конце,

525
00:35:53,980 --> 00:35:55,980
и он просто сломается из-за того,

526
00:35:55,980 --> 00:35:58,980
что там, наверное, некоторые предположения.

527
00:35:58,980 --> 00:35:59,980
— Ничего, конечно.

528
00:35:59,980 --> 00:36:01,980
— Потому что некоторый соц

529
00:36:01,980 --> 00:36:02,980
все же может сломаться от того,

530
00:36:02,980 --> 00:36:06,980
что адреса 48 поднимется до 64.

531
00:36:06,980 --> 00:36:08,980
— Ну, знаешь...

532
00:36:08,980 --> 00:36:10,980
— Специфический соц, он может.

533
00:36:10,980 --> 00:36:13,980
— Это как всякие системы защиты сломались,

534
00:36:13,980 --> 00:36:15,980
ковидоинтелсы выпустили

535
00:36:15,980 --> 00:36:17,980
процессор с асимметричным ядром.

536
00:36:17,980 --> 00:36:20,980
— Ну, конечно, наверняка кто-то где-то сломается.

537
00:36:20,980 --> 00:36:23,980
Это такая известная история,

538
00:36:23,980 --> 00:36:28,980
что вот там новая версия текстового редактора,

539
00:36:28,980 --> 00:36:30,980
мы там пофиксили багу,

540
00:36:30,980 --> 00:36:33,980
которая, когда вы зажимаете пробел,

541
00:36:33,980 --> 00:36:38,980
нагревает процессор на 100 градусов,

542
00:36:38,980 --> 00:36:41,980
а в ответ пишет пользователь

543
00:36:41,980 --> 00:36:45,980
«Ой, верните обратно, у меня там не работает control,

544
00:36:45,980 --> 00:36:48,980
поэтому я и сделал скрипт,

545
00:36:48,980 --> 00:36:53,980
что если температура процессора поднимается до 90 градусов,

546
00:36:53,980 --> 00:36:56,980
а вы интерпретируете, как будто я нажал control,

547
00:36:56,980 --> 00:36:59,980
поэтому, верните все обратно,

548
00:36:59,980 --> 00:37:01,980
я хочу старое поведение».

549
00:37:01,980 --> 00:37:04,980
То есть наверняка кто-то

550
00:37:04,980 --> 00:37:06,980
так же себя может вести,

551
00:37:06,980 --> 00:37:09,980
но это его личные проблемы.

552
00:37:09,980 --> 00:37:13,980
В целом, такое наблюдаться неровно.

553
00:37:13,980 --> 00:37:19,980
Итак, вот еще раз,

554
00:37:19,980 --> 00:37:22,980
все это — полные синонимы,

555
00:37:22,980 --> 00:37:25,980
поэтому если вы где-то видите AMD 64,

556
00:37:25,980 --> 00:37:27,980
это просто шестидесятый репитмин

557
00:37:27,980 --> 00:37:29,980
в режиме x86,

558
00:37:29,980 --> 00:37:31,980
ни больше, ни меньше,

559
00:37:31,980 --> 00:37:33,980
длинный вот такой у вас процессор,

560
00:37:33,980 --> 00:37:36,980
ни толстый — никакой разницы.

561
00:37:36,980 --> 00:37:38,980
Что у нас произошло

562
00:37:38,980 --> 00:37:41,980
в этом самом шестидесятый репитмин x86?

563
00:37:41,980 --> 00:37:42,980
Ну, первое,

564
00:37:42,980 --> 00:37:44,980
вы уже догадываетесь,

565
00:37:44,980 --> 00:37:46,980
регистры расширили.

566
00:38:00,980 --> 00:38:02,980
Регистры расширили,

567
00:38:02,980 --> 00:38:07,980
и теперь то, что было eax,

568
00:38:07,980 --> 00:38:10,980
стало rax.

569
00:38:12,980 --> 00:38:14,980
То есть картинка вот такая.

570
00:38:14,980 --> 00:38:16,980
Все это вместе.

571
00:38:16,980 --> 00:38:21,980
rax — это eax,

572
00:38:21,980 --> 00:38:27,980
аax — h,

573
00:38:27,980 --> 00:38:34,980
а l — 0,

574
00:38:34,980 --> 00:38:38,980
и x86 — 0,

575
00:38:38,980 --> 00:38:40,980
и x86 — 0,

576
00:38:40,980 --> 00:38:42,980
и y — 0,

577
00:38:42,980 --> 00:38:44,980
и x86 — 0,

578
00:38:44,980 --> 00:38:46,980
и y — 0,

579
00:38:46,980 --> 00:38:48,980
и Ñ — 0.

580
00:38:48,980 --> 00:38:51,980
Т.е. все эти гибкие сложности

581
00:38:51,980 --> 00:39:00,980
набрасываются в рамках

582
00:39:00,980 --> 00:39:02,980
резерва,

583
00:39:02,980 --> 00:39:04,980
насколько я upon the whole

584
00:39:04,980 --> 00:39:07,980
ierz interval

585
00:39:07,980 --> 00:39:08,980
5000p.

586
00:39:08,980 --> 00:39:15,720
что у них вот такого разрезания не было.

587
00:39:17,340 --> 00:39:23,600
И им давали возможность обращения к младшим восьмидетикам.

588
00:39:25,360 --> 00:39:32,420
То есть у этих регистров у них была вот такая форма,

589
00:39:33,420 --> 00:39:36,900
которая означает младшие восьмидетики.

590
00:39:36,900 --> 00:39:38,280
Вот аналога H нет.

591
00:39:38,980 --> 00:39:39,860
Почему?

592
00:39:40,740 --> 00:39:41,800
Ну, потому что не нужно.

593
00:39:44,660 --> 00:39:47,080
На самом деле для SP это нафиг не нужно,

594
00:39:47,700 --> 00:39:52,640
но ввиду симметрии кодирования оно там тоже появилось.

595
00:39:55,000 --> 00:39:58,840
То есть у вас есть доступ теперь ко всем регистрам

596
00:39:58,840 --> 00:40:03,960
к младшим восьми, шестнадцати, тридцати двум и шестидесяти четырем.

597
00:40:08,980 --> 00:40:18,660
Потом, в одно из самых вкусных, добавили новых регистров общего назначения.

598
00:40:18,660 --> 00:40:30,660
Регистры эти называются R8 по R15.

599
00:40:30,660 --> 00:40:34,660
Вот какие названия сцеплены.

600
00:40:34,660 --> 00:40:38,600
Это шестидесяти четырехбитные формы.

601
00:40:38,600 --> 00:40:38,820
Это шестидесяти четырехбитные формы.

602
00:40:38,820 --> 00:40:38,900
Это шестидесяти четырехбитные формы.

603
00:40:38,900 --> 00:40:42,900
У них также есть тридцать два, шестнадцать и восемь,

604
00:40:42,900 --> 00:40:54,340
которые называются R8D, R8V, R8B.

605
00:40:54,340 --> 00:40:55,780
Но опять, регистры не важны.

606
00:41:03,780 --> 00:41:07,440
Это восемь регистров общего назначения.

607
00:41:07,440 --> 00:41:08,740
Такие как...

608
00:41:08,740 --> 00:41:11,240
ЕАХ, ЕЦХ и так далее.

609
00:41:13,020 --> 00:41:13,600
Вот-вот.

610
00:41:14,240 --> 00:41:15,200
Точно так же.

611
00:41:17,240 --> 00:41:23,740
Но у них коротенькие формы образуются по другой системе.

612
00:41:25,020 --> 00:41:26,040
По более выгодной.

613
00:41:30,740 --> 00:41:34,740
Как поделаться инструкцией с ЕЦХ?

614
00:41:36,740 --> 00:41:38,660
Ну, на самом деле,

615
00:41:38,740 --> 00:41:44,740
кодирование там, по большей части, тридцать двухбитное.

616
00:41:44,740 --> 00:41:49,740
То есть большинство команд в шестидесяти четырехбитном режиме

617
00:41:49,740 --> 00:41:52,740
в дефолте тридцать двухбитное.

618
00:41:52,740 --> 00:41:58,740
Для того, чтобы закодировать что-то новенькое,

619
00:41:58,740 --> 00:42:02,740
то есть вот R-регистр шириной,

620
00:42:02,740 --> 00:42:04,740
или вот эти новые регистры,

621
00:42:04,740 --> 00:42:07,740
там нужно добавить специальный префикс.

622
00:42:07,740 --> 00:42:08,580
Там нужно добавить специальный префикс.

623
00:42:08,580 --> 00:42:11,580
Префикс называется REX.

624
00:42:16,580 --> 00:42:24,580
И имеет коды от 0x40 до 0x41.

625
00:42:27,580 --> 00:42:30,580
Если только курсы кодирования,

626
00:42:30,580 --> 00:42:34,580
то это были такие специальные короткие формы

627
00:42:34,580 --> 00:42:37,580
для команд INC, DEC и DIST.

628
00:42:38,580 --> 00:42:41,580
Сейчас эти короткие формы забрали,

629
00:42:41,580 --> 00:42:43,580
то есть команды INC, DEC остались,

630
00:42:43,580 --> 00:42:46,580
но у них остались только полные формы.

631
00:42:46,580 --> 00:42:49,580
А короткие формы забрали под префикс,

632
00:42:49,580 --> 00:42:55,580
который позволяет вам закодировать вот эти новые регистры.

633
00:42:55,580 --> 00:42:59,580
Вообще система кодирования, она минимально изменилась.

634
00:42:59,580 --> 00:43:03,580
Но для того, чтобы обращаться к новым регистрам,

635
00:43:03,580 --> 00:43:07,580
поле, которое кодировало индексы регистра,

636
00:43:07,580 --> 00:43:10,580
оно уже было трехбитовое.

637
00:43:10,580 --> 00:43:12,580
Регистра стало 16,

638
00:43:12,580 --> 00:43:17,580
и вам нужно теперь использовать 4 бита для индекса регистра.

639
00:43:17,580 --> 00:43:20,580
Вот этот дополнительный бит,

640
00:43:20,580 --> 00:43:23,580
он и берется из префикса REX.

641
00:43:23,580 --> 00:43:26,580
То есть вот эти вот единички,

642
00:43:26,580 --> 00:43:32,580
это битовые расширения полей,

643
00:43:32,580 --> 00:43:35,580
которые используются в обычном коде команды,

644
00:43:35,580 --> 00:43:36,580
позволяющие вам закодировать.

645
00:43:36,580 --> 00:43:39,580
Эти расширенные регистры.

646
00:43:39,580 --> 00:43:44,580
И в связи с этим есть еще одна особенность,

647
00:43:44,580 --> 00:43:52,580
а именно одной команде нельзя мешать аж регистры

648
00:43:52,580 --> 00:44:00,580
и что угодно новое.

649
00:44:00,580 --> 00:44:03,580
Почему?

650
00:44:03,580 --> 00:44:04,580
Потому что вот эти вот,

651
00:44:04,580 --> 00:44:12,580
формы, которые SPL, WPL, откуда они взялись?

652
00:44:12,580 --> 00:44:17,580
Это те коды, которые раньше кодировали аж регистры.

653
00:44:17,580 --> 00:44:23,580
А в новой системе кодирования,

654
00:44:23,580 --> 00:44:26,580
они кодируют теперь не аж регистры,

655
00:44:26,580 --> 00:44:29,580
а младшие 8 бит других регистров.

656
00:44:29,580 --> 00:44:32,580
Из этого следует, что просто технически,

657
00:44:32,580 --> 00:44:40,580
если вы используете новую индексацию регистров,

658
00:44:40,580 --> 00:44:42,580
то есть у вас есть префикс,

659
00:44:42,580 --> 00:44:47,580
то аж регистры вы не способны теперь закодировать.

660
00:44:47,580 --> 00:44:51,580
То есть аж регистры, они не были убраны,

661
00:44:51,580 --> 00:44:55,580
но вы не всегда можете на них достучаться

662
00:44:55,580 --> 00:44:58,580
в зависимости от того, что вы используете.

663
00:44:58,580 --> 00:45:00,580
То есть какая-нибудь команда

664
00:45:00,580 --> 00:45:04,580
может сказать, что мов а аж запятая ц л осталась.

665
00:45:04,580 --> 00:45:06,580
Нет проблем.

666
00:45:06,580 --> 00:45:08,580
Но сказать, например,

667
00:45:08,580 --> 00:45:13,580
мов а аж запятая р 8 б невозможно.

668
00:45:13,580 --> 00:45:17,580
Потому что, если вы используете обширное кодирование

669
00:45:17,580 --> 00:45:20,580
для того, чтобы обратиться к р 8 б,

670
00:45:20,580 --> 00:45:23,580
то кода для а аж просто нет.

671
00:45:23,580 --> 00:45:27,580
А аж, то что раньше кодировало а аж,

672
00:45:27,580 --> 00:45:29,580
теперь это будет WPL.

673
00:45:30,580 --> 00:45:35,580
Вот пометьте себе, что в одной команде

674
00:45:35,580 --> 00:45:39,580
нельзя использовать одновременно аж регистры

675
00:45:39,580 --> 00:45:42,580
и любой новый регистр.

676
00:45:42,580 --> 00:45:51,580
И R, потом SPL, WPL или там RAX.

677
00:45:51,580 --> 00:45:56,580
Любой регистр, которого не было в 3D-умережении,

678
00:45:56,580 --> 00:45:59,580
нельзя использовать вместе с аж регистрами,

679
00:45:59,580 --> 00:46:01,580
в одной команде.

680
00:46:01,580 --> 00:46:04,580
Потому что для обращения к этому новому регистру

681
00:46:04,580 --> 00:46:06,580
нужен префикс.

682
00:46:06,580 --> 00:46:11,580
А префикс переключает значение этих цифр.

683
00:46:11,580 --> 00:46:13,580
Нет, не его новый регистр,

684
00:46:13,580 --> 00:46:22,580
а в эти самые WPL, SPL, SIL, DIL.

685
00:46:22,580 --> 00:46:23,580
Вот.

686
00:46:23,580 --> 00:46:25,580
Оно сюда приходит.

687
00:46:29,580 --> 00:46:31,580
Ну, не сказать, что это нормально.

688
00:46:31,580 --> 00:46:33,580
Просто нет.

689
00:46:33,580 --> 00:46:34,580
Правильно.

690
00:46:34,580 --> 00:46:36,580
А что бы мы скодировали?

691
00:46:36,580 --> 00:46:39,580
Ну, хоть вот в моменте исполнения...

692
00:46:39,580 --> 00:46:41,580
Нет, ты не сумеешь выразить такую мысль,

693
00:46:41,580 --> 00:46:43,580
это низкий интервью.

694
00:46:45,580 --> 00:46:47,580
Причем можно спросить,

695
00:46:47,580 --> 00:46:50,580
а вот у нас мы можем условно считать 15 б,

696
00:46:50,580 --> 00:46:51,580
а записать только 8 б?

697
00:46:51,580 --> 00:46:52,580
Да, конечно.

698
00:46:52,580 --> 00:46:55,580
А у нас старшая часть будет аннулироваться?

699
00:46:55,580 --> 00:46:57,580
Вот, сейчас я про это скажу.

700
00:46:57,580 --> 00:46:58,580
Ну...

701
00:46:58,580 --> 00:47:00,580
Хорошо, сейчас скажу.

702
00:47:00,580 --> 00:47:02,580
Да, здесь есть особенность,

703
00:47:02,580 --> 00:47:04,580
она заключается в следующем,

704
00:47:04,580 --> 00:47:10,580
что когда вы пишете в 32 младших бита

705
00:47:10,580 --> 00:47:15,580
и ровно в 32 младших бита любого регистра,

706
00:47:15,580 --> 00:47:21,580
например, mov.eax, там, ecx,

707
00:47:21,580 --> 00:47:26,580
то в этом случае старшие 32 бита обнуляются.

708
00:47:28,580 --> 00:47:31,580
Вот, обязательно пометьте.

709
00:47:31,580 --> 00:47:32,580
Еще раз, правильно.

710
00:47:32,580 --> 00:47:38,580
Если команда пишет 32-битную часть регистра

711
00:47:38,580 --> 00:47:41,580
любого, старого, нового, неважно,

712
00:47:41,580 --> 00:47:46,580
то старшие 32 бита обнуляются.

713
00:47:46,580 --> 00:47:50,580
То есть на самом деле команда пишет 10 дисков,

714
00:47:50,580 --> 00:47:53,580
после пишет 0 в старшую часть.

715
00:47:53,580 --> 00:47:57,580
Если вы пишете не 32-битную часть,

716
00:47:57,580 --> 00:48:01,580
например, вот пишите 16 бит, 8, 8,

717
00:48:01,580 --> 00:48:04,580
то ничего подобного не происходит.

718
00:48:04,580 --> 00:48:07,580
То есть как раньше запись mov.eax

719
00:48:07,580 --> 00:48:11,580
не трогала старшие 16 бит,

720
00:48:11,580 --> 00:48:14,580
так и эти она тоже не трогает.

721
00:48:16,580 --> 00:48:19,580
Поэтому только запись 32-битной порции

722
00:48:19,580 --> 00:48:22,580
имеет вот такую особенность.

723
00:48:22,580 --> 00:48:25,580
Можно ли я считать, что

724
00:48:25,580 --> 00:48:29,580
когда мы пишем в 8 или в 16,

725
00:48:29,580 --> 00:48:34,580
и у нас, по сути, не трогается остальная часть,

726
00:48:34,580 --> 00:48:39,580
то это, по сути, мы читаем свой же регистр

727
00:48:39,580 --> 00:48:44,580
и просто маску накидываем и делаем или с этой частью.

728
00:48:44,580 --> 00:48:48,580
То есть на самом деле у нас происходит чтение,

729
00:48:48,580 --> 00:48:51,580
может, из этого регистра читали данные

730
00:48:51,580 --> 00:48:52,580
перед тем, как мы его пишем?

731
00:48:52,580 --> 00:48:54,580
Ну, скорее не столько чтение,

732
00:48:54,580 --> 00:48:56,580
а есть ли зависимость

733
00:48:56,580 --> 00:48:59,580
по исходному значению этого регистра.

734
00:48:59,580 --> 00:49:01,580
Вот так вот я рассказываю.

735
00:49:01,580 --> 00:49:02,580
Да, есть.

736
00:49:02,580 --> 00:49:05,580
Вернее, там есть разные режимы в разных процессорах,

737
00:49:05,580 --> 00:49:07,580
но, как правило,

738
00:49:07,580 --> 00:49:10,580
наверное, проще считать, что есть.

739
00:49:10,580 --> 00:49:12,580
Потому что в разных процессорах

740
00:49:12,580 --> 00:49:13,580
там были разные фичи

741
00:49:13,580 --> 00:49:16,580
про вот 8-битные части и так далее,

742
00:49:16,580 --> 00:49:18,580
но в современных эти фичи,

743
00:49:18,580 --> 00:49:19,580
я так понимаю,

744
00:49:19,580 --> 00:49:22,580
они все меньше актуальны.

745
00:49:22,580 --> 00:49:24,580
Есть специальные такие режимы,

746
00:49:24,580 --> 00:49:26,580
а есть маленькие кусочки.

747
00:49:26,580 --> 00:49:31,580
И оно будет зависимое.

748
00:49:31,580 --> 00:49:33,580
Но у нас, видите, там есть флаг,

749
00:49:33,580 --> 00:49:35,580
например, у Armani есть флаг из Merging,

750
00:49:35,580 --> 00:49:37,580
который динамический,

751
00:49:37,580 --> 00:49:38,580
и если он смерджется,

752
00:49:38,580 --> 00:49:41,580
то он не замерзает.

753
00:49:41,580 --> 00:49:43,580
А если не смерджется,

754
00:49:43,580 --> 00:49:45,580
то он замерзает, по-скольку.

755
00:49:45,580 --> 00:49:47,580
И этот флаг зависит.

756
00:49:47,580 --> 00:49:50,580
Нет, здесь никаких флагов по этому поводу нет,

757
00:49:50,580 --> 00:49:52,580
но вот это вот зависимость

758
00:49:52,580 --> 00:49:54,580
в плане того, чтобы,

759
00:49:54,580 --> 00:49:55,580
если вы делаете, например,

760
00:49:55,580 --> 00:49:58,580
скажите,

761
00:49:58,580 --> 00:50:05,580
mov ax constant,

762
00:50:05,580 --> 00:50:07,580
то вот эта команда

763
00:50:07,580 --> 00:50:09,580
означает, что ее результат

764
00:50:09,580 --> 00:50:13,580
зависит от предыдущего значения rax.

765
00:50:13,580 --> 00:50:14,580
Ну да, да, да.

766
00:50:14,580 --> 00:50:15,580
Я вот про что.

767
00:50:15,580 --> 00:50:19,580
А если вы делаете mov eax constant,

768
00:50:19,580 --> 00:50:22,580
то эта команда пишет весь регистр,

769
00:50:22,580 --> 00:50:25,580
и поэтому зависимости от того,

770
00:50:25,580 --> 00:50:28,580
что с этим регистром делали раньше, нет.

771
00:50:28,580 --> 00:50:31,580
На правильность это не влияет,

772
00:50:31,580 --> 00:50:35,580
но это влияет на эффективность работы,

773
00:50:35,580 --> 00:50:38,580
когда вы смотрите, какая команда какой зависит,

774
00:50:38,580 --> 00:50:41,580
что там суперскаляра может одновременно исполнить.

775
00:50:41,580 --> 00:50:43,580
В этом плане, конечно, рекомендуется

776
00:50:43,580 --> 00:50:45,580
писать весь регистр.

777
00:50:45,580 --> 00:50:47,580
Это означает, что рекомендуется

778
00:50:47,580 --> 00:50:50,580
писать хотя бы 32 бита.

779
00:50:50,580 --> 00:50:52,580
И еще последствия.

780
00:50:52,580 --> 00:50:54,580
Тоже важное.

781
00:50:54,580 --> 00:50:57,580
Я вам сказал, что такая дефолтная битность

782
00:50:57,580 --> 00:50:59,580
в 64-битном режиме

783
00:50:59,580 --> 00:51:01,580
все равно 32 бита.

784
00:51:01,580 --> 00:51:05,580
Поэтому выгоднее использовать команду

785
00:51:09,580 --> 00:51:11,580
а не команду

786
00:51:15,580 --> 00:51:16,580
Почему?

787
00:51:16,580 --> 00:51:18,580
Потому что результат одинаковый,

788
00:51:18,580 --> 00:51:21,580
а эта команда на 1 байт короче.

789
00:51:21,580 --> 00:51:24,580
Там нет реакс-префикса.

790
00:51:24,580 --> 00:51:26,580
С другой стороны,

791
00:51:26,580 --> 00:51:29,580
если вы ксорите, например, R8,

792
00:51:29,580 --> 00:51:33,580
то вот ксорите вы R8 или R8D,

793
00:51:33,580 --> 00:51:35,580
никакой разницы.

794
00:51:35,580 --> 00:51:38,580
Эти команды занимают одинаковый размер,

795
00:51:38,580 --> 00:51:41,580
работают с одинаковой скоростью,

796
00:51:41,580 --> 00:51:43,580
вообще-то разница.

797
00:51:43,580 --> 00:51:45,580
Потому что для кодирования R8

798
00:51:45,580 --> 00:51:47,580
вам реакс все равно нужен.

799
00:51:47,580 --> 00:51:50,580
А вот для таких старых регистров,

800
00:51:50,580 --> 00:51:53,580
выгоднее использовать Е-формы,

801
00:51:53,580 --> 00:51:57,580
потому что оно тогда будет кодироваться на 1 байт короче,

802
00:51:57,580 --> 00:52:00,580
если вам нужно занурение старшей части.

803
00:52:00,580 --> 00:52:01,580
Да.

804
00:52:06,580 --> 00:52:07,580
Да.

805
00:52:07,580 --> 00:52:09,580
Потому что просто загрузка 32 бита

806
00:52:09,580 --> 00:52:12,580
уже обнуряет старшую часть.

807
00:52:16,580 --> 00:52:17,580
Да.

808
00:52:17,580 --> 00:52:18,580
Тоже самое.

809
00:52:18,580 --> 00:52:21,580
Но я ихс на 1 байт короче кодирую,

810
00:52:21,580 --> 00:52:24,580
потому что оно не требует реакс-префикса.

811
00:52:24,580 --> 00:52:27,580
Так что если вы смотрите на код компилятора,

812
00:52:27,580 --> 00:52:29,580
вот ответ на вопрос,

813
00:52:29,580 --> 00:52:32,580
почему компиляторы выглядят такими

814
00:52:32,580 --> 00:52:34,580
тридцатиноубитными командочки,

815
00:52:34,580 --> 00:52:36,580
даже если у вас в этом регистре

816
00:52:36,580 --> 00:52:38,580
лежит шестнечетыреубитное число.

817
00:52:38,580 --> 00:52:41,580
Потому что действия эквивалентные,

818
00:52:41,580 --> 00:52:45,580
а кодируются короче.

819
00:52:45,580 --> 00:52:47,580
И в этом месте даже есть

820
00:52:47,580 --> 00:52:50,580
такой один забавный хак.

821
00:52:50,580 --> 00:52:52,580
Я бы даже так сказал.

822
00:52:53,580 --> 00:52:58,580
Кто знает про код 0x90?

823
00:53:00,580 --> 00:53:02,580
Что это за код такой?

824
00:53:02,580 --> 00:53:04,580
Это ноб.

825
00:53:05,580 --> 00:53:06,580
Ну это ноб,

826
00:53:06,580 --> 00:53:09,580
это как бы официальный ноб.

827
00:53:09,580 --> 00:53:11,580
А если технически,

828
00:53:11,580 --> 00:53:15,580
то какому действию это соответствует?

829
00:53:17,580 --> 00:53:19,580
Нет.

830
00:53:19,580 --> 00:53:21,580
Нет.

831
00:53:30,580 --> 00:53:33,580
И это действительно был ноб

832
00:53:33,580 --> 00:53:36,580
в шестнадцати и тридцатиноубитном режиме.

833
00:53:36,580 --> 00:53:39,580
Но теперь обратите внимание.

834
00:53:39,580 --> 00:53:41,580
Вот это новое правило

835
00:53:41,580 --> 00:53:43,580
зануления старшей части

836
00:53:43,580 --> 00:53:46,580
означает, что эта команда не ноб.

837
00:53:46,580 --> 00:53:48,580
Потому что она должна

838
00:53:48,580 --> 00:53:51,580
занулять старшую половину Rx.

839
00:53:51,580 --> 00:53:55,580
Но, так как официально в документации

840
00:53:55,580 --> 00:53:57,580
сказано, что это ноб,

841
00:53:57,580 --> 00:54:01,580
то оно не зануляет ничего.

842
00:54:01,580 --> 00:54:03,580
Это действительно ноб.

843
00:54:03,580 --> 00:54:05,580
То есть в программе об код

844
00:54:05,580 --> 00:54:07,580
поставили там официальный if.

845
00:54:07,580 --> 00:54:10,580
Несмотря на то, что вот оно как бы

846
00:54:10,580 --> 00:54:12,580
соответствует коду этой команды,

847
00:54:12,580 --> 00:54:15,580
но на самом деле это честный ноб.

848
00:54:15,580 --> 00:54:17,580
То есть если мы сами эту команду напишем,

849
00:54:17,580 --> 00:54:19,580
то тоже ничего не произойдет?

850
00:54:19,580 --> 00:54:21,580
Это уже зависит от.

851
00:54:21,580 --> 00:54:24,580
Потому что у команды XTHG

852
00:54:24,580 --> 00:54:27,580
есть несколько вариантов кода.

853
00:54:27,580 --> 00:54:30,580
И если оно сконфилируется

854
00:54:30,580 --> 00:54:33,580
в код 0x90,

855
00:54:33,580 --> 00:54:35,580
то это будет ноб.

856
00:54:35,580 --> 00:54:37,580
А если оно сконфилирует себя

857
00:54:37,580 --> 00:54:40,580
в полную форму XTHG,

858
00:54:40,580 --> 00:54:42,580
то оно будет обнулять.

859
00:54:42,580 --> 00:54:44,580
И я так понимаю,

860
00:54:44,580 --> 00:54:46,580
что современные компиляторы,

861
00:54:46,580 --> 00:54:49,580
если вы их просите вот так вот сконфилировать,

862
00:54:49,580 --> 00:54:51,580
они вам будут сконфилировать в полную форму,

863
00:54:51,580 --> 00:54:53,580
как раз специально,

864
00:54:53,580 --> 00:54:55,580
чтобы вы получили вот тот эффект,

865
00:54:55,580 --> 00:54:57,580
который просили.

866
00:54:57,580 --> 00:54:59,580
Потому что, наверное, вы просили обнулить

867
00:54:59,580 --> 00:55:02,580
старшую часть реки.

868
00:55:02,580 --> 00:55:04,580
То есть вот этот вот код,

869
00:55:04,580 --> 00:55:08,580
он имеет специальную обработку.

870
00:55:08,580 --> 00:55:10,580
Несмотря на то, что он как будто

871
00:55:10,580 --> 00:55:12,580
соответствует команде XTHG,

872
00:55:12,580 --> 00:55:15,580
в фактически любительном мире

873
00:55:15,580 --> 00:55:17,580
это уже не так.

874
00:55:17,580 --> 00:55:22,580
Это такой честный специальный случай.

875
00:55:22,580 --> 00:55:25,580
А ноб?

876
00:55:25,580 --> 00:55:29,580
Нет операции и ничего не делает.

877
00:55:29,580 --> 00:55:31,580
Обращаю ваше внимание,

878
00:55:31,580 --> 00:55:36,580
что на x86 ноб имеют код не 0.

879
00:55:36,580 --> 00:55:39,580
Довольно популярно в разных архитектурах

880
00:55:39,580 --> 00:55:42,580
для ноба выбирать код 0.

881
00:55:42,580 --> 00:55:45,580
Так вот, 0 на x86

882
00:55:45,580 --> 00:55:47,580
это не только ноб,

883
00:55:47,580 --> 00:55:49,580
это двухбайтовая команда,

884
00:55:49,580 --> 00:55:52,580
которая обращается в память.

885
00:55:52,580 --> 00:55:55,580
Поэтому, если вы наткнетесь на исполнение

886
00:55:55,580 --> 00:55:57,580
кучи нулей как кода,

887
00:55:57,580 --> 00:55:59,580
вы с высокой вероятностью

888
00:55:59,580 --> 00:56:01,580
очень быстро покрашитесь.

889
00:56:01,580 --> 00:56:03,580
Потому что будете обращаться

890
00:56:03,580 --> 00:56:06,580
в чёрт его знает куда в память.

891
00:56:08,580 --> 00:56:10,580
Поэтому переход на генерацию

892
00:56:10,580 --> 00:56:13,580
вставляете юдэдвэр.

893
00:56:13,580 --> 00:56:15,580
Ну дэдвэр бывает, что кобелятор вставляют.

894
00:56:15,580 --> 00:56:18,580
Но на самом деле, качтые заполнения

895
00:56:18,580 --> 00:56:21,580
гораздо чаще используются

896
00:56:21,580 --> 00:56:23,580
вот этот код.

897
00:56:24,580 --> 00:56:27,580
Этот код соответствует команде

898
00:56:27,580 --> 00:56:29,580
int3.

899
00:56:29,580 --> 00:56:31,580
Вы вылезете в апперчик.

900
00:56:31,580 --> 00:56:34,580
Но после у меня int3 под другое используется

901
00:56:34,580 --> 00:56:37,580
а юдэдвэр именно под некорректную позицию.

902
00:56:37,580 --> 00:56:39,580
Нет, мы тут тратим места.

903
00:56:40,580 --> 00:56:45,540
Посреди кода, когда у вас там функции выравниваются на что-то,

904
00:56:45,960 --> 00:56:47,980
вот они обычно заполняются вот так.

905
00:56:50,300 --> 00:56:54,340
У D2, я знаю, компиляторы в духе сланга и ПЦЦ

906
00:56:54,340 --> 00:56:58,260
любят ставить, если ваша функция описана как no return,

907
00:56:59,040 --> 00:57:01,840
то вместо команды read ставится UD2.

908
00:57:02,620 --> 00:57:03,500
Вот так они любят ставить.

909
00:57:03,500 --> 00:57:08,540
А всякие заполнения обычно происходят вот через UD3.

910
00:57:10,580 --> 00:57:12,440
Почему не нопами?

911
00:57:14,100 --> 00:57:19,220
Потому что если D2 здесь оказался, то что-то незапланированное произошло.

912
00:57:19,240 --> 00:57:20,580
Нет, я видел, как заполняют нопами.

913
00:57:20,880 --> 00:57:22,740
Я видел и N3, и видел нопы.

914
00:57:23,320 --> 00:57:26,840
Ну, когда я встал, это заполнение в том месте,

915
00:57:27,100 --> 00:57:30,460
которое рассчитано на то, что его будут исполнять.

916
00:57:30,820 --> 00:57:35,960
А N3 это заполнение, которое рассчитано, что его не будут исполнять.

917
00:57:36,520 --> 00:57:39,460
Например, вот эти дырки между функциями.

918
00:57:40,580 --> 00:57:45,620
Вот там рассчитано на то, что туда при нормальном исполнении ты не попадешь.

919
00:57:46,520 --> 00:57:49,440
Если говорить про выравнивание внутри функции,

920
00:57:49,800 --> 00:57:50,940
то, конечно, это нопа.

921
00:57:53,400 --> 00:57:56,240
Ну, кстати говоря, это не единственная форма нопа.

922
00:57:57,020 --> 00:58:01,960
Нопа есть, ну, как уже некоторое время назад добавили,

923
00:58:02,400 --> 00:58:06,520
еще всякие такие многобайтовые формы.

924
00:58:08,140 --> 00:58:10,340
Вы можете считать мультибайт.

925
00:58:10,580 --> 00:58:15,940
Ну, командочки, которые делают ноп, ну, кодируются большим числом байтиков

926
00:58:16,340 --> 00:58:22,380
для того, чтобы не спамить много команд, а использовать более жирные команды.

927
00:58:22,740 --> 00:58:23,940
Ну, такое тоже встречается.

928
00:58:26,760 --> 00:58:31,100
Почему именно N3, а не запланированная команда невалидная,

929
00:58:31,240 --> 00:58:34,900
которая делает действия, которые приводят к крашу?

930
00:58:35,380 --> 00:58:38,620
Ну, N3 тоже приводит к крашу, если у тебя отрядчик не подключен.

931
00:58:40,580 --> 00:58:46,080
То есть, если отрядчик подключен, оно цивилизованно вываливается в отрядчик.

932
00:58:46,580 --> 00:58:51,580
Так что, с точки зрения того, чтобы покрашиться, N3 без отрядчика себя также крашит.

933
00:58:52,580 --> 00:58:57,580
Поэтому не забывайте убирать N3 из кода, если вы его используете.

934
00:58:59,580 --> 00:59:01,580
Без отрядчика N3 крашит.

935
00:59:03,580 --> 00:59:06,580
Ну, можно еще и сектор ханда поставить.

936
00:59:07,580 --> 00:59:08,580
Система зависит.

937
00:59:10,580 --> 00:59:16,580
Так, это были регистры.

938
00:59:18,580 --> 00:59:23,580
Следующий важный вопрос, который нужно посмотреть, это адресация.

939
00:59:40,580 --> 00:59:49,580
Сейчас я вам нарисую третью великую табличку.

940
00:59:50,580 --> 00:59:55,580
Про то, как можно адресоваться через различные видные регистры.

941
00:59:56,580 --> 00:59:57,580
Она выглядит так.

942
01:00:03,580 --> 01:00:07,580
На первой позиции может быть любой регистр общего назначения.

943
01:00:07,580 --> 01:00:30,580
Например, плюс на втором что угодно, кроме РСП, умножить на, как и раньше, плюс...

944
01:00:31,580 --> 01:00:33,580
Давайте набор всех.

945
01:00:37,580 --> 01:00:38,580
Вот так.

946
01:00:57,580 --> 01:01:01,580
Да, construction pointer теперь называется A.

947
01:01:03,580 --> 01:01:06,580
И даже можно участвовать в адресации.

948
01:01:07,580 --> 01:01:09,580
Это касается и относительной адресации.

949
01:01:12,580 --> 01:01:14,580
Ну вот, давайте посмотрим на эту картинку.

950
01:01:15,580 --> 01:01:22,580
У нее есть исключения, но вот это вот то, что случается почти всегда.

951
01:01:26,580 --> 01:01:31,580
Во-первых, то, что было в 32 битах, оно практически остается.

952
01:01:33,580 --> 01:01:36,580
Вы можете использовать новый регистр общего назначения

953
01:01:36,580 --> 01:01:38,580
без всяких уменьшений.

954
01:01:38,580 --> 01:01:40,580
Так же, как и раньше.

955
01:01:40,580 --> 01:01:41,580
Все то же самое.

956
01:01:41,580 --> 01:01:45,580
Второй аргумент можно умножить на 2, 4, 8.

957
01:01:45,580 --> 01:01:47,580
Можно не умножать.

958
01:01:47,580 --> 01:01:49,580
Какие особенности?

959
01:01:49,580 --> 01:01:50,580
Особенность номер один.

960
01:01:50,580 --> 01:01:53,580
Обратите внимание на смещение.

961
01:01:55,580 --> 01:01:57,580
32 битное смещение.

962
01:01:58,580 --> 01:02:04,580
На самом деле, эта печальная история вообще справедлива для всех команд.

963
01:02:04,580 --> 01:02:05,580
За исключением двух.

964
01:02:05,580 --> 01:02:14,580
За исключением двух команд нигде абсолютно нет 64-битных константов.

965
01:02:15,580 --> 01:02:19,580
То есть все константы, которые вы можете указать в командах,

966
01:02:20,580 --> 01:02:25,580
за исключением двух команд, 32-битные максимум.

967
01:02:27,580 --> 01:02:34,580
То есть, например, сказать ADD регистр, запятая 64-битная константа невозможно.

968
01:02:36,580 --> 01:02:40,580
Константы не расширены до 64-битных.

969
01:02:43,580 --> 01:02:49,580
И в адресах также вот эта вот константа, она 32-битная максимум.

970
01:02:52,580 --> 01:02:54,580
При том, сознательно или беззнательно.

971
01:02:55,580 --> 01:02:57,580
Какой ответ был раньше?

972
01:02:57,580 --> 01:02:58,580
Неважный.

973
01:02:58,580 --> 01:02:59,580
Неважный.

974
01:02:59,580 --> 01:03:00,580
А теперь ответ?

975
01:03:00,580 --> 01:03:01,580
Важный.

976
01:03:01,580 --> 01:03:02,580
И сознательный.

977
01:03:02,580 --> 01:03:06,580
Потому что видимость константы меньше видимости адреса.

978
01:03:06,580 --> 01:03:09,580
Поэтому как константы расширяются, важно.

979
01:03:09,580 --> 01:03:12,580
И константы расширяются как число со знаками.

980
01:03:12,580 --> 01:03:21,580
Вы можете адресовываться на плюс-минус 2 гигабайта относительно адреса заданного регистром.

981
01:03:23,580 --> 01:03:31,580
Кроме того, вместо первой части, где у вас регистры, может выступать регистр RIP.

982
01:03:32,580 --> 01:03:35,580
RIP это ваше текущее положение.

983
01:03:35,580 --> 01:03:41,580
Даже более точно, это адрес начала следующей команды за вашей командой.

984
01:03:44,580 --> 01:03:54,580
И поэтому в 64-битном мире адресация, как всяким константам и подобным вещам, она обычно RIP-относительная.

985
01:03:54,580 --> 01:04:00,580
Потому что ваши константы, они скорее всего находятся недалеко от вас.

986
01:04:00,580 --> 01:04:01,580
Поэтому вы можете...

987
01:04:02,580 --> 01:04:10,580
Вы можете через небольшое смещение относительно вашей позиции до них добраться.

988
01:04:10,580 --> 01:04:16,580
Обращение по абсолютному адресу в 64-битном мире очень затруднено.

989
01:04:20,580 --> 01:04:22,580
Еще раз.

990
01:04:22,580 --> 01:04:26,580
64-битные команды почти нигде не используются.

991
01:04:26,580 --> 01:04:28,580
Есть только два исключения.

992
01:04:28,580 --> 01:04:30,580
Вот запишите себе эти исключения.

993
01:04:32,580 --> 01:04:56,580
Во-первых, 64-битные константы можно использовать в команде mov.

994
01:04:56,580 --> 01:05:00,580
reg64.const64.

995
01:05:00,580 --> 01:05:10,580
То есть, чтобы записать в 64-битный регистр 64-битную константу.

996
01:05:10,580 --> 01:05:18,580
И второе исключение это mov.

997
01:05:18,580 --> 01:05:24,580
...

998
01:05:24,580 --> 01:05:28,580
В обратную сторону тоже можно.

999
01:05:28,580 --> 01:05:32,580
Где аккумулятор это...

1000
01:05:42,580 --> 01:05:52,580
То есть, вы можете прочитать или записать аккумулятор по адресу 64-битной константы.

1001
01:05:52,580 --> 01:05:54,580
...

1002
01:05:54,580 --> 01:05:56,580
И это единственные команды,

1003
01:05:56,580 --> 01:06:00,580
которые оперируют 64-битными числами.

1004
01:06:00,580 --> 01:06:04,580
В смысле, значениями, заданными в коде команды.

1005
01:06:04,580 --> 01:06:08,580
Все остальные константы, которые вы используете,

1006
01:06:08,580 --> 01:06:12,580
они все максимум 32-битные.

1007
01:06:16,580 --> 01:06:18,580
Вот такая печальная история.

1008
01:06:20,580 --> 01:06:22,580
Почему это важно?

1009
01:06:22,580 --> 01:06:24,580
Потому что

1010
01:06:24,580 --> 01:06:26,580
нередко то, что вы использовали,

1011
01:06:26,580 --> 01:06:28,580
было константами.

1012
01:06:28,580 --> 01:06:30,580
Например,

1013
01:06:30,580 --> 01:06:32,580
когда вы писали

1014
01:06:32,580 --> 01:06:34,580
push

1015
01:06:34,580 --> 01:06:36,580
push

1016
01:06:36,580 --> 01:06:38,580
push

1017
01:06:38,580 --> 01:06:40,580
метка.

1018
01:06:40,580 --> 01:06:42,580
Что такое метка?

1019
01:06:42,580 --> 01:06:44,580
Это константа.

1020
01:06:44,580 --> 01:06:46,580
Это константа.

1021
01:06:46,580 --> 01:06:48,580
Просто эту константу

1022
01:06:48,580 --> 01:06:50,580
вычисляет компилятор

1023
01:06:50,580 --> 01:06:52,580
во время компиляции,

1024
01:06:52,580 --> 01:06:54,580
где эта метка

1025
01:06:54,580 --> 01:06:56,580
расположится в памяти.

1026
01:06:56,580 --> 01:06:58,580
Соответственно, теперь

1027
01:06:58,580 --> 01:07:00,580
такая команда невозможна.

1028
01:07:00,580 --> 01:07:02,580
Потому что

1029
01:07:02,580 --> 01:07:04,580
ваша метка расположится в памяти

1030
01:07:04,580 --> 01:07:06,580
где-то по 64-битному адресу.

1031
01:07:08,580 --> 01:07:10,580
А запушить

1032
01:07:10,580 --> 01:07:12,580
вот здесь

1033
01:07:12,580 --> 01:07:14,580
вы можете указать только

1034
01:07:14,580 --> 01:07:16,580
32-битное значение.

1035
01:07:18,580 --> 01:07:20,580
Понятно?

1036
01:07:20,580 --> 01:07:22,580
Поэтому вот так вот запушить

1037
01:07:22,580 --> 01:07:24,580
адрес метки

1038
01:07:24,580 --> 01:07:26,580
невозможно.

1039
01:07:28,580 --> 01:07:30,580
Все, что вы можете сделать,

1040
01:07:30,580 --> 01:07:32,580
это movregister, запятая метка,

1041
01:07:32,580 --> 01:07:34,580
потом pushregister,

1042
01:07:34,580 --> 01:07:36,580
и то там есть особенности.

1043
01:07:40,580 --> 01:07:42,580
Как правило,

1044
01:07:42,580 --> 01:07:44,580
movregister

1045
01:07:44,580 --> 01:07:48,160
таб.

1046
01:07:51,160 --> 01:07:53,380
Атак, London?

1047
01:07:53,380 --> 01:07:54,180
Да.

1048
01:07:54,180 --> 01:07:54,800
Так!

1049
01:07:54,900 --> 01:07:55,640
Пин MTG резка!

1050
01:07:55,640 --> 01:07:57,380
Потом кичу!

1051
01:07:57,380 --> 01:07:59,420
Так потенциально можно!

1052
01:07:59,420 --> 01:08:00,420
Но так, честно говоря,

1053
01:08:00,420 --> 01:08:02,580
не очень хорошо

1054
01:08:02,580 --> 01:08:04,340
в связи

1055
01:08:04,340 --> 01:08:06,460
с некоторыми доступными

1056
01:08:06,460 --> 01:08:06,980
как оно компилируется

1057
01:08:06,980 --> 01:08:08,260
или линкуется

1058
01:08:09,100 --> 01:08:10,580
ize the location.

1059
01:08:10,580 --> 01:08:12,580
Вы хотите писать

1060
01:08:12,580 --> 01:08:13,160
вот так.

1061
01:08:14,580 --> 01:08:34,100
И, да, я не помню, какой дефолт у нас, ясно, у нас не совсем правильный дефолт.

1062
01:08:34,100 --> 01:08:37,360
Вначале нужно сказать еще где.

1063
01:08:41,200 --> 01:08:43,820
Нужно ли это говорить на основе, не помню.

1064
01:08:44,580 --> 01:08:47,120
Надо посмотреть, про что это.

1065
01:08:47,620 --> 01:08:53,000
Про то, что когда вы в дефолтере в режиме указываете метку,

1066
01:08:53,420 --> 01:08:57,560
то метка компилируется не как адрес этой метки,

1067
01:08:57,560 --> 01:09:11,800
а как rip плюс смещение относительно адреса следующей команды.

1068
01:09:12,100 --> 01:09:13,840
И вот это то, что вы хотите.

1069
01:09:14,580 --> 01:09:17,200
Вы хотите вот такую форму вот здесь.

1070
01:09:23,680 --> 01:09:26,680
То есть, ясно, нужно было точно говорить дефолт, реал.

1071
01:09:27,220 --> 01:09:30,280
А вот у нас, ну, какой дефолт, реал, не реал, я не помню.

1072
01:09:30,280 --> 01:09:34,620
И вот это, чтобы пихать на 64-х метрах.

1073
01:09:35,420 --> 01:09:37,160
Чтобы ее как-то использовать, да.

1074
01:09:37,860 --> 01:09:40,780
Вернее, это вот, смотри, вот это ваша метка,

1075
01:09:41,580 --> 01:09:44,560
которая располагается где-то недалеко от вас.

1076
01:09:44,580 --> 01:09:55,940
Да, конечно.

1077
01:09:56,660 --> 01:09:58,040
Вот, справа табличка.

1078
01:09:59,980 --> 01:10:03,780
Но это предсказуемое смещение относительно rip

1079
01:10:03,780 --> 01:10:06,060
обычно то, что вы хотите.

1080
01:10:06,980 --> 01:10:09,660
Потому что эта метка располагается, скорее всего,

1081
01:10:09,760 --> 01:10:12,260
ну, не дальше, чем 2 гигабайта от вашего кода.

1082
01:10:13,260 --> 01:10:14,560
Если вы пишете данную метку.

1083
01:10:14,580 --> 01:10:17,840
Что исполняемую, конечно, библиотеку.

1084
01:10:18,540 --> 01:10:21,600
Он явно имеет размеры меньше, чем 2 гигабайта.

1085
01:10:22,120 --> 01:10:24,260
Поэтому относительно кода, если вы шагнете,

1086
01:10:24,420 --> 01:10:27,520
пусть будет 2 гигабайта, будет 0.

1087
01:10:28,120 --> 01:10:29,240
Какой вопрос?

1088
01:10:29,600 --> 01:10:32,740
Можно ли просто обстоять размеры, если это 4 гигабайта?

1089
01:10:33,860 --> 01:10:34,540
Нет.

1090
01:10:35,080 --> 01:10:36,260
Там присутствует некая форма.

1091
01:10:40,820 --> 01:10:44,060
В некоторых командах есть возможность

1092
01:10:44,580 --> 01:10:47,340
использования более коротких констант.

1093
01:10:47,340 --> 01:10:49,140
Например, адресат.

1094
01:10:49,140 --> 01:10:53,340
Там есть форма с 8-битыми константами.

1095
01:10:53,340 --> 01:10:56,080
Если ваша константа умещается в 8 бит,

1096
01:10:56,080 --> 01:10:59,580
будет использована короткая форма, константа.

1097
01:10:59,580 --> 01:11:04,340
Но, например, там какой-нибудь mov, константа,

1098
01:11:04,340 --> 01:11:07,340
там будет полная форма без сокращения.

1099
01:11:09,340 --> 01:11:12,340
Ну и на самом деле это не так уж критично.

1100
01:11:14,580 --> 01:11:20,340
Конечно, имеет смысл экономить размер кода,

1101
01:11:20,340 --> 01:11:23,340
но там, где оно бесплатно остается.

1102
01:11:23,340 --> 01:11:30,340
Но если бы каждая вторая команда мог по автосету относительно RDI

1103
01:11:30,340 --> 01:11:32,340
на число меньше, чем 1 байт?

1104
01:11:32,340 --> 01:11:33,340
Нет.

1105
01:11:33,340 --> 01:11:37,340
Но у меня пример буквально такой есть.

1106
01:11:37,340 --> 01:11:39,340
Какой-то странный пример.

1107
01:11:39,340 --> 01:11:41,340
Почему вы хотели транспайлер?

1108
01:11:41,340 --> 01:11:43,340
Не знаю.

1109
01:11:43,340 --> 01:11:46,340
Внутренности должны как-то активизироваться.

1110
01:11:46,340 --> 01:11:48,340
А нужно ли?

1111
01:11:48,340 --> 01:11:52,340
Ну, вообще, если так массово, то да, может.

1112
01:11:53,340 --> 01:11:56,340
Ускорить-то, конечно, но только нужно ли ускорять?

1113
01:11:56,340 --> 01:12:00,340
Ну, это уже не взрослый вопрос.

1114
01:12:02,340 --> 01:12:04,340
Итак, понятно?

1115
01:12:06,340 --> 01:12:08,340
А, и еще такой вопрос.

1116
01:12:08,340 --> 01:12:12,340
Можно ли указать регистр не 64-битные, а 13-битные в адресе?

1117
01:12:13,340 --> 01:12:15,340
Еще раз.

1118
01:12:15,340 --> 01:12:22,340
У вас есть адресация 32-битная, 16-битная и 64-битная.

1119
01:12:22,340 --> 01:12:26,340
Вы можете использовать в 64-битном режиме

1120
01:12:26,340 --> 01:12:29,340
32-битную адресацию?

1121
01:12:29,340 --> 01:12:30,340
Зачем?

1122
01:12:30,340 --> 01:12:32,340
А мешать их внутренности?

1123
01:12:32,340 --> 01:12:33,340
Нет.

1124
01:12:33,340 --> 01:12:38,340
Ну, вот, смотри, здесь нет возможности указать регистры разной длительности.

1125
01:12:38,340 --> 01:12:41,340
Просто у меня, видимо, бета-ассемблер,

1126
01:12:41,340 --> 01:12:46,340
считающий, что uax, смешанный с rdi, это rax плюс rdi.

1127
01:12:46,340 --> 01:12:49,340
Ну, да, это он так проявил интеллект,

1128
01:12:49,340 --> 01:12:52,340
что, типа, видимо, хотел все равно,

1129
01:12:52,340 --> 01:12:55,340
а аккумулятор, то есть, назвал его неправильно,

1130
01:12:55,340 --> 01:13:00,340
поэтому мы его, как бы, автоматически проапгрейдим.

1131
01:13:01,340 --> 01:13:02,340
Сейчас.

1132
01:13:03,340 --> 01:13:05,340
Интересное замечание.

1133
01:13:07,340 --> 01:13:10,340
Что еще можно сказать?

1134
01:13:11,340 --> 01:13:20,340
Так.

1135
01:13:20,340 --> 01:13:22,340
Ну, теперь...

1136
01:13:22,340 --> 01:13:25,340
Да, есть еще интересные вещи.

1137
01:13:29,340 --> 01:13:34,340
А именно, вот переход в 64-бита,

1138
01:13:34,340 --> 01:13:37,340
также AMD-шники...

1139
01:13:39,340 --> 01:13:41,340
Поэтому можно...

1140
01:13:41,340 --> 01:13:46,340
Пусть чуть ли не слегка почистить обходы.

1141
01:13:46,340 --> 01:13:50,340
А именно все вот эти новые расширения команд,

1142
01:13:50,340 --> 01:13:52,340
они, конечно, очень страдают.

1143
01:13:52,340 --> 01:13:53,340
Почему?

1144
01:13:53,340 --> 01:13:55,340
Потому что их надо кодировать.

1145
01:13:56,340 --> 01:14:00,340
А коротких кодов давно уже не осталось.

1146
01:14:00,340 --> 01:14:03,340
Так мы же говорили про это, когда...

1147
01:14:03,340 --> 01:14:04,340
Сейчас скажу.

1148
01:14:04,340 --> 01:14:06,340
Когда добавляли prefix-refix, нет?

1149
01:14:06,340 --> 01:14:07,340
Нет.

1150
01:14:07,340 --> 01:14:14,340
Префикс — это про добавление вообще, как бы, поведения к обычным командам.

1151
01:14:14,340 --> 01:14:17,340
А я говорю про добавление команд.

1152
01:14:18,340 --> 01:14:21,340
То есть то, что вот мы дальше рассмотрим,

1153
01:14:21,340 --> 01:14:23,340
всякие там сиф-команды,

1154
01:14:23,340 --> 01:14:27,340
всякие AVX-512 и прочие,

1155
01:14:27,340 --> 01:14:29,340
вот эти все модные штучки,

1156
01:14:29,340 --> 01:14:31,340
они требуют новых кодов.

1157
01:14:31,340 --> 01:14:33,340
Для новых именно команд.

1158
01:14:33,340 --> 01:14:35,340
Не просто для новой формы старых команд,

1159
01:14:35,340 --> 01:14:36,340
а для новой команды.

1160
01:14:37,340 --> 01:14:40,340
И вот эти вот новые формы команд,

1161
01:14:40,340 --> 01:14:42,340
то есть новые команды,

1162
01:14:42,340 --> 01:14:44,340
откуда взять им новые коды?

1163
01:14:44,340 --> 01:14:48,340
Потому что коды давно кончились.

1164
01:14:48,340 --> 01:14:52,340
Поэтому приходится использовать кучу всяких префиксов.

1165
01:14:52,340 --> 01:14:55,340
Префикс такой, префикс такой,

1166
01:14:55,340 --> 01:14:59,340
и теперь у нас есть немножко кодового пространства,

1167
01:14:59,340 --> 01:15:01,340
которое еще не занято.

1168
01:15:01,340 --> 01:15:05,340
Поэтому новые команды, они нередко очень длинные

1169
01:15:05,340 --> 01:15:06,340
по своему тому.

1170
01:15:07,340 --> 01:15:09,340
Другой стороны,

1171
01:15:09,340 --> 01:15:12,340
в базовом наборе таких коротких команд

1172
01:15:12,340 --> 01:15:15,340
существует довольно немало команд,

1173
01:15:15,340 --> 01:15:18,340
которые никому нафиг давно не нужны.

1174
01:15:18,340 --> 01:15:21,340
И AVD-шники по поводу того,

1175
01:15:21,340 --> 01:15:23,340
что у нас новый режим работает,

1176
01:15:23,340 --> 01:15:27,340
соответственно, у нас нет совместимости ни с каким софтом,

1177
01:15:27,340 --> 01:15:30,340
решили, что это прекрасное время

1178
01:15:30,340 --> 01:15:34,340
почистить и некоторые команды выкинуть.

1179
01:15:34,340 --> 01:15:36,340
То есть эти команды,

1180
01:15:36,340 --> 01:15:39,340
они по-прежнему существуют и работают,

1181
01:15:39,340 --> 01:15:43,340
как и раньше работали в текстовом битовом режиме,

1182
01:15:43,340 --> 01:15:46,340
но из шифинического битового режима их выкинули,

1183
01:15:46,340 --> 01:15:48,340
их коды почистили.

1184
01:15:48,340 --> 01:15:52,340
Теперь эти коды этим командам не соответствуют.

1185
01:15:52,340 --> 01:15:56,340
И эти коды можно использовать под что-нибудь,

1186
01:15:56,340 --> 01:15:58,340
ну, такой резерв на будущее.

1187
01:15:58,340 --> 01:16:00,340
Что это за команды?

1188
01:16:00,340 --> 01:16:03,340
Во-первых, это группа команд,

1189
01:16:03,340 --> 01:16:05,340
так называемые двоичные команды,

1190
01:16:05,340 --> 01:16:08,340
двоично-десятичные реплики.

1191
01:16:23,340 --> 01:16:27,340
Это такие команды, как

1192
01:16:27,340 --> 01:16:30,340
va-a-a,

1193
01:16:30,340 --> 01:16:32,340
есть такая команда,

1194
01:16:35,340 --> 01:16:36,340
да.

1195
01:16:36,340 --> 01:16:38,340
Раньше, когда открывались документации,

1196
01:16:38,340 --> 01:16:40,340
это была первая команда,

1197
01:16:40,340 --> 01:16:42,340
которую вы видите.

1198
01:16:42,340 --> 01:16:44,340
a-a-m,

1199
01:16:44,340 --> 01:16:46,340
das

1200
01:16:46,340 --> 01:16:48,340
и подобные.

1201
01:16:48,340 --> 01:16:51,340
Там их, по-моему, было.

1202
01:16:51,340 --> 01:16:53,340
Про что это?

1203
01:16:53,340 --> 01:16:54,340
Как я вам сказал,

1204
01:16:54,340 --> 01:16:57,340
про так называемую двоично-десятичную ритмичку.

1205
01:16:57,340 --> 01:16:59,340
Кто-нибудь в курсе чего-нибудь?

1206
01:16:59,340 --> 01:17:01,340
Ну, для часов.

1207
01:17:01,340 --> 01:17:03,340
Что?

1208
01:17:03,340 --> 01:17:07,340
Для часов, там уже, типа, 10 цифр используются.

1209
01:17:07,340 --> 01:17:11,340
При этом хочется быстро поучаствовать.

1210
01:17:11,340 --> 01:17:13,340
Ну, смотрите.

1211
01:17:13,340 --> 01:17:18,340
Это система, где каждый байт

1212
01:17:22,340 --> 01:17:25,340
используется для кодирования

1213
01:17:25,340 --> 01:17:27,340
одной десятичной.

1214
01:17:27,340 --> 01:17:30,340
двух десятичных цифр.

1215
01:17:30,340 --> 01:17:31,340
Да.

1216
01:17:31,340 --> 01:17:34,340
Binary coded decim.

1217
01:17:34,340 --> 01:17:37,340
То есть это десятичное число,

1218
01:17:37,340 --> 01:17:40,340
которое закодировано в двоичной системе.

1219
01:17:40,340 --> 01:17:43,340
То есть у вас каждый байтинг

1220
01:17:43,340 --> 01:17:47,340
имеет значение от 0 до 99.

1221
01:17:53,340 --> 01:17:57,340
И в исходном наборе x86

1222
01:17:57,340 --> 01:17:59,340
были команды, которые

1223
01:17:59,340 --> 01:18:01,340
помогали среди людей,

1224
01:18:01,340 --> 01:18:03,340
с ритмитикой такой формы.

1225
01:18:03,340 --> 01:18:05,340
В зависимости от того,

1226
01:18:05,340 --> 01:18:07,340
что вы за командой делаете,

1227
01:18:07,340 --> 01:18:09,340
там происходила

1228
01:18:09,340 --> 01:18:11,340
либо коррекция до,

1229
01:18:11,340 --> 01:18:13,340
либо коррекция после операции.

1230
01:18:13,340 --> 01:18:15,340
То есть там в зависимости от того,

1231
01:18:15,340 --> 01:18:17,340
как вы делаете сложение

1232
01:18:17,340 --> 01:18:19,340
или умножение,

1233
01:18:19,340 --> 01:18:21,340
вам нужно было

1234
01:18:21,340 --> 01:18:23,340
поставить вот эту команду

1235
01:18:23,340 --> 01:18:25,340
до или после этой ритмической команды

1236
01:18:25,340 --> 01:18:27,340
с такими числами,

1237
01:18:27,340 --> 01:18:29,340
чтобы получился результат

1238
01:18:29,340 --> 01:18:31,340
снова в такой же форме.

1239
01:18:31,340 --> 01:18:33,340
Ну, костыли, ужас.

1240
01:18:33,340 --> 01:18:35,340
Да, да.

1241
01:18:35,340 --> 01:18:37,340
Вот эти костыли,

1242
01:18:37,340 --> 01:18:39,340
они доблестно сохранялись

1243
01:18:39,340 --> 01:18:41,340
в системе команд.

1244
01:18:41,340 --> 01:18:43,340
Конечно, они были реализованы

1245
01:18:43,340 --> 01:18:45,340
не в железе, а в микрокоде,

1246
01:18:45,340 --> 01:18:47,340
но тем не менее

1247
01:18:47,340 --> 01:18:49,340
они доблестно работали.

1248
01:18:49,340 --> 01:18:51,340
И вот сейчас эти команды

1249
01:18:51,340 --> 01:18:53,340
таки наконец выкинули,

1250
01:18:53,340 --> 01:18:55,340
чтобы освободить их коды

1251
01:18:55,340 --> 01:18:57,340
под что-то ложненькое.

1252
01:18:57,340 --> 01:18:59,340
Вот.

1253
01:18:59,340 --> 01:19:01,340
Ничего не хочется использовать

1254
01:19:01,340 --> 01:19:03,340
огромные коды

1255
01:19:03,340 --> 01:19:05,340
с 10 префиксами,

1256
01:19:05,340 --> 01:19:07,340
как для других вещей.

1257
01:19:07,340 --> 01:19:09,340
Потом выкинули команды.

1258
01:19:09,340 --> 01:19:11,340
Так это вообще бесполезные команды,

1259
01:19:11,340 --> 01:19:13,340
их в компилятор никогда не сгенерят.

1260
01:19:13,340 --> 01:19:15,340
Да.

1261
01:19:15,340 --> 01:19:17,340
Это не значит,

1262
01:19:17,340 --> 01:19:19,340
что их никто не использует.

1263
01:19:19,340 --> 01:19:21,340
Да, очень много такого.

1264
01:19:21,340 --> 01:19:23,340
Системы защиты!

1265
01:19:23,340 --> 01:19:25,340
Пусть спокоен.

1266
01:19:25,340 --> 01:19:27,340
Наверняка это кто-то использует.

1267
01:19:27,340 --> 01:19:29,340
Да.

1268
01:19:29,340 --> 01:19:31,340
Да, они просто обожают

1269
01:19:31,340 --> 01:19:33,340
всякие извращенные команды,

1270
01:19:33,340 --> 01:19:35,340
чтобы усложнить вам реверс

1271
01:19:35,340 --> 01:19:37,340
того, что у них происходит.

1272
01:19:37,340 --> 01:19:39,340
Поэтому не волнуйтесь,

1273
01:19:39,340 --> 01:19:41,340
даже самые извращенные команды

1274
01:19:41,340 --> 01:19:43,340
наверняка кому-то нужны.

1275
01:19:43,340 --> 01:19:45,340
А как же вот это сообщество людей,

1276
01:19:45,340 --> 01:19:47,340
которые пишут нечитабельный код?

1277
01:19:47,340 --> 01:19:49,340
Нет, это не нечитабельный код,

1278
01:19:49,340 --> 01:19:51,340
это специально

1279
01:19:51,340 --> 01:19:53,340
запрещенный код.

1280
01:19:53,340 --> 01:19:55,340
А как же это сообщество людей,

1281
01:19:55,340 --> 01:19:57,340
которые пишут нечитабельный код?

1282
01:19:57,340 --> 01:19:59,340
Специально

1283
01:19:59,340 --> 01:20:01,340
запутывание.

1284
01:20:01,340 --> 01:20:03,340
Нечитабельный код потом компилируется

1285
01:20:03,340 --> 01:20:05,340
во что-то нормальное,

1286
01:20:05,340 --> 01:20:07,340
но такое он не будет компилироваться.

1287
01:20:07,340 --> 01:20:09,340
Да, это немножко про другое.

1288
01:20:09,340 --> 01:20:11,340
Так вот, bound и int.

1289
01:20:11,340 --> 01:20:13,340
Что это такое?

1290
01:20:13,340 --> 01:20:15,340
Это команды, которые могут

1291
01:20:15,340 --> 01:20:17,340
сгенерировать вам

1292
01:20:17,340 --> 01:20:19,340
исключения, аппаратные исключения,

1293
01:20:19,340 --> 01:20:21,340
а не плюсовые.

1294
01:20:21,340 --> 01:20:23,340
В зависимости от чего.

1295
01:20:23,340 --> 01:20:25,340
Например, bound предназначалось

1296
01:20:25,340 --> 01:20:27,340
для проверки

1297
01:20:27,340 --> 01:20:29,340
границ индексов, массивов,

1298
01:20:29,340 --> 01:20:31,340
что типа вы там записываете

1299
01:20:31,340 --> 01:20:33,340
границу куда-то,

1300
01:20:33,340 --> 01:20:35,340
потом индекс куда-то,

1301
01:20:35,340 --> 01:20:37,340
делаете команду bound,

1302
01:20:37,340 --> 01:20:39,340
и если индекс не попадает в этот диапазон,

1303
01:20:39,340 --> 01:20:41,340
то эта команда генерирует

1304
01:20:41,340 --> 01:20:43,340
исключения.

1305
01:20:43,340 --> 01:20:45,340
Но

1306
01:20:45,340 --> 01:20:47,340
в современном мире

1307
01:20:47,340 --> 01:20:49,340
генерируются исключения,

1308
01:20:49,340 --> 01:20:51,340
это последнее, что вы хотите.

1309
01:20:51,340 --> 01:20:53,340
Потому что это дико медленно,

1310
01:20:53,340 --> 01:20:55,340
и там все вот эти границы

1311
01:20:55,340 --> 01:20:57,340
более 16-пильные.

1312
01:20:57,340 --> 01:20:59,340
Абсолютно бесполезная команда

1313
01:20:59,340 --> 01:21:01,340
по современным меркам

1314
01:21:01,340 --> 01:21:03,340
в ту же сторону.

1315
01:21:09,340 --> 01:21:11,340
Вот, может быть, расширение

1316
01:21:11,340 --> 01:21:13,340
на хоряло

1317
01:21:13,340 --> 01:21:15,340
получилось

1318
01:21:15,340 --> 01:21:17,340
интересным.

1319
01:21:17,340 --> 01:21:19,340
Но в 32-пильном мире

1320
01:21:19,340 --> 01:21:21,340
просто уже никто не использует эту команду.

1321
01:21:21,340 --> 01:21:23,340
В 16-пильном когда-то ее использовали,

1322
01:21:23,340 --> 01:21:25,340
а чтобы это использовать

1323
01:21:25,340 --> 01:21:27,340
в 32-пильном мире, неразумно.

1324
01:21:27,340 --> 01:21:29,340
Ну, еще раз,

1325
01:21:29,340 --> 01:21:31,340
чтобы ее кто-то использовал,

1326
01:21:31,340 --> 01:21:33,340
я не разу не видел.

1327
01:21:33,340 --> 01:21:35,340
Может быть, ее действительно

1328
01:21:35,340 --> 01:21:37,340
честно расширили,

1329
01:21:37,340 --> 01:21:39,340
но в 1286-м

1330
01:21:39,340 --> 01:21:41,340
никого она не использовала.

1331
01:21:41,340 --> 01:21:43,340
Вот.

1332
01:21:43,340 --> 01:21:45,340
Потом

1333
01:21:45,340 --> 01:21:47,340
довольно полезная

1334
01:21:47,340 --> 01:21:49,340
команда

1335
01:21:49,340 --> 01:21:51,340
S-A-L-C,

1336
01:21:51,340 --> 01:21:53,340
у которого

1337
01:21:53,340 --> 01:21:55,340
есть

1338
01:21:55,340 --> 01:21:57,340
команды,

1339
01:21:57,340 --> 01:21:59,340
которые долгое время

1340
01:21:59,340 --> 01:22:01,340
вообще не признавали ее существованием.

1341
01:22:01,340 --> 01:22:03,340
То есть она была долго

1342
01:22:03,340 --> 01:22:05,340
недокументированной командой,

1343
01:22:05,340 --> 01:22:07,340
которой в документации

1344
01:22:07,340 --> 01:22:09,340
не значилось, но

1345
01:22:09,340 --> 01:22:11,340
про нее, наверное, было известно.

1346
01:22:11,340 --> 01:22:13,340
Вообще, команда довольно прикольная,

1347
01:22:13,340 --> 01:22:15,340
которая ставит А-Л

1348
01:22:15,340 --> 01:22:17,340
всей витики

1349
01:22:17,340 --> 01:22:19,340
в то состояние, которое имеет

1350
01:22:19,340 --> 01:22:21,340
флаг C-F.

1351
01:22:21,340 --> 01:22:23,340
То есть она ставит А-Л

1352
01:22:23,340 --> 01:22:25,340
то, ну, довольно прикольно,

1353
01:22:25,340 --> 01:22:27,340
потому что всякие команды,

1354
01:22:27,340 --> 01:22:29,340
которые ставят

1355
01:22:29,340 --> 01:22:31,340
регистр состояния

1356
01:22:31,340 --> 01:22:33,340
в зависимости от флагов,

1357
01:22:33,340 --> 01:22:35,340
они обычно ставят 0 или 1.

1358
01:22:35,340 --> 01:22:37,340
А эта штука ставит 0

1359
01:22:37,340 --> 01:22:39,340
или FF,

1360
01:22:39,340 --> 01:22:41,340
поэтому ей пользовались.

1361
01:22:41,340 --> 01:22:43,340
Ну, вот ее, например.

1362
01:22:43,340 --> 01:22:45,340
S-A-L-L?

1363
01:22:45,340 --> 01:22:47,340
Ну, это для C-F.

1364
01:22:47,340 --> 01:22:49,340
А для C-F есть?

1365
01:22:49,340 --> 01:22:51,340
Ну, в принципе, да.

1366
01:22:51,340 --> 01:22:53,340
Ну, в принципе, да.

1367
01:22:53,340 --> 01:22:55,340
Она, не знаю,

1368
01:22:55,340 --> 01:22:57,340
сладенькая, что-то такое.

1369
01:22:57,340 --> 01:22:59,340
Была какая-то особенность,

1370
01:22:59,340 --> 01:23:01,340
почему ее много людей использовали.

1371
01:23:01,340 --> 01:23:03,340
А вот следующая будет

1372
01:23:03,340 --> 01:23:05,340
у нас в чайнике.

1373
01:23:23,340 --> 01:23:25,340
Пуша-пупа выкинуть.

1374
01:23:25,340 --> 01:23:27,340
Пуша-пупа выкинуть.

1375
01:23:27,340 --> 01:23:29,340
То есть теперь

1376
01:23:29,340 --> 01:23:31,340
нет команды сохранить

1377
01:23:31,340 --> 01:23:33,340
все регистры

1378
01:23:33,340 --> 01:23:35,340
общего назначения

1379
01:23:35,340 --> 01:23:37,340
в стэк одной команды.

1380
01:23:37,340 --> 01:23:39,340
Вместо того, чтобы

1381
01:23:39,340 --> 01:23:41,340
расширять старые

1382
01:23:41,340 --> 01:23:43,340
пуша-пупа на 16 регистров,

1383
01:23:43,340 --> 01:23:45,340
они решили,

1384
01:23:45,340 --> 01:23:47,340
что проще выберите

1385
01:23:47,340 --> 01:23:49,340
и теперь

1386
01:23:49,340 --> 01:23:51,340
нет такой проблемы.

1387
01:23:51,340 --> 01:23:53,340
Ребята,

1388
01:23:53,340 --> 01:23:55,340
когда нужно?

1389
01:23:55,340 --> 01:23:57,340
Ну, редко, когда нужно,

1390
01:23:57,340 --> 01:23:59,340
но студенты ее обычно любят.

1391
01:23:59,340 --> 01:24:01,340
Почему?

1392
01:24:01,340 --> 01:24:03,340
Потому что сохранить все регистры

1393
01:24:03,340 --> 01:24:05,340
на всякий случай.

1394
01:24:05,340 --> 01:24:07,340
Вы обращайте внимание,

1395
01:24:07,340 --> 01:24:09,340
что выкинуть.

1396
01:24:13,340 --> 01:24:15,340
Потом вы выкинули

1397
01:24:15,340 --> 01:24:17,340
там некоторое количество команд,

1398
01:24:17,340 --> 01:24:19,340
которые работают

1399
01:24:19,340 --> 01:24:21,340
с сегментными регистрами,

1400
01:24:21,340 --> 01:24:23,340
но до сегментных регистров

1401
01:24:23,340 --> 01:24:25,340
их еще не нашли,

1402
01:24:25,340 --> 01:24:27,340
поэтому я это поскидываю.

1403
01:24:27,340 --> 01:24:29,340
Выкинули

1404
01:24:29,340 --> 01:24:31,340
некоторые формы команды

1405
01:24:31,340 --> 01:24:33,340
jump и pull.

1406
01:24:45,340 --> 01:24:47,340
Абсолютно дальние

1407
01:24:47,340 --> 01:24:49,340
переходы,

1408
01:24:49,340 --> 01:24:51,340
но вы пока все равно не знаете,

1409
01:24:51,340 --> 01:24:53,340
что это дальние переходы,

1410
01:24:53,340 --> 01:24:55,340
причем и более.

1411
01:24:55,340 --> 01:24:57,340
Передописные.

1412
01:24:57,340 --> 01:24:59,340
Фар. Дальние.

1413
01:25:03,340 --> 01:25:05,340
Там есть понятие

1414
01:25:05,340 --> 01:25:07,340
называемых близких переходов

1415
01:25:07,340 --> 01:25:09,340
и дальних переходов.

1416
01:25:09,340 --> 01:25:11,340
Все переходы,

1417
01:25:11,340 --> 01:25:13,340
которые вы пользовались,

1418
01:25:13,340 --> 01:25:15,340
они все ближние.

1419
01:25:15,340 --> 01:25:17,340
Про дальние переходы

1420
01:25:17,340 --> 01:25:19,340
тоже сильно потом.

1421
01:25:19,340 --> 01:25:21,340
Поэтому некоторые формы

1422
01:25:21,340 --> 01:25:23,340
pull, jump,

1423
01:25:23,340 --> 01:25:25,340
pull.

1424
01:25:25,340 --> 01:25:27,340
Но это на самом деле

1425
01:25:27,340 --> 01:25:29,340
хоть и печально.

1426
01:25:29,340 --> 01:25:31,340
Вот это я почувствовал,

1427
01:25:31,340 --> 01:25:33,340
что вообще хотелось.

1428
01:25:33,340 --> 01:25:35,340
И из забавного

1429
01:25:37,340 --> 01:25:39,340
выкинули команды

1430
01:25:53,340 --> 01:25:55,340
C-Center, C-Z.

1431
01:25:55,340 --> 01:25:57,340
Про что это?

1432
01:25:59,340 --> 01:26:01,340
Мы, в принципе, упоминали,

1433
01:26:01,340 --> 01:26:03,340
когда говорили про команды

1434
01:26:03,340 --> 01:26:05,340
кинг, что через кинг

1435
01:26:05,340 --> 01:26:07,340
это такой старый

1436
01:26:07,340 --> 01:26:09,340
способ вызова

1437
01:26:09,340 --> 01:26:11,340
ядра.

1438
01:26:11,340 --> 01:26:13,340
Тяжелый,

1439
01:26:13,340 --> 01:26:15,340
до сих пор еще как-то

1440
01:26:15,340 --> 01:26:17,340
поддерживается, но не рекомендуется,

1441
01:26:17,340 --> 01:26:19,340
потому что это

1442
01:26:19,340 --> 01:26:21,340
не для него.

1443
01:26:21,340 --> 01:26:23,340
Предназначенный для таких

1444
01:26:23,340 --> 01:26:25,340
вещей, как прерывание

1445
01:26:25,340 --> 01:26:27,340
от железа, а не чтобы

1446
01:26:27,340 --> 01:26:29,340
по 100-500 раз

1447
01:26:29,340 --> 01:26:31,340
взорвать ядро из лидер-спейса.

1448
01:26:31,340 --> 01:26:33,340
Поэтому, для того, чтобы

1449
01:26:33,340 --> 01:26:35,340
ускорить вот этот вот

1450
01:26:35,340 --> 01:26:37,340
переход в ядро

1451
01:26:37,340 --> 01:26:39,340
и возврат обратно,

1452
01:26:39,340 --> 01:26:41,340
сделали специальные команды.

1453
01:26:41,340 --> 01:26:43,340
Во-первых, сделали

1454
01:26:43,340 --> 01:26:45,340
их интеловцы и назвали их

1455
01:26:45,340 --> 01:26:47,340
C-Center, C-Exit.

1456
01:26:47,340 --> 01:26:49,340
Что это за команды?

1457
01:26:49,340 --> 01:26:51,340
Это команды без аргументов,

1458
01:26:51,340 --> 01:26:53,340
которые делают

1459
01:26:53,340 --> 01:26:55,340
джамп

1460
01:26:55,340 --> 01:26:57,340
между уровнями перелегий

1461
01:26:57,340 --> 01:26:59,340
из третьего кольца

1462
01:26:59,340 --> 01:27:01,340
юзер-спейса в нулевое кольцо

1463
01:27:01,340 --> 01:27:03,340
Kernel Space

1464
01:27:03,340 --> 01:27:05,340
это C-Enter, и C-Exit

1465
01:27:05,340 --> 01:27:07,340
это джамп обратно.

1466
01:27:07,340 --> 01:27:09,340
В какое место они джампуют?

1467
01:27:09,340 --> 01:27:11,340
Туда,

1468
01:27:11,340 --> 01:27:13,340
куда настроено специальными

1469
01:27:13,340 --> 01:27:15,340
MSR-регистрами.

1470
01:27:15,340 --> 01:27:17,340
Мы говорили, что есть

1471
01:27:17,340 --> 01:27:19,340
специальные машино-специфичные регистры,

1472
01:27:19,340 --> 01:27:21,340
которые просто тучат.

1473
01:27:21,340 --> 01:27:23,340
И вот

1474
01:27:23,340 --> 01:27:25,340
два этих регистра

1475
01:27:25,340 --> 01:27:27,340
определяют, куда переход

1476
01:27:27,340 --> 01:27:29,340
по C-Center,

1477
01:27:29,340 --> 01:27:31,340
куда переход по C-Exit.

1478
01:27:31,340 --> 01:27:33,340
То есть это командный вид

1479
01:27:33,340 --> 01:27:35,340
джамп в ядро,

1480
01:27:35,340 --> 01:27:37,340
джамп обратно.

1481
01:27:37,340 --> 01:27:39,340
AMD-шники

1482
01:27:39,340 --> 01:27:41,340
сделали свой аналог

1483
01:27:41,340 --> 01:27:43,340
для

1484
01:27:43,340 --> 01:27:45,340
быстрого вызова ядра.

1485
01:27:53,340 --> 01:27:55,340
Давайте я здесь напишу.

1486
01:28:01,340 --> 01:28:03,340
Сейчас я вам это покажу.

1487
01:28:03,340 --> 01:28:05,340
Здесь

1488
01:28:05,340 --> 01:28:07,340
интересная история.

1489
01:28:09,340 --> 01:28:11,340
AMD-шные, смотрите,

1490
01:28:11,340 --> 01:28:13,340
командуют. Это...

1491
01:28:21,340 --> 01:28:23,340
C-Cell.

1492
01:28:23,340 --> 01:28:25,340
Это командный

1493
01:28:25,340 --> 01:28:27,340
вид

1494
01:28:27,340 --> 01:28:29,340
колл

1495
01:28:29,340 --> 01:28:31,340
в ядро.

1496
01:28:31,340 --> 01:28:33,340
То есть они также без аргументов

1497
01:28:33,340 --> 01:28:35,340
в плане куда

1498
01:28:35,340 --> 01:28:37,340
перейти.

1499
01:28:37,340 --> 01:28:39,340
И куда переходит C-Cell

1500
01:28:39,340 --> 01:28:41,340
определяется MSR-ом

1501
01:28:41,340 --> 01:28:43,340
машино-специфичным регистром.

1502
01:28:43,340 --> 01:28:45,340
Но C-Cell,

1503
01:28:45,340 --> 01:28:47,340
в отличие от C-Enter,

1504
01:28:47,340 --> 01:28:49,340
сохраняет на стеке адрес возврата,

1505
01:28:49,340 --> 01:28:51,340
откуда из юзерспейса

1506
01:28:51,340 --> 01:28:53,340
вы вызвали

1507
01:28:53,340 --> 01:28:55,340
ядро.

1508
01:28:55,340 --> 01:28:57,340
И C-Thread возвращает вас

1509
01:28:57,340 --> 01:28:59,340
в это место.

1510
01:28:59,340 --> 01:29:01,340
То есть интерфейс C-Enter, C-Exit

1511
01:29:01,340 --> 01:29:03,340
требует, что у вас

1512
01:29:03,340 --> 01:29:05,340
в юзерспейсе было фиксированное

1513
01:29:05,340 --> 01:29:07,340
место, откуда вы

1514
01:29:07,340 --> 01:29:09,340
вызываете ядро, и куда ядро

1515
01:29:09,340 --> 01:29:11,340
возвращается.

1516
01:29:11,340 --> 01:29:13,340
А C-Cell, C-Thread

1517
01:29:13,340 --> 01:29:15,340
вы можете делать вот вызов

1518
01:29:15,340 --> 01:29:17,340
ядра почти откуда угодно

1519
01:29:17,340 --> 01:29:19,340
и не париться, чтобы

1520
01:29:19,340 --> 01:29:21,340
вот ядро с юзерспейсом договорилось.

1521
01:29:21,340 --> 01:29:23,340
Так что,

1522
01:29:23,340 --> 01:29:25,340
вот, AMD-шники, конечно, поддержали

1523
01:29:25,340 --> 01:29:27,340
Intel-овские команды, потому что

1524
01:29:27,340 --> 01:29:29,340
они поддерживают все Intel-овское,

1525
01:29:29,340 --> 01:29:31,340
и добавили свои команды.

1526
01:29:31,340 --> 01:29:33,340
Угадайте, какие команды

1527
01:29:33,340 --> 01:29:35,340
использовали красивые убитые

1528
01:29:35,340 --> 01:29:37,340
операционки?

1529
01:29:39,340 --> 01:29:41,340
Потому что они

1530
01:29:41,340 --> 01:29:43,340
есть и на Intel-овских просах,

1531
01:29:43,340 --> 01:29:45,340
и на AMD-шниках.

1532
01:29:45,340 --> 01:29:47,340
Зачем писать вот под это,

1533
01:29:47,340 --> 01:29:49,340
когда этих команд

1534
01:29:49,340 --> 01:29:51,340
на Intel-овских просах нет?

1535
01:29:51,340 --> 01:29:53,340
Intel-овцы, конечно, не ставят.

1536
01:29:53,340 --> 01:29:55,340
Поэтому все пользовались

1537
01:29:55,340 --> 01:29:57,340
этими командами.

1538
01:29:57,340 --> 01:29:59,340
Поэтому, AMD-шники,

1539
01:29:59,340 --> 01:30:01,340
когда

1540
01:30:01,340 --> 01:30:03,340
вот разрабатывали 64-битное

1541
01:30:03,340 --> 01:30:05,340
расширение, они сказали, что

1542
01:30:05,340 --> 01:30:07,340
в 64-битном режиме

1543
01:30:07,340 --> 01:30:09,340
эти команды

1544
01:30:09,340 --> 01:30:11,340
выброшены, нет, они не

1545
01:30:11,340 --> 01:30:13,340
работают.

1546
01:30:13,340 --> 01:30:15,340
Соответственно, ядро

1547
01:30:15,340 --> 01:30:17,340
только так можно вызывать,

1548
01:30:17,340 --> 01:30:19,340
ну и через NT, ну NT понятно,

1549
01:30:19,340 --> 01:30:21,340
и не очень интересно.

1550
01:30:21,340 --> 01:30:23,340
А Intel-овцы, когда поддерживают

1551
01:30:23,340 --> 01:30:25,340
AMD-шное расширение, они его поддерживали

1552
01:30:25,340 --> 01:30:27,340
но целиком.

1553
01:30:27,340 --> 01:30:29,340
Поэтому они и syscall, и sysread

1554
01:30:29,340 --> 01:30:31,340
поддержали, но только

1555
01:30:31,340 --> 01:30:33,340
в 64-битном режиме.

1556
01:30:33,340 --> 01:30:35,340
Соответственно, на Intel-овских

1557
01:30:35,340 --> 01:30:37,340
просах sysenter, sysexit

1558
01:30:37,340 --> 01:30:39,340
работает и в 32, и в 64-бит.

1559
01:30:39,340 --> 01:30:41,340
Поэтому ты сейчас читаешь

1560
01:30:41,340 --> 01:30:43,340
Intel-овскую документацию.

1561
01:30:43,340 --> 01:30:45,340
А на AMD-шных

1562
01:30:45,340 --> 01:30:47,340
просах это

1563
01:30:47,340 --> 01:30:49,340
существует только в 32-битном

1564
01:30:49,340 --> 01:30:51,340
режиме, а это

1565
01:30:51,340 --> 01:30:53,340
существует везде.

1566
01:30:53,340 --> 01:30:55,340
Но таким образом,

1567
01:30:55,340 --> 01:30:57,340
AMD-шники заставили 64-битные

1568
01:30:57,340 --> 01:30:59,340
операционки использовать

1569
01:30:59,340 --> 01:31:01,340
вот этот интерфейс

1570
01:31:01,340 --> 01:31:03,340
для вызова ядра.

1571
01:31:03,340 --> 01:31:05,340
Вот такой вот у них

1572
01:31:05,340 --> 01:31:07,340
тройленд

1573
01:31:07,340 --> 01:31:09,340
для ядра

1574
01:31:09,340 --> 01:31:11,340
и пропихивания своих форм

1575
01:31:11,340 --> 01:31:13,340
каналов.

1576
01:31:13,340 --> 01:31:15,340
А еще раз, а почему Intel

1577
01:31:15,340 --> 01:31:17,340
просто не использует?

1578
01:31:17,340 --> 01:31:19,340
Медленно.

1579
01:31:19,340 --> 01:31:21,340
Этот интерфейс гораздо быстрее, чем Intel.

1580
01:31:23,340 --> 01:31:25,340
Ну и вообще,

1581
01:31:25,340 --> 01:31:27,340
их пытаются, по-моему, выпилить

1582
01:31:27,340 --> 01:31:29,340
из ядра, как они и Linux.

1583
01:31:29,340 --> 01:31:31,340
Ну да.

1584
01:31:31,340 --> 01:31:33,340
Я читал, что там

1585
01:31:33,340 --> 01:31:35,340
хотят, ну если дохватно,

1586
01:31:35,340 --> 01:31:37,340
то понятно, что дохватно,

1587
01:31:37,340 --> 01:31:39,340
просто он этот факт по дефолту

1588
01:31:39,340 --> 01:31:41,340
еще поддерживает, или по дефолту

1589
01:31:41,340 --> 01:31:43,340
его уже переключили, уже нет.

1590
01:31:43,340 --> 01:31:45,340
Ну да, хотят, но перетянуты,

1591
01:31:45,340 --> 01:31:47,340
потому что это тяжелый интерфейс

1592
01:31:47,340 --> 01:31:49,340
и практически не особо

1593
01:31:49,340 --> 01:31:51,340
кому-то нужен.

1594
01:31:51,340 --> 01:31:53,340
То есть нормальные программы

1595
01:31:53,340 --> 01:31:55,340
используют либо просто

1596
01:31:55,340 --> 01:31:57,340
вызов библиотек,

1597
01:31:57,340 --> 01:31:59,340
которые уже идут в ядро,

1598
01:31:59,340 --> 01:32:01,340
а нормальные библиотеки используют

1599
01:32:01,340 --> 01:32:03,340
правильный механизм,

1600
01:32:03,340 --> 01:32:05,340
чтобы быстро отправиться в ядро,

1601
01:32:05,340 --> 01:32:07,340
а не тормознуть

1602
01:32:07,340 --> 01:32:09,340
через интерфейс.

1603
01:32:17,340 --> 01:32:19,340
Чтобы использовать эти команды,

1604
01:32:19,340 --> 01:32:21,340
тебе нужно знать,

1605
01:32:21,340 --> 01:32:23,340
где твоя операционка в юзерспейсе

1606
01:32:23,340 --> 01:32:25,340
держит вот эту пару

1607
01:32:25,340 --> 01:32:27,340
sys.enter

1608
01:32:27,340 --> 01:32:29,340
для sys.exe.

1609
01:32:29,340 --> 01:32:31,340
...

1610
01:32:31,340 --> 01:32:33,340
...

1611
01:32:33,340 --> 01:32:35,340
...

1612
01:32:35,340 --> 01:32:37,340
...

1613
01:32:37,340 --> 01:32:39,340
...

1614
01:32:39,340 --> 01:32:41,340
...

1615
01:32:41,340 --> 01:32:43,340
...

1616
01:32:43,340 --> 01:32:45,340
...

1617
01:32:45,340 --> 01:32:47,340
...

1618
01:32:47,340 --> 01:32:49,340
...

1619
01:32:49,340 --> 01:32:51,340
...

1620
01:32:51,340 --> 01:32:53,340
...

1621
01:32:53,340 --> 01:32:55,340
...

1622
01:32:55,340 --> 01:32:57,340
...

1623
01:32:57,340 --> 01:32:59,340
...

1624
01:32:59,340 --> 01:33:01,340
...

1625
01:33:01,340 --> 01:33:03,340
...

1626
01:33:03,340 --> 01:33:05,340
...

1627
01:33:05,340 --> 01:33:07,340
...

1628
01:33:07,340 --> 01:33:09,340
...

1629
01:33:09,340 --> 01:33:13,340
...

1630
01:33:13,340 --> 01:33:15,340
...

1631
01:33:15,340 --> 01:33:17,340
...

1632
01:33:17,340 --> 01:33:19,340
...

1633
01:33:19,340 --> 01:33:31,340
Это уже четвертая табличка.

1634
01:33:31,340 --> 01:33:41,340
В принципе, да. Только это не про это, а про то, как передавать аргументы,

1635
01:33:41,340 --> 01:33:48,340
про эти диски и всякое такое.

1636
01:33:48,340 --> 01:33:55,340
Из хорошего в физически убитом мире всего две конвенции есть.

1637
01:33:55,340 --> 01:34:04,340
Да, там существуют некоторые вариации на тему, но они не существенны.

1638
01:34:04,340 --> 01:34:10,340
Вот такого дикого запаха, как было в принципе, там нет.

1639
01:34:10,340 --> 01:34:11,340
Ничего же.

1640
01:34:11,340 --> 01:34:13,340
Какого запаха используют?

1641
01:34:13,340 --> 01:34:15,340
Ну, мне кажется, Дельфи используют.

1642
01:34:15,340 --> 01:34:20,340
Дельфи, мне кажется, используют.

1643
01:34:20,340 --> 01:34:23,340
У меня вообще не существовало Дельфи, поэтому не могу сказать.

1644
01:34:23,340 --> 01:34:27,340
Одно я уже что-то ковырял и все.

1645
01:34:27,340 --> 01:34:30,340
И вот оно очень даже множество.

1646
01:34:30,340 --> 01:34:36,340
Я его открывал, ужаснулся и закрыл.

1647
01:34:36,340 --> 01:34:40,340
Нет, я открывал код Дельфи.

1648
01:34:40,340 --> 01:34:41,340
Страдал.

1649
01:34:41,340 --> 01:34:42,340
Страдал.

1650
01:34:42,340 --> 01:34:45,340
Вообще, Дельфи гнирюет очень фаршиво.

1651
01:34:45,340 --> 01:34:47,340
Его прям очень больно читать.

1652
01:34:47,340 --> 01:34:53,340
Там для того, чтобы сделать кто-то аналог строкопивая из одной строчки в другую,

1653
01:34:53,340 --> 01:35:00,340
там выложены, по-моему, три уровня выложенности функций, чтобы сделать это действие.

1654
01:35:00,340 --> 01:35:03,340
То есть нормально, если что-то не компилировать, просто inline,

1655
01:35:03,340 --> 01:35:06,340
то у тебя такой мелкий цикл, который очевиден.

1656
01:35:06,340 --> 01:35:10,340
А там функция вызывает функцию, вызывает функцию, которая в итоге все,

1657
01:35:10,340 --> 01:35:13,340
что делает строкопивая.

1658
01:35:13,340 --> 01:35:16,340
Очень больно читается.

1659
01:35:16,340 --> 01:35:19,340
Итак, конверсии вызова.

1660
01:35:19,340 --> 01:35:28,340
Во-первых, рассмотрим штуку, которая называется FastCon64.

1661
01:35:28,340 --> 01:35:36,340
Обратите внимание, в отличие от того зоопарка, который был в крестоюбитом мире и назывался FastCon,

1662
01:35:36,340 --> 01:35:39,340
FastCon64 — это жесткая конверсия.

1663
01:35:39,340 --> 01:35:45,340
Это жесткая конкретная конверсия вызова без всяких неоднозначностей.

1664
01:35:45,340 --> 01:35:51,340
И это единственная конверсия вызова 64-х видов под Windows.

1665
01:35:51,340 --> 01:35:57,340
То есть вы, в принципе, можете сказать там в своем коде два подчеркивания CDECAL,

1666
01:35:57,340 --> 01:36:01,340
два подчеркивания STDECAL в C-шном коде.

1667
01:36:01,340 --> 01:36:06,340
Оно будет компилятором прочитано и жестко заебывается.

1668
01:36:06,340 --> 01:36:08,340
Потому что используется только...

1669
01:36:09,340 --> 01:36:12,340
Только одна конверсия.

1670
01:36:12,340 --> 01:36:17,340
И вот эти подобные комментарии будут просто игнорироваться.

1671
01:36:17,340 --> 01:36:19,340
Что здесь происходит?

1672
01:36:19,340 --> 01:36:20,340
— Игнорируются только виды. — Что?

1673
01:36:20,340 --> 01:36:23,340
— Игнорируются только виды. — Тоже игнорируются.

1674
01:36:23,340 --> 01:36:26,340
Там тоже только один вариант.

1675
01:36:26,340 --> 01:36:29,340
Но другой.

1676
01:36:29,340 --> 01:36:31,340
Итак, что здесь происходит?

1677
01:36:31,340 --> 01:36:35,340
Как следует из названия, это конверсия вида FastCon.

1678
01:36:35,340 --> 01:36:37,340
То есть она использует...

1679
01:36:37,340 --> 01:36:42,340
Регистры для передачи некоторого количества аргументов.

1680
01:36:42,340 --> 01:36:48,340
И регистры следующие.

1681
01:36:48,340 --> 01:36:51,340
Аргументы.

1682
01:36:51,340 --> 01:36:53,340
RCX,

1683
01:36:53,340 --> 01:36:55,340
RDX,

1684
01:36:55,340 --> 01:36:57,340
R8,

1685
01:36:57,340 --> 01:37:00,340
R9.

1686
01:37:00,340 --> 01:37:03,340
— Это два аргумента? — Да.

1687
01:37:03,340 --> 01:37:06,340
То есть первые четыре аргумента.

1688
01:37:06,340 --> 01:37:09,340
И двух регистров.

1689
01:37:09,340 --> 01:37:13,340
— Их три, да? — Да.

1690
01:37:13,340 --> 01:37:19,340
Или...

1691
01:37:19,340 --> 01:37:23,340
ХММ 0 по 3.

1692
01:37:23,340 --> 01:37:28,340
Ну и вот это вот последствия того, что мы ведем не исторически.

1693
01:37:28,340 --> 01:37:32,340
Эти ХММ-регистры — это про плавающую точку.

1694
01:37:32,340 --> 01:37:35,340
Его мы поскидываем пока.

1695
01:37:35,340 --> 01:37:40,340
Поэтому отметьте себе вот это вот замечание.

1696
01:37:40,340 --> 01:37:44,340
Это будет про ровные числа.

1697
01:37:44,340 --> 01:37:49,340
То есть если первые аргументы кто-то был фло,

1698
01:37:49,340 --> 01:37:51,340
что плавающая точка,

1699
01:37:51,340 --> 01:37:57,340
то он пойдет в соответствующий ХММ-регистр.

1700
01:37:57,340 --> 01:38:01,340
Обратите внимание на слово «или».

1701
01:38:01,340 --> 01:38:04,340
Это означает, что первый аргумент

1702
01:38:04,340 --> 01:38:07,340
идет либо в РЦХ,

1703
01:38:07,340 --> 01:38:10,340
либо в ХММ 0.

1704
01:38:10,340 --> 01:38:12,340
В зависимости от его типа.

1705
01:38:12,340 --> 01:38:14,340
Если он числочисленный,

1706
01:38:14,340 --> 01:38:16,340
то в РЦХ.

1707
01:38:16,340 --> 01:38:18,340
Если есть плавающая точка,

1708
01:38:18,340 --> 01:38:20,340
то в ХММ 0.

1709
01:38:20,340 --> 01:38:23,340
А второй аргумент идет куда?

1710
01:38:23,340 --> 01:38:25,340
Или в РДХ,

1711
01:38:25,340 --> 01:38:28,340
или в СММ 1.

1712
01:38:28,340 --> 01:38:30,340
И куда шел первый аргумент —

1713
01:38:30,340 --> 01:38:32,340
вообще неважно.

1714
01:38:32,340 --> 01:38:35,340
То есть первые четыре аргумента

1715
01:38:35,340 --> 01:38:37,340
идут в эти регистры.

1716
01:38:37,340 --> 01:38:40,340
А нельзя ли восемь аргументов?

1717
01:38:40,340 --> 01:38:41,340
Нет.

1718
01:38:41,340 --> 01:38:42,340
Еще раз.

1719
01:38:42,340 --> 01:38:44,340
Оно вот так вот поскидывается.

1720
01:38:44,340 --> 01:38:46,340
Первые четыре аргумента через регистры.

1721
01:38:46,340 --> 01:38:50,340
И эти регистры фиксированы следующим образом.

1722
01:38:54,340 --> 01:38:57,340
То есть можно мешать РЦХ и ХММ,

1723
01:38:57,340 --> 01:38:59,340
но только четыре регистра.

1724
01:38:59,340 --> 01:39:00,340
Еще раз.

1725
01:39:00,340 --> 01:39:04,340
Они отвечаются в зависимости от типа аргументов.

1726
01:39:04,340 --> 01:39:06,340
Целочисленные аргументы,

1727
01:39:06,340 --> 01:39:08,340
целые числа и указатели

1728
01:39:08,340 --> 01:39:11,340
идут в обычные регистры.

1729
01:39:11,340 --> 01:39:15,340
Плавающая точка идет сюда.

1730
01:39:15,340 --> 01:39:18,340
И первые четыре аргумента в регистрах.

1731
01:39:18,340 --> 01:39:20,340
Просто в каком регистре

1732
01:39:20,340 --> 01:39:22,340
зависит от типа аргументов.

1733
01:39:22,340 --> 01:39:25,340
А почему нельзя восемь аргументов?

1734
01:39:25,340 --> 01:39:27,340
Потому что так постулировали.

1735
01:39:27,340 --> 01:39:29,340
Почему так постулировали?

1736
01:39:30,340 --> 01:39:32,340
Потому что нужно было как-то постулировать,

1737
01:39:32,340 --> 01:39:34,340
и они постулировали вот так.

1738
01:39:34,340 --> 01:39:37,340
На самом деле это имеет смысл.

1739
01:39:37,340 --> 01:39:39,340
Мы увидим уже попозже.

1740
01:39:39,340 --> 01:39:41,340
А если у меня один Инт, один Флот?

1741
01:39:41,340 --> 01:39:42,340
Как я их отправлю?

1742
01:39:42,340 --> 01:39:43,340
Я что ж не догадался.

1743
01:39:43,340 --> 01:39:44,340
Я не уловил.

1744
01:39:44,340 --> 01:39:47,340
Инт, Флот в ХММ-1.

1745
01:39:47,340 --> 01:39:49,340
То есть если первый у тебя Инт,

1746
01:39:49,340 --> 01:39:50,340
а потом Флот,

1747
01:39:50,340 --> 01:39:52,340
то Инт идет в РЦХ,

1748
01:39:52,340 --> 01:39:54,340
Флот в ХММ-1.

1749
01:39:54,340 --> 01:39:57,340
То есть соотношение вот такое.

1750
01:39:57,340 --> 01:39:58,340
Или туда, или туда.

1751
01:40:00,340 --> 01:40:02,340
То есть Инт возвращает Флот на РЦХ.

1752
01:40:02,340 --> 01:40:03,340
Возвращает, да.

1753
01:40:03,340 --> 01:40:05,340
Мы же не дошли до этого.

1754
01:40:05,340 --> 01:40:06,340
Ну да, да.

1755
01:40:06,340 --> 01:40:07,340
Мы же не дошли,

1756
01:40:07,340 --> 01:40:09,340
мы возвращаем на франшизу.

1757
01:40:12,340 --> 01:40:13,340
Так.

1758
01:40:13,340 --> 01:40:16,340
Теперь какие регистры нужно сохранять?

1759
01:40:20,340 --> 01:40:22,340
Сохранять нужно.

1760
01:40:30,340 --> 01:40:42,340
다면

1761
01:40:42,340 --> 01:40:49,340
Aziku

1762
01:40:50,340 --> 01:40:51,340
И вот это вот.

1763
01:40:51,340 --> 01:40:53,340
Боль, страдания

1764
01:40:54,740 --> 01:40:55,340
и поумедяции.

1765
01:40:56,340 --> 01:40:57,340
И что значит

1766
01:40:57,340 --> 01:40:59,340
обидно?

1767
01:40:59,340 --> 01:41:15,340
Нет. Пока до СМА мы не дошли, давай так, о будущем. Говорю, что вот эту конвенцию составлял козел, который вообще не имеет мозга и не думал о будущем.

1768
01:41:15,340 --> 01:41:36,100
Вот всякое вот это разумно, окей, понятно, что они имеют в виду, имеют свои плюсы, к этому нет претензий. Вот это полный идиотизм, страдания, боль и неадекватность. Но, к сожалению, с этим уже ничего не сделать.

1769
01:41:36,100 --> 01:41:43,320
— Сейчас, то есть, типа, все вот эти регистры и вот эти?

1770
01:41:43,320 --> 01:41:45,260
— Да. Нет, ну вот это просто норм.

1771
01:41:45,340 --> 01:41:55,840
В этом нет ничего плохого. А вот это очень больно, глупо и так далее. Но почему, пока не знаете. Потому что мы вот идем этим другим путем.

1772
01:41:55,840 --> 01:41:57,340
— Потому что мы скипали свою точку.

1773
01:41:57,340 --> 01:42:08,340
— Да. Мы поскипали правую точку и синт, поэтому это вот залегай на будущее, пометьте себе, попозже поймете почему.

1774
01:42:08,340 --> 01:42:13,340
— А вызывающая стаканчик?

1775
01:42:13,340 --> 01:42:15,340
— Покрик.

1776
01:42:15,340 --> 01:42:25,340
— Вызываемая функция — эти регистры, если хочешь менять, то должна вернуть в исходное состояние.

1777
01:42:25,340 --> 01:42:32,340
В тридцатилюбительном мире у нас было вот так вот. Ну, только Е. Вот видишь, очень похоже.

1778
01:42:32,340 --> 01:42:33,340
— ЕВХ.

1779
01:42:33,340 --> 01:42:41,340
— ЕВХ, ЕВП, ЕСА, ЕДА. То есть вот это вот прям как вывел в тридцатилюбительном мире, только R.

1780
01:42:41,340 --> 01:42:43,340
Вот это новые регистры — тоже норм.

1781
01:42:43,340 --> 01:42:53,340
Вот это — большая, но вы ее пока не знаете.

1782
01:42:53,340 --> 01:42:59,340
Возвращаемое значение.

1783
01:42:59,340 --> 01:43:01,340
Результат.

1784
01:43:01,340 --> 01:43:05,340
В.

1785
01:43:05,340 --> 01:43:11,340
Сказать лучше.

1786
01:43:11,340 --> 01:43:17,340
Аккумуляторе.

1787
01:43:17,340 --> 01:43:19,340
Я вот так напишу.

1788
01:43:19,340 --> 01:43:25,340
Или...

1789
01:43:25,340 --> 01:43:27,340
— Это ХММО.

1790
01:43:27,340 --> 01:43:29,340
— ХММО, да.

1791
01:43:29,340 --> 01:43:35,340
Потому что это поплавающая точка.

1792
01:43:35,340 --> 01:43:39,340
На самом деле нужно будет небольшую штучку добавить.

1793
01:43:39,340 --> 01:43:41,340
И в тридцатилюбительной конвенции поплавающая точка.

1794
01:43:41,340 --> 01:43:45,340
Но я вам думаю, поплавающая точка — это последующая точка.

1795
01:43:45,340 --> 01:43:47,340
Занятие.

1796
01:43:47,340 --> 01:43:49,340
Поэтому так. Отложил.

1797
01:43:49,340 --> 01:43:51,340
А здесь уж.

1798
01:43:51,340 --> 01:43:53,340
Сейчас мы все целиком рассматриваем.

1799
01:43:53,340 --> 01:43:55,340
Наверное, довольно тесно здесь связано.

1800
01:43:55,340 --> 01:43:57,340
С происходящим. Поэтому...

1801
01:43:57,340 --> 01:44:01,340
— А если больше, то указатель сюда подороже записан.

1802
01:44:01,340 --> 01:44:03,340
— Да.

1803
01:44:03,340 --> 01:44:05,340
Если у вас аргументов больше,

1804
01:44:05,340 --> 01:44:07,340
то аргументы идут на стейки.

1805
01:44:07,340 --> 01:44:11,340
Если возвращаемое значение

1806
01:44:11,340 --> 01:44:13,340
не лезет

1807
01:44:13,340 --> 01:44:15,340
в аккумулятор,

1808
01:44:15,340 --> 01:44:17,340
то то же самое, что было в тридцатилюбительном мире,

1809
01:44:17,340 --> 01:44:19,340
это тоже нулевым значением указатель.

1810
01:44:19,340 --> 01:44:21,340
И поэтому указатель

1811
01:44:21,340 --> 01:44:23,340
будет сохранять значение.

1812
01:44:23,340 --> 01:44:25,340
И идеи эти такие еще.

1813
01:44:25,340 --> 01:44:27,340
— То есть ИСИ возможно вызвать

1814
01:44:27,340 --> 01:44:29,340
спецплюсными методами.

1815
01:44:29,340 --> 01:44:31,340
— Да.

1816
01:44:31,340 --> 01:44:33,340
То есть здесь нет всяких извращений

1817
01:44:33,340 --> 01:44:35,340
про

1818
01:44:35,340 --> 01:44:37,340
РЦХ или еще что-нибудь.

1819
01:44:37,340 --> 01:44:39,340
— Да.

1820
01:44:45,340 --> 01:44:47,340
— Другое дело, что, по-моему,

1821
01:44:47,340 --> 01:44:49,340
там порядок,

1822
01:44:49,340 --> 01:44:51,340
который крупное

1823
01:44:51,340 --> 01:44:53,340
возвращаемое значение

1824
01:44:53,340 --> 01:44:55,340
и ЗИС.

1825
01:44:55,340 --> 01:44:57,340
По-моему, там Microsoft.

1826
01:44:57,340 --> 01:44:59,340
Я, правда, не помню точно. Надо уточнить.

1827
01:44:59,340 --> 01:45:01,340
В каком порядке идут эти

1828
01:45:01,340 --> 01:45:03,340
аргументы.

1829
01:45:03,340 --> 01:45:05,340
— Это в конвенции начали?

1830
01:45:05,340 --> 01:45:07,340
— Да. Единственная конвенция,

1831
01:45:07,340 --> 01:45:09,340
которая была в тридцатилюбительном мире.

1832
01:45:09,340 --> 01:45:11,340
— Мы же говорили две.

1833
01:45:11,340 --> 01:45:13,340
— Нет. В шестидесятилюбительном мире

1834
01:45:13,340 --> 01:45:15,340
все конвенции. Одна обендована,

1835
01:45:15,340 --> 01:45:17,340
другая не обендована. Поэтому,

1836
01:45:17,340 --> 01:45:19,340
когда у вас есть операционка,

1837
01:45:19,340 --> 01:45:21,340
то вы строго привязаны

1838
01:45:21,340 --> 01:45:23,340
к одной конвенции.

1839
01:45:23,340 --> 01:45:25,340
— А.

1840
01:45:25,340 --> 01:45:27,340
— Вот.

1841
01:45:27,340 --> 01:45:29,340
Поэтому всякие комментарии в коде

1842
01:45:29,340 --> 01:45:31,340
про конвенцию игнорируются,

1843
01:45:31,340 --> 01:45:33,340
потому что какую конвенцию использовать

1844
01:45:33,340 --> 01:45:35,340
определяется таргетом под какую

1845
01:45:35,340 --> 01:45:37,340
конвенцию.

1846
01:45:37,340 --> 01:45:39,340
Потому что у вас один вариант,

1847
01:45:39,340 --> 01:45:41,340
что использовать.

1848
01:45:41,340 --> 01:45:43,340
Так.

1849
01:45:43,340 --> 01:45:45,340
Какие еще

1850
01:45:45,340 --> 01:45:47,340
базовые расходы

1851
01:45:47,340 --> 01:45:49,340
носите?

1852
01:45:49,340 --> 01:45:51,340
— Конвенция.

1853
01:45:51,340 --> 01:45:53,340
Я смотрю, какая-то мудро-красная

1854
01:45:53,340 --> 01:45:55,340
операционка. Она просто где-то

1855
01:45:55,340 --> 01:45:57,340
внутри себя указывается?

1856
01:45:57,340 --> 01:45:59,340
— Ваша операционка должна постулировать,

1857
01:45:59,340 --> 01:46:01,340
какую конвенцию использует она,

1858
01:46:01,340 --> 01:46:03,340
системные библиотеки и прочее.

1859
01:46:03,340 --> 01:46:05,340
— Такой вопрос.

1860
01:46:05,340 --> 01:46:07,340
Если у меня код

1861
01:46:07,340 --> 01:46:09,340
генерированный с фронтами,

1862
01:46:09,340 --> 01:46:11,340
и он использует CSW-конвенцию...

1863
01:46:11,340 --> 01:46:13,340
— Если он внутри себя использует,

1864
01:46:13,340 --> 01:46:15,340
то никто об этом не узнает,

1865
01:46:15,340 --> 01:46:17,340
пока он не взаимодействует

1866
01:46:17,340 --> 01:46:19,340
никак с внешним миром.

1867
01:46:19,340 --> 01:46:21,340
— Да.

1868
01:46:21,340 --> 01:46:23,340
И вот, если я буду пытаться

1869
01:46:23,340 --> 01:46:25,340
записать код на людей,

1870
01:46:25,340 --> 01:46:27,340
мне надо писать про ставки,

1871
01:46:27,340 --> 01:46:29,340
которые будут конвертировать...

1872
01:46:29,340 --> 01:46:31,340
— Если он внутри себя это использует

1873
01:46:31,340 --> 01:46:33,340
и ни с кем не взаимодействует,

1874
01:46:33,340 --> 01:46:35,340
если его вызывают,

1875
01:46:35,340 --> 01:46:37,340
то все будет так.

1876
01:46:37,340 --> 01:46:39,340
— Да. Надо писать про ставки,

1877
01:46:39,340 --> 01:46:41,340
которые будут конвертировать

1878
01:46:41,340 --> 01:46:43,340
обе магазины по-другому.

1879
01:46:43,340 --> 01:46:45,340
— Да. Вообще проще просто

1880
01:46:45,340 --> 01:46:47,340
компилировать.

1881
01:46:47,340 --> 01:46:49,340
Потому что целом мы можем сказать,

1882
01:46:49,340 --> 01:46:51,340
что компилируют это обе.

1883
01:46:51,340 --> 01:46:53,340
— Это G-code.

1884
01:46:53,340 --> 01:46:55,340
— Только еще раз.

1885
01:46:55,340 --> 01:46:57,340
— Я не использую G-code.

1886
01:46:57,340 --> 01:46:59,340
— Я думаю, что компиляторы

1887
01:46:59,340 --> 01:47:01,340
умеют использовать разные обе.

1888
01:47:01,340 --> 01:47:03,340
— Ну, это уже твои проблемы.

1889
01:47:03,340 --> 01:47:05,340
— Ну, это уже твои проблемы.

1890
01:47:05,340 --> 01:47:07,340
— Потому что мне надо писать

1891
01:47:07,340 --> 01:47:09,340
за ручками про ставки,

1892
01:47:09,340 --> 01:47:11,340
которые будут конвертировать

1893
01:47:11,340 --> 01:47:13,340
один обе.

1894
01:47:13,340 --> 01:47:15,340
— И просто компилировать

1895
01:47:15,340 --> 01:47:17,340
другой обе.

1896
01:47:17,340 --> 01:47:19,340
— Можно, например,

1897
01:47:19,340 --> 01:47:21,340
аналогистами писать.

1898
01:47:27,340 --> 01:47:29,340
— Так, это были базовые штучки.

1899
01:47:29,340 --> 01:47:31,340
И еще

1900
01:47:31,340 --> 01:47:33,340
в 64-битных конвенциях

1901
01:47:33,340 --> 01:47:35,340
есть

1902
01:47:35,340 --> 01:47:37,340
и в той, и в той фича.

1903
01:47:37,340 --> 01:47:39,340
Не знаю, как это

1904
01:47:39,340 --> 01:47:41,340
по-другому назвать.

1905
01:47:49,340 --> 01:47:51,340
Здесь она называется

1906
01:47:51,340 --> 01:47:53,340
shadow space.

1907
01:47:59,340 --> 01:48:01,340
Что это такое?

1908
01:48:01,340 --> 01:48:03,340
Shadow space —

1909
01:48:03,340 --> 01:48:05,340
это специальная конфигурация

1910
01:48:05,340 --> 01:48:07,340
стэка,

1911
01:48:07,340 --> 01:48:09,340
которая выглядит

1912
01:48:09,340 --> 01:48:11,340
следующим образом.

1913
01:48:13,340 --> 01:48:15,340
Вот.

1914
01:48:15,340 --> 01:48:17,340
Как выглядит стэк

1915
01:48:17,340 --> 01:48:19,340
в функции, когда ее

1916
01:48:19,340 --> 01:48:21,340
вызовут.

1917
01:48:23,340 --> 01:48:25,340
Вот здесь адрес возврата.

1918
01:48:25,340 --> 01:48:27,340
Здесь вы там

1919
01:48:27,340 --> 01:48:29,340
сохраняете всякие

1920
01:48:29,340 --> 01:48:31,340
быстрые ваши локальные

1921
01:48:31,340 --> 01:48:33,340
предметы, да,

1922
01:48:33,340 --> 01:48:35,340
на его адресе старшего.

1923
01:48:35,340 --> 01:48:37,340
И вот здесь

1924
01:48:37,340 --> 01:48:39,340
у вас аргументы, функции,

1925
01:48:39,340 --> 01:48:41,340
которые не вызовут людей.

1926
01:48:41,340 --> 01:48:43,340
Понятно, да?

1927
01:48:43,340 --> 01:48:45,340
Так вот,

1928
01:48:45,340 --> 01:48:47,340
shadow space —

1929
01:48:47,340 --> 01:48:49,340
это вот это место.

1930
01:48:51,340 --> 01:48:53,340
Это между

1931
01:48:53,340 --> 01:48:55,340
аргументами и ритмами?

1932
01:48:55,340 --> 01:48:57,340
Да.

1933
01:48:57,340 --> 01:48:59,340
32 байта.

1934
01:48:59,340 --> 01:49:01,340
Здесь пошли уже аргументы.

1935
01:49:01,340 --> 01:49:03,340
арг...

1936
01:49:03,340 --> 01:49:05,340
арг...

1937
01:49:05,340 --> 01:49:07,340
Ну, если считать, что это арг 0,

1938
01:49:07,340 --> 01:49:09,340
то это будет

1939
01:49:09,340 --> 01:49:11,340
арг 4, арг 5,

1940
01:49:11,340 --> 01:49:13,340
и так далее.

1941
01:49:17,340 --> 01:49:19,340
Смотрите,

1942
01:49:19,340 --> 01:49:21,340
у вас после

1943
01:49:21,340 --> 01:49:23,340
адреса возврата

1944
01:49:23,340 --> 01:49:25,340
и перед аргументами

1945
01:49:25,340 --> 01:49:27,340
есть 32 байта пространства,

1946
01:49:27,340 --> 01:49:29,340
которое вы можете использовать

1947
01:49:29,340 --> 01:49:31,340
как хотите.

1948
01:49:31,340 --> 01:49:33,340
Зачем?

1949
01:49:33,340 --> 01:49:35,340
Ну, на самом деле,

1950
01:49:35,340 --> 01:49:37,340
это не доказаться даже.

1951
01:49:37,340 --> 01:49:39,340
Вы указаете?

1952
01:49:39,340 --> 01:49:41,340
Нет.

1953
01:49:41,340 --> 01:49:43,340
Нет.

1954
01:49:43,340 --> 01:49:45,340
Кто добавляет

1955
01:49:45,340 --> 01:49:47,340
большого количества

1956
01:49:47,340 --> 01:49:49,340
заморочек

1957
01:49:49,340 --> 01:49:51,340
к конвенциям вызовов?

1958
01:49:51,340 --> 01:49:53,340
Нет.

1959
01:49:53,340 --> 01:49:55,340
Вы уже слышали это слово

1960
01:49:55,340 --> 01:49:57,340
в прошлый раз.

1961
01:49:57,340 --> 01:49:59,340
Сейчас еще раз.

1962
01:49:59,340 --> 01:50:01,340
Пора.

1963
01:50:01,340 --> 01:50:03,340
Функции

1964
01:50:03,340 --> 01:50:05,340
с неизвестным количеством аргументов.

1965
01:50:05,340 --> 01:50:07,340
Смотрите.

1966
01:50:07,340 --> 01:50:09,340
Чем удобно

1967
01:50:09,340 --> 01:50:11,340
это Shadow Space?

1968
01:50:11,340 --> 01:50:13,340
32 байта

1969
01:50:13,340 --> 01:50:15,340
это как раз место,

1970
01:50:15,340 --> 01:50:17,340
чтобы сбросить

1971
01:50:17,340 --> 01:50:19,340
эти аргументы

1972
01:50:19,340 --> 01:50:21,340
из регистров

1973
01:50:21,340 --> 01:50:23,340
на стэп

1974
01:50:23,340 --> 01:50:25,340
и получить

1975
01:50:25,340 --> 01:50:27,340
обычную линейную

1976
01:50:27,340 --> 01:50:29,340
адресацию, как

1977
01:50:29,340 --> 01:50:31,340
в вашем аргументе.

1978
01:50:31,340 --> 01:50:33,340
Проблема

1979
01:50:33,340 --> 01:50:35,340
с вараргами,

1980
01:50:35,340 --> 01:50:37,340
когда у вас фастхол,

1981
01:50:37,340 --> 01:50:39,340
что вы должны специальным образом

1982
01:50:39,340 --> 01:50:41,340
обрабатывать несколько

1983
01:50:41,340 --> 01:50:43,340
начальных значений,

1984
01:50:43,340 --> 01:50:45,340
а потом по-другому

1985
01:50:45,340 --> 01:50:47,340
все остальные аргументы.

1986
01:50:47,340 --> 01:50:49,340
А здесь вы можете

1987
01:50:49,340 --> 01:50:51,340
ваши специальные значения

1988
01:50:51,340 --> 01:50:53,340
из регистров сбросить

1989
01:50:53,340 --> 01:50:55,340
на стэп и получить

1990
01:50:55,340 --> 01:50:57,340
унифицированную адресацию

1991
01:50:57,340 --> 01:50:59,340
ко всем аргументам,

1992
01:50:59,340 --> 01:51:01,340
которые есть в вашем аргументе.

1993
01:51:01,340 --> 01:51:03,340
Это реально упрощается

1994
01:51:03,340 --> 01:51:05,340
относительно всяких других

1995
01:51:05,340 --> 01:51:07,340
фастхол-вариантов.

1996
01:51:07,340 --> 01:51:09,340
Ты можешь это сделать.

1997
01:51:09,340 --> 01:51:11,340
Ты не обязан это делать.

1998
01:51:11,340 --> 01:51:13,340
Но у тебя есть место,

1999
01:51:13,340 --> 01:51:15,340
куда ты можешь сбросить

2000
01:51:15,340 --> 01:51:17,340
и сделать простую индексацию

2001
01:51:17,340 --> 01:51:19,340
для варарг-функций.

2002
01:51:19,340 --> 01:51:21,340
Это просто место,

2003
01:51:21,340 --> 01:51:23,340
которое ты можешь использовать

2004
01:51:23,340 --> 01:51:25,340
как хочешь.

2005
01:51:25,340 --> 01:51:27,340
Оно явно предназначалось

2006
01:51:27,340 --> 01:51:29,340
в вашем аргументе.

2007
01:51:29,340 --> 01:51:31,340
Но никто не запрещает

2008
01:51:31,340 --> 01:51:33,340
использовать его как ты хочешь.

2009
01:51:33,340 --> 01:51:35,340
Например, располагать там

2010
01:51:35,340 --> 01:51:37,340
свои локальные ферменты.

2011
01:51:37,340 --> 01:51:39,340
И поэтому нельзя ввозить аргументы?

2012
01:51:39,340 --> 01:51:41,340
Нет, не поэтому.

2013
01:51:41,340 --> 01:51:43,340
Просто потому что так решили.

2014
01:51:43,340 --> 01:51:45,340
Еще раз.

2015
01:51:45,340 --> 01:51:47,340
Просто здесь так постулировать.

2016
01:51:47,340 --> 01:51:49,340
И на самом деле

2017
01:51:49,340 --> 01:51:51,340
то, что всего 4 аргумента,

2018
01:51:51,340 --> 01:51:53,340
они 4 вот сюда

2019
01:51:53,340 --> 01:51:55,340
в любом случае лезут.

2020
01:51:55,340 --> 01:51:57,340
То есть и добры,

2021
01:51:57,340 --> 01:51:59,340
тоже можно сбросить.

2022
01:51:59,340 --> 01:52:01,340
И все будет хорошо и удобно.

2023
01:52:01,340 --> 01:52:03,340
То есть это было

2024
01:52:03,340 --> 01:52:05,340
специально для вас проведено.

2025
01:52:11,340 --> 01:52:13,340
Потому что стек

2026
01:52:13,340 --> 01:52:15,340
изменяется в 64-битном мире

2027
01:52:15,340 --> 01:52:17,340
8-байтными порциями.

2028
01:52:19,340 --> 01:52:21,340
Если вы пытаетесь

2029
01:52:21,340 --> 01:52:23,340
передать в качестве аргумента

2030
01:52:23,340 --> 01:52:25,340
функции,

2031
01:52:25,340 --> 01:52:27,340
то этот инк на стеке

2032
01:52:27,340 --> 01:52:29,340
будет считать в 8 байт.

2033
01:52:29,340 --> 01:52:31,340
Частично будет намного лучше.

2034
01:52:33,340 --> 01:52:35,340
Потому что стек идет шагами

2035
01:52:35,340 --> 01:52:37,340
от видности.

2036
01:52:37,340 --> 01:52:39,340
Если ваш аргумент меньше,

2037
01:52:39,340 --> 01:52:41,340
у вас будет неиспользованное место.

2038
01:52:45,340 --> 01:52:47,340
Вот такая ключа.

2039
01:52:47,340 --> 01:52:49,340
Shadow Space.

2040
01:52:49,340 --> 01:52:51,340
Притом, обращаю ваше внимание,

2041
01:52:51,340 --> 01:52:53,340
что это место 32 байта

2042
01:52:53,340 --> 01:52:55,340
оно фиксировано.

2043
01:52:55,340 --> 01:52:57,340
Абсолютно все функции его получают.

2044
01:52:57,340 --> 01:52:59,340
Даже если у функции

2045
01:52:59,340 --> 01:53:01,340
один аргумент или

2046
01:53:01,340 --> 01:53:03,340
ноль аргументов,

2047
01:53:03,340 --> 01:53:05,340
все равно в Shadow Space

2048
01:53:05,340 --> 01:53:07,340
в полной размерности 32 байта

2049
01:53:07,340 --> 01:53:09,340
положен функция.

2050
01:53:09,340 --> 01:53:11,340
Я помню,

2051
01:53:11,340 --> 01:53:13,340
когда я

2052
01:53:13,340 --> 01:53:15,340
только начал экспериментировать

2053
01:53:15,340 --> 01:53:17,340
с 64-битными,

2054
01:53:17,340 --> 01:53:19,340
я вызывал функцию

2055
01:53:19,340 --> 01:53:21,340
лап-клатина ревендовую,

2056
01:53:21,340 --> 01:53:23,340
которая принимает один аргумент.

2057
01:53:23,340 --> 01:53:25,340
А если нет,

2058
01:53:25,340 --> 01:53:27,340
так я не выделю 8 байт.

2059
01:53:27,340 --> 01:53:29,340
Ни один аргумент.

2060
01:53:29,340 --> 01:53:31,340
У меня все покрашено.

2061
01:53:31,340 --> 01:53:33,340
Почему?

2062
01:53:33,340 --> 01:53:35,340
Потому что что происходило

2063
01:53:35,340 --> 01:53:37,340
внутри функции лап-клатины?

2064
01:53:37,340 --> 01:53:39,340
Она просто записывала константочки

2065
01:53:39,340 --> 01:53:41,340
в некоторые регистры

2066
01:53:41,340 --> 01:53:43,340
и делала джамп

2067
01:53:43,340 --> 01:53:45,340
на функцию лап-клатины

2068
01:53:45,340 --> 01:53:47,340
yes,

2069
01:53:47,340 --> 01:53:49,340
на которой требуем.

2070
01:53:49,340 --> 01:53:51,340
И та функция

2071
01:53:51,340 --> 01:53:53,340
уже на стек сохраняла

2072
01:53:53,340 --> 01:53:55,340
4 аргумента

2073
01:53:55,340 --> 01:53:57,340
и вылезала за мои 8 байтиков,

2074
01:53:57,340 --> 01:53:59,340
которые я выделил.

2075
01:53:59,340 --> 01:54:01,340
То есть, вот Shadow Space

2076
01:54:01,340 --> 01:54:03,340
имеет фиксированный размер 32 байта

2077
01:54:03,340 --> 01:54:05,340
и не связан

2078
01:54:05,340 --> 01:54:07,340
с количеством аргументов.

2079
01:54:07,340 --> 01:54:09,340
4 аргумента, 64,

2080
01:54:09,340 --> 01:54:11,340
2 аргумента,

2081
01:54:11,340 --> 01:54:13,340
в любом случае функция получает

2082
01:54:13,340 --> 01:54:15,340
Shadow Space размером 32 байта.

2083
01:54:15,340 --> 01:54:17,340
Понятно?

2084
01:54:17,340 --> 01:54:19,340
Это ключа

2085
01:54:19,340 --> 01:54:21,340
конденса.

2086
01:54:21,340 --> 01:54:23,340
Кроме того, есть еще одна особенность,

2087
01:54:23,340 --> 01:54:25,340
которая тоже относится ко всем

2088
01:54:25,340 --> 01:54:27,340
конденсиям 64.

2089
01:54:27,340 --> 01:54:29,340
Видно, что перед

2090
01:54:29,340 --> 01:54:31,340
вызовом функции,

2091
01:54:31,340 --> 01:54:33,340
то есть вот в этот момент,

2092
01:54:33,340 --> 01:54:35,340
стек поинта

2093
01:54:37,340 --> 01:54:39,340
должен быть кратен

2094
01:54:39,340 --> 01:54:41,340
64.

2095
01:54:41,340 --> 01:54:43,340
Вот тьфу, 16, 64.

2096
01:54:47,340 --> 01:54:49,340
16 байт.

2097
01:54:53,340 --> 01:54:57,340
Ну, вообще,

2098
01:54:57,340 --> 01:54:59,340
если вы ведете себя цивилизованно,

2099
01:54:59,340 --> 01:55:01,340
то

2100
01:55:01,340 --> 01:55:03,340
какая кратность может быть у

2101
01:55:03,340 --> 01:55:05,340
стек поинтера в 64 битах?

2102
01:55:05,340 --> 01:55:07,340
Либо

2103
01:55:07,340 --> 01:55:09,340
кратно 16,

2104
01:55:09,340 --> 01:55:11,340
либо на 8 не кратно

2105
01:55:11,340 --> 01:55:13,340
16.

2106
01:55:13,340 --> 01:55:15,340
То есть, либо кратно, либо полукратно.

2107
01:55:15,340 --> 01:55:17,340
Так вот,

2108
01:55:17,340 --> 01:55:19,340
в момент того, когда мы делаете

2109
01:55:19,340 --> 01:55:21,340
call, то есть

2110
01:55:21,340 --> 01:55:23,340
перед

2111
01:55:23,340 --> 01:55:25,340
вызовом функции,

2112
01:55:25,340 --> 01:55:27,340
стек поинтер должен быть кратен

2113
01:55:27,340 --> 01:55:29,340
16.

2114
01:55:31,340 --> 01:55:33,340
Соответственно, когда

2115
01:55:33,340 --> 01:55:35,340
войду в функцию,

2116
01:55:35,340 --> 01:55:37,340
то ваш стек поинтер будет

2117
01:55:37,340 --> 01:55:39,340
не кратен 16.

2118
01:55:39,340 --> 01:55:41,340
Да.

2119
01:55:41,340 --> 01:55:43,340
Поэтому, если вы решите

2120
01:55:43,340 --> 01:55:45,340
мгновенно кого-то вызвать,

2121
01:55:45,340 --> 01:55:47,340
то вам нужно

2122
01:55:47,340 --> 01:55:49,340
стек поинтер опустить не на

2123
01:55:49,340 --> 01:55:51,340
32 байта,

2124
01:55:51,340 --> 01:55:53,340
а на

2125
01:55:53,340 --> 01:55:55,340
40.

2126
01:55:55,340 --> 01:55:57,340
Потому что вам нужно выделить

2127
01:55:57,340 --> 01:55:59,340
32 байта

2128
01:55:59,340 --> 01:56:01,340
и выливать стек поинтер.

2129
01:56:03,340 --> 01:56:05,340
Вот, заключите себе,

2130
01:56:05,340 --> 01:56:07,340
что

2131
01:56:07,340 --> 01:56:09,340
в момент выполнения

2132
01:56:09,340 --> 01:56:11,340
команды call,

2133
01:56:11,340 --> 01:56:13,340
перед командой call, стек поинтер

2134
01:56:13,340 --> 01:56:15,340
должен быть кратен 16.

2135
01:56:17,340 --> 01:56:19,340
И, соответственно,

2136
01:56:19,340 --> 01:56:21,340
когда вы только что оказались

2137
01:56:21,340 --> 01:56:23,340
внутри функции, ваш

2138
01:56:23,340 --> 01:56:25,340
стек поинтер ровно на 8

2139
01:56:25,340 --> 01:56:27,340
не кратен 16.

2140
01:56:35,340 --> 01:56:37,340
Что будет,

2141
01:56:37,340 --> 01:56:39,340
если вы забьете на это

2142
01:56:39,340 --> 01:56:41,340
требование?

2143
01:56:41,340 --> 01:56:43,340
Либо все будет работать,

2144
01:56:43,340 --> 01:56:45,340
либо кто-то покрашится.

2145
01:56:45,340 --> 01:56:47,340
Почему кто-то может покрашиться,

2146
01:56:47,340 --> 01:56:49,340
если у вас не кратен

2147
01:56:49,340 --> 01:56:51,340
стек поинтер?

2148
01:56:51,340 --> 01:56:53,340
Поэтому мы узнаем,

2149
01:56:53,340 --> 01:56:55,340
когда дойдем до этих самых

2150
01:56:55,340 --> 01:56:57,340
xml-регистров.

2151
01:56:57,340 --> 01:56:59,340
Вот это требование к кратности 16,

2152
01:56:59,340 --> 01:57:01,340
оно связано с xml-регистрами.

2153
01:57:05,340 --> 01:57:07,340
Поэтому, если тот, кого вы вызываете,

2154
01:57:07,340 --> 01:57:09,340
не использует xml-регистры,

2155
01:57:09,340 --> 01:57:11,340
и кого он вызывает,

2156
01:57:11,340 --> 01:57:13,340
не использует xml-регистры,

2157
01:57:13,340 --> 01:57:15,340
то оно даже будет работать,

2158
01:57:15,340 --> 01:57:17,340
если вы нарушите это требование к кратности.

2159
01:57:17,340 --> 01:57:19,340
Но если кто-то там

2160
01:57:19,340 --> 01:57:21,340
использует xml-регистры,

2161
01:57:21,340 --> 01:57:23,340
то у вас есть хорошие шансы,

2162
01:57:23,340 --> 01:57:25,340
что оно в том месте покрашится.

2163
01:57:25,340 --> 01:57:27,340
Получается, перед каждым

2164
01:57:27,340 --> 01:57:29,340
вызовом группа 164

2165
01:57:29,340 --> 01:57:31,340
должен стоять sub-rsp 32?

2166
01:57:31,340 --> 01:57:33,340
Нет.

2167
01:57:33,340 --> 01:57:35,340
Нет.

2168
01:57:35,340 --> 01:57:37,340
Это я вам сейчас рассказал

2169
01:57:37,340 --> 01:57:39,340
как-то такую топологию стека.

2170
01:57:39,340 --> 01:57:41,340
Но

2171
01:57:41,340 --> 01:57:43,340
использование стека

2172
01:57:43,340 --> 01:57:45,340
в 64-битном мире

2173
01:57:45,340 --> 01:57:47,340
оно другое.

2174
01:57:47,340 --> 01:57:49,340
Если в 64-битном мире

2175
01:57:49,340 --> 01:57:51,340
вы привыкли

2176
01:57:51,340 --> 01:57:53,340
вызывать функции как

2177
01:57:53,340 --> 01:57:55,340
push-push-call,

2178
01:57:55,340 --> 01:57:57,340
push-push-call, push-push-call,

2179
01:57:57,340 --> 01:57:59,340
то в 64-битном мире

2180
01:57:59,340 --> 01:58:01,340
выглядит не так.

2181
01:58:01,340 --> 01:58:03,340
В 64-битном мире

2182
01:58:03,340 --> 01:58:05,340
стек-пойнтер обычно

2183
01:58:05,340 --> 01:58:07,340
один раз опускается

2184
01:58:07,340 --> 01:58:09,340
в самом начале функции,

2185
01:58:09,340 --> 01:58:11,340
резервируя место и под ваши

2186
01:58:11,340 --> 01:58:13,340
локальные переменные,

2187
01:58:13,340 --> 01:58:15,340
и под аргументы,

2188
01:58:15,340 --> 01:58:17,340
которые могут потребоваться,

2189
01:58:17,340 --> 01:58:19,340
а потом на стек аргументы

2190
01:58:19,340 --> 01:58:21,340
складываются командой mov.

2191
01:58:21,340 --> 01:58:23,340
То есть у вас перед каждым

2192
01:58:23,340 --> 01:58:25,340
вызовом функции

2193
01:58:25,340 --> 01:58:27,340
никакой shadow space

2194
01:58:27,340 --> 01:58:29,340
не выделяется.

2195
01:58:29,340 --> 01:58:31,340
Он выделяется один раз

2196
01:58:31,340 --> 01:58:33,340
при входе в функцию,

2197
01:58:33,340 --> 01:58:35,340
вы опускаете стек-пойнтер

2198
01:58:35,340 --> 01:58:37,340
вот насколько он может

2199
01:58:37,340 --> 01:58:39,340
максимум потребоваться.

2200
01:58:39,340 --> 01:58:41,340
Это справедливо

2201
01:58:41,340 --> 01:58:43,340
для почти всех функций,

2202
01:58:43,340 --> 01:58:45,340
кроме тех,

2203
01:58:45,340 --> 01:58:47,340
которые динамически

2204
01:58:47,340 --> 01:58:49,340
выделяют место на стеке

2205
01:58:49,340 --> 01:58:51,340
неизвестного размера

2206
01:58:51,340 --> 01:58:55,340
.

2207
01:58:55,340 --> 01:58:57,340
Обычные функции ведут себя

2208
01:58:57,340 --> 01:58:59,340
еще раз.

2209
01:58:59,340 --> 01:59:01,340
Стек-пойнтер опускается

2210
01:59:01,340 --> 01:59:03,340
и только в конце стек-пойнтер

2211
01:59:03,340 --> 01:59:05,340
возвращается обратно.

2212
01:59:05,340 --> 01:59:07,340
Поэтому аргументы

2213
01:59:07,340 --> 01:59:09,340
через mov.

2214
01:59:09,340 --> 01:59:11,340
shadow space

2215
01:59:11,340 --> 01:59:13,340
есть автоматически,

2216
01:59:13,340 --> 01:59:15,340
потому что вы должны его учесть,

2217
01:59:15,340 --> 01:59:17,340
когда опускаете стек-пойнтер.

2218
01:59:19,340 --> 01:59:21,340
Это место, принадлежащее

2219
01:59:21,340 --> 01:59:23,340
вызываемой функции,

2220
01:59:23,340 --> 01:59:25,340
которая может делать с ним

2221
01:59:25,340 --> 01:59:27,340
все, что хочет,

2222
01:59:27,340 --> 01:59:29,340
и, соответственно,

2223
01:59:29,340 --> 01:59:31,340
вы можете делать с этим местом

2224
01:59:31,340 --> 01:59:33,340
все, что хотите.

2225
01:59:33,340 --> 01:59:35,340
Вы можете сохранять переменные

2226
01:59:35,340 --> 01:59:37,340
как хотите,

2227
01:59:37,340 --> 01:59:39,340
используя эти 32 байка,

2228
01:59:39,340 --> 01:59:41,340
они принадлежат вам.

2229
01:59:41,340 --> 01:59:43,340
Понятно?

2230
01:59:43,340 --> 01:59:45,340
Вот.

2231
01:59:45,340 --> 01:59:47,340
Это была

2232
01:59:47,340 --> 01:59:49,340
диндовая конвенция

2233
01:59:49,340 --> 01:59:51,340
по стек-пойнту 64.

2234
01:59:51,340 --> 01:59:53,340
.

2235
01:59:53,340 --> 01:59:55,340
.

2236
01:59:55,340 --> 01:59:57,340
.

2237
01:59:57,340 --> 01:59:59,340
.

2238
01:59:59,340 --> 02:00:01,340
.

2239
02:00:01,340 --> 02:00:03,340
.

2240
02:00:03,340 --> 02:00:05,340
.

2241
02:00:05,340 --> 02:00:07,340
.

2242
02:00:07,340 --> 02:00:09,340
.

2243
02:00:09,340 --> 02:00:13,340
.

2244
02:00:13,340 --> 02:00:15,340
.

2245
02:00:15,340 --> 02:00:17,340
.

2246
02:00:17,340 --> 02:00:19,340
.

2247
02:00:19,340 --> 02:00:25,340
.

2248
02:00:25,340 --> 02:00:27,340
.

2249
02:00:27,340 --> 02:00:29,340
.

2250
02:00:29,340 --> 02:00:31,340
.

2251
02:00:31,340 --> 02:00:33,340
.

2252
02:00:33,340 --> 02:00:35,340
.

2253
02:00:35,340 --> 02:00:37,340
.

2254
02:00:37,340 --> 02:00:39,340
.

2255
02:00:39,340 --> 02:00:41,340
.

2256
02:00:41,340 --> 02:00:43,340
.

2257
02:00:43,340 --> 02:00:45,340
.

2258
02:00:45,340 --> 02:00:47,340
.

2259
02:00:47,340 --> 02:00:57,340
. .

2260
02:00:57,340 --> 02:00:59,340
.

2261
02:00:59,340 --> 02:01:01,340
.

2262
02:01:01,340 --> 02:01:03,340
.

2263
02:01:03,340 --> 02:01:05,340
.

2264
02:01:05,340 --> 02:01:07,340
.

2265
02:01:07,340 --> 02:01:09,340
.

2266
02:01:09,340 --> 02:01:11,340
.

2267
02:01:11,340 --> 02:01:13,340
.

2268
02:01:13,340 --> 02:01:15,340
.

2269
02:01:15,340 --> 02:01:25,340
. .

2270
02:01:25,340 --> 02:01:27,340
.

2271
02:01:27,340 --> 02:01:29,340
.

2272
02:01:29,340 --> 02:01:31,340
.

2273
02:01:31,340 --> 02:01:33,340
.

2274
02:01:33,340 --> 02:01:35,340
.

2275
02:01:35,340 --> 02:01:37,340
.

2276
02:01:37,340 --> 02:01:39,340
.

2277
02:01:39,340 --> 02:01:41,340
.

2278
02:01:41,340 --> 02:01:43,340
.

2279
02:01:43,340 --> 02:01:55,340
. .

2280
02:01:55,340 --> 02:01:57,340
. .

2281
02:01:57,340 --> 02:01:59,340
.

2282
02:01:59,340 --> 02:02:01,340
.

2283
02:02:01,340 --> 02:02:03,340
.

2284
02:02:03,340 --> 02:02:05,340
.

2285
02:02:05,340 --> 02:02:07,340
.

2286
02:02:07,340 --> 02:02:09,340
.

2287
02:02:09,340 --> 02:02:11,340
.

2288
02:02:11,340 --> 02:02:31,340
.

2289
02:02:31,340 --> 02:02:35,340
Вот это аргументы.

2290
02:02:35,340 --> 02:02:40,340
То есть аргументы можно передавать через огромное количество регистров.

2291
02:02:40,340 --> 02:02:41,340
Обратите внимание,

2292
02:02:41,340 --> 02:02:42,340
на слово

2293
02:02:42,340 --> 02:02:44,340
И.

2294
02:02:44,340 --> 02:02:45,340
Это означает,

2295
02:02:45,340 --> 02:02:46,340
что

2296
02:02:46,340 --> 02:02:48,340
число с плавающей точкой

2297
02:02:48,340 --> 02:02:49,340
независимо

2298
02:02:49,340 --> 02:02:50,340
от

2299
02:02:50,340 --> 02:02:51,340
сочисленных аргументов

2300
02:02:51,340 --> 02:02:53,340
используют свои регистры.

2301
02:02:53,340 --> 02:02:54,340
То есть,

2302
02:02:54,340 --> 02:02:56,340
если у вас, например, первый аргумент

2303
02:02:56,340 --> 02:02:57,340
сочисленный,

2304
02:02:57,340 --> 02:02:58,340
а потом плавающая точка,

2305
02:02:58,340 --> 02:03:00,340
а потом снова целое число,

2306
02:03:00,340 --> 02:03:01,340
то

2307
02:03:01,340 --> 02:03:03,340
первое сочисленное значение

2308
02:03:03,340 --> 02:03:04,340
пойдет в RDI,

2309
02:03:04,340 --> 02:03:05,340
плавающая точка

2310
02:03:05,340 --> 02:03:06,340
в XM0,

2311
02:03:06,340 --> 02:03:08,340
а второе сочисленное

2312
02:03:08,340 --> 02:03:10,340
в RSE.

2313
02:03:10,340 --> 02:03:15,340
То есть используются и те регистры,

2314
02:03:15,340 --> 02:03:16,340
и те регистры

2315
02:03:16,340 --> 02:03:18,340
вместе, одновременно.

2316
02:03:18,340 --> 02:03:20,340
Не или как было

2317
02:03:20,340 --> 02:03:22,340
по сколу 64.

2318
02:03:22,340 --> 02:03:24,340
.

2319
02:03:24,340 --> 02:03:26,340
.

2320
02:03:26,340 --> 02:03:28,340
Да, можно дофигачивать

2321
02:03:28,340 --> 02:03:30,340
и передать регистры.

2322
02:03:30,340 --> 02:03:31,340
Но,

2323
02:03:31,340 --> 02:03:33,340
как несложно догадаться,

2324
02:03:33,340 --> 02:03:35,340
это резко повышает

2325
02:03:35,340 --> 02:03:37,340
сложность

2326
02:03:37,340 --> 02:03:39,340
по сколу функций.

2327
02:03:39,340 --> 02:03:41,340
.

2328
02:03:41,340 --> 02:03:43,340
Потому что в RAR

2329
02:03:43,340 --> 02:03:44,340
не разобраться,

2330
02:03:44,340 --> 02:03:46,340
что у вас происходит.

2331
02:03:46,340 --> 02:03:48,340
Удачи!

2332
02:03:48,340 --> 02:03:49,340
.

2333
02:03:49,340 --> 02:03:50,340
И,

2334
02:03:50,340 --> 02:03:51,340
поэтому,

2335
02:03:51,340 --> 02:03:52,340
если ваша функция

2336
02:03:52,340 --> 02:03:54,340
в RAR,

2337
02:03:54,340 --> 02:03:56,340
количество аргументов

2338
02:03:56,340 --> 02:03:58,340
вот в этих регистрах

2339
02:03:58,340 --> 02:04:00,340
необходимо указать

2340
02:04:00,340 --> 02:04:06,340
в RAX.

2341
02:04:06,340 --> 02:04:07,340
То есть,

2342
02:04:07,340 --> 02:04:08,340
если вы

2343
02:04:08,340 --> 02:04:09,340
вызываете

2344
02:04:09,340 --> 02:04:10,340
print,

2345
02:04:10,340 --> 02:04:14,340
то количество аргументов,

2346
02:04:14,340 --> 02:04:16,340
которые вы запихали вот сюда,

2347
02:04:16,340 --> 02:04:19,340
необходимо указать в RAX.

2348
02:04:19,340 --> 02:04:22,340
Если вы сюда запихали 0 аргументов,

2349
02:04:22,340 --> 02:04:24,340
вы должны указать 0 в RAX.

2350
02:04:24,340 --> 02:04:26,340
Если вы этого не сделаете

2351
02:04:26,340 --> 02:04:28,340
и оставите в RAX мусор,

2352
02:04:28,340 --> 02:04:30,340
то print у вас покрашится.

2353
02:04:30,340 --> 02:04:36,340
.

2354
02:04:36,340 --> 02:04:38,340
Количество аргументов

2355
02:04:38,340 --> 02:04:40,340
в XMM регистрах.

2356
02:04:40,340 --> 02:04:42,340
.

2357
02:04:42,340 --> 02:04:43,340
Еще раз.

2358
02:04:43,340 --> 02:04:45,340
Для VARARG функций

2359
02:04:45,340 --> 02:04:47,340
сколько аргументов вы

2360
02:04:47,340 --> 02:04:49,340
заполнили в XMM регистрах,

2361
02:04:49,340 --> 02:04:51,340
необходимо указать

2362
02:04:51,340 --> 02:04:53,340
в регистре RAX перед вызовом.

2363
02:04:53,340 --> 02:04:55,340
.

2364
02:04:55,340 --> 02:04:57,340
RAX – это количество используемых

2365
02:04:57,340 --> 02:04:59,340
XMM для VARARG функций.

2366
02:04:59,340 --> 02:05:01,340
.

2367
02:05:01,340 --> 02:05:03,340
Получается,

2368
02:05:03,340 --> 02:05:05,340
у нас через stack не передаются аргументы?

2369
02:05:05,340 --> 02:05:07,340
Или там избыток какой-то?

2370
02:05:07,340 --> 02:05:09,340
.

2371
02:05:09,340 --> 02:05:10,340
Конечно же,

2372
02:05:10,340 --> 02:05:12,340
остальные, которые не навестились в регистрах,

2373
02:05:12,340 --> 02:05:14,340
отправляются на stack в обратном порядке,

2374
02:05:14,340 --> 02:05:16,340
но это довольно интуитивная идея.

2375
02:05:16,340 --> 02:05:22,340
.

2376
02:05:22,340 --> 02:05:24,340
То есть другие аргументы на stack

2377
02:05:24,340 --> 02:05:26,340
в обратном порядке по обычным правилам.

2378
02:05:26,340 --> 02:05:28,340
Здесь ничего нового.

2379
02:05:28,340 --> 02:05:30,340
Но вот в регистрах

2380
02:05:30,340 --> 02:05:32,340
такие правила,

2381
02:05:32,340 --> 02:05:34,340
и для VARARG вот такие правила.

2382
02:05:34,340 --> 02:05:38,340
.

2383
02:05:38,340 --> 02:05:40,340
Плавающая точка уходит в эти регистры,

2384
02:05:40,340 --> 02:05:42,340
не плавающая точка

2385
02:05:42,340 --> 02:05:44,340
идет в регистр общего значения.

2386
02:05:44,340 --> 02:05:46,340
.

2387
02:05:46,340 --> 02:05:48,340
Так, что нужно сохранять?

2388
02:05:48,340 --> 02:05:50,340
Сохранять нужно меньше.

2389
02:05:50,340 --> 02:05:52,340
.

2390
02:05:52,340 --> 02:05:54,340
.

2391
02:05:54,340 --> 02:05:56,340
.

2392
02:05:56,340 --> 02:05:58,340
.

2393
02:05:58,340 --> 02:06:00,340
.

2394
02:06:00,340 --> 02:06:02,340
.

2395
02:06:02,340 --> 02:06:04,340
.

2396
02:06:04,340 --> 02:06:06,340
.

2397
02:06:06,340 --> 02:06:08,340
.

2398
02:06:08,340 --> 02:06:10,340
.

2399
02:06:10,340 --> 02:06:12,340
.

2400
02:06:12,340 --> 02:06:14,340
.

2401
02:06:14,340 --> 02:06:16,340
.

2402
02:06:16,340 --> 02:06:18,340
.

2403
02:06:18,340 --> 02:06:20,340
.

2404
02:06:20,340 --> 02:06:22,340
.

2405
02:06:22,340 --> 02:06:24,340
.

2406
02:06:24,340 --> 02:06:26,340
.

2407
02:06:26,340 --> 02:06:28,340
.

2408
02:06:28,340 --> 02:06:30,340
.

2409
02:06:30,340 --> 02:06:32,340
.

2410
02:06:32,340 --> 02:06:34,340
.

2411
02:06:34,340 --> 02:06:36,340
.

2412
02:06:36,340 --> 02:06:38,340
.

2413
02:06:38,340 --> 02:06:40,340
.

2414
02:06:40,340 --> 02:06:42,340
.

2415
02:06:42,340 --> 02:06:44,340
.

2416
02:06:44,340 --> 02:06:46,340
.

2417
02:06:46,340 --> 02:06:48,340
.

2418
02:06:48,340 --> 02:06:50,340
.

2419
02:06:50,340 --> 02:06:52,340
.

2420
02:06:52,340 --> 02:06:54,340
.

2421
02:06:54,340 --> 02:06:56,340
.

2422
02:06:56,340 --> 02:06:58,340
.

2423
02:06:58,340 --> 02:07:00,340
.

2424
02:07:00,340 --> 02:07:04,340
. .

2425
02:07:04,340 --> 02:07:08,340
. .

2426
02:07:08,340 --> 02:07:10,340
.

2427
02:07:10,340 --> 02:07:12,340
.

2428
02:07:12,340 --> 02:07:14,340
.

2429
02:07:14,340 --> 02:07:16,340
.

2430
02:07:16,340 --> 02:07:18,340
.

2431
02:07:18,340 --> 02:07:20,340
.

2432
02:07:20,340 --> 02:07:22,340
.

2433
02:07:22,340 --> 02:07:24,340
.

2434
02:07:24,340 --> 02:07:26,340
.

2435
02:07:26,340 --> 02:07:28,340
.

2436
02:07:28,340 --> 02:07:41,380
Так, да, аккумулятор и вроде как XMM 0 по 1.

2437
02:07:42,420 --> 02:07:45,380
Тоже я об этом читал, но сам никогда не видел.

2438
02:07:46,920 --> 02:07:49,020
Зачем может потребоваться 2 XMM?

2439
02:07:49,020 --> 02:07:53,940
Я предполагаю, может быть для комплекса чисел.

2440
02:07:53,940 --> 02:08:06,500
Когда ваше значение состоит из 2 чисел, может быть вот эта комплексная часть пройдет XMM 1, но нужно проверить.

2441
02:08:07,480 --> 02:08:08,700
Какой размер XMM есть?

2442
02:08:09,080 --> 02:08:15,340
Да фига, но обычно используется в передаче организма только в меньшую часть.

2443
02:08:15,340 --> 02:08:21,460
То есть с точки зрения размеров, конечно, там хватит на 4 флота,

2444
02:08:22,180 --> 02:08:23,900
но так обычно.

2445
02:08:23,940 --> 02:08:33,180
Поэтому я предполагаю, зачем нужен XMM 1, чтобы для комплекса чисел.

2446
02:08:33,620 --> 02:08:34,660
Но надо проверить.

2447
02:08:37,420 --> 02:08:40,560
Стек также нужно выравнивать на 16.

2448
02:08:41,940 --> 02:08:45,640
Но здесь есть уже своя фича.

2449
02:08:46,420 --> 02:08:52,560
Фича называется здесь PREDU.

2450
02:08:53,940 --> 02:08:55,940
Что за RedDoll?

2451
02:08:57,940 --> 02:08:59,940
Это вот такая картинка.

2452
02:09:16,420 --> 02:09:20,420
Вот здесь аргументы, которые у нас в пенте.

2453
02:09:23,940 --> 02:09:30,940
Адрес возврата.

2454
02:09:30,940 --> 02:09:33,940
Стекпоинты выравниваем.

2455
02:09:33,940 --> 02:09:37,940
А RedDoll это вот эта штука.

2456
02:09:37,940 --> 02:09:48,940
Даже не совсем так она выглядит.

2457
02:09:48,940 --> 02:09:49,940
Адрес возврата.

2458
02:09:49,940 --> 02:09:50,940
Адрес возврата.

2459
02:09:50,940 --> 02:09:51,940
Адрес возврата.

2460
02:09:51,940 --> 02:09:52,940
Стекпоинты выравниваем.

2461
02:09:52,940 --> 02:09:54,640
Делаем вот так.

2462
02:09:56,900 --> 02:09:58,240
Там газовые батареи.

2463
02:09:58,360 --> 02:09:59,360
Режимы закрываю.

2464
02:09:59,740 --> 02:10:01,700
И это все.

2465
02:10:02,180 --> 02:10:03,180
Батарейка.

2466
02:10:04,060 --> 02:10:04,540
Видите?

2467
02:10:04,860 --> 02:10:06,020
Вот здесь они закрываются.

2468
02:10:06,180 --> 02:10:06,940
Этоzie рет Bloggers.

2469
02:10:07,940 --> 02:10:11,940
И это возможность поменять свой пакет.

2470
02:10:13,940 --> 02:10:16,740
Скажу, что я ещё час поставил.

2471
02:10:16,940 --> 02:10:18,440
Скажу, что изменилось.

2472
02:10:18,940 --> 02:10:20,940
Ну, и сейчас вы с нами.

2473
02:10:20,940 --> 02:10:21,840
Смотрите.

2474
02:10:21,840 --> 02:10:22,260
Что?

2475
02:10:22,260 --> 02:10:22,540
Смотрите.

2476
02:10:22,540 --> 02:10:23,760
сохранить на стеке.

2477
02:10:24,480 --> 02:10:25,700
Мы говорили о чем?

2478
02:10:26,120 --> 02:10:26,980
Как это сделать?

2479
02:10:27,720 --> 02:10:30,800
Вам нужно вначале опустить стекпоинтер

2480
02:10:30,800 --> 02:10:32,860
и потом

2481
02:10:32,860 --> 02:10:33,880
сохранять значение.

2482
02:10:34,740 --> 02:10:36,500
То есть писать ниже

2483
02:10:36,500 --> 02:10:38,560
стекпоинтера не надо.

2484
02:10:39,140 --> 02:10:39,440
Почему?

2485
02:10:40,480 --> 02:10:42,180
Потому что сохранность данных

2486
02:10:42,180 --> 02:10:44,780
ниже стекпоинтера, честно говоря,

2487
02:10:45,400 --> 02:10:47,140
не гарантируется системе.

2488
02:10:47,980 --> 02:10:48,840
Что может пройти

2489
02:10:48,840 --> 02:10:50,400
какое-нибудь там прерывание

2490
02:10:50,400 --> 02:10:51,520
или еще что,

2491
02:10:52,540 --> 02:10:55,260
и данные ниже стекпоинтера

2492
02:10:55,260 --> 02:10:56,840
считаются, что они никому

2493
02:10:56,840 --> 02:10:58,600
не принадлежат, мусор,

2494
02:10:58,880 --> 02:10:59,920
их можно портить.

2495
02:11:01,320 --> 02:11:01,820
Поэтому,

2496
02:11:02,720 --> 02:11:04,560
если вы сохраните там данные,

2497
02:11:05,020 --> 02:11:07,140
вас мгновенно никто не поругает.

2498
02:11:08,300 --> 02:11:09,320
Но сохранность

2499
02:11:09,320 --> 02:11:10,100
данных там

2500
02:11:10,100 --> 02:11:11,660
не гарантируется.

2501
02:11:13,640 --> 02:11:14,720
Так вот, Red Zone

2502
02:11:14,720 --> 02:11:17,280
это специальная гарантия,

2503
02:11:18,000 --> 02:11:18,780
что данные

2504
02:11:18,780 --> 02:11:20,260
ниже стекпоинтера

2505
02:11:20,260 --> 02:11:21,980
до 128

2506
02:11:21,980 --> 02:11:23,980
байт гарантированно

2507
02:11:23,980 --> 02:11:24,680
сохраняются.

2508
02:11:26,720 --> 02:11:28,340
То есть никакое прерывание

2509
02:11:28,340 --> 02:11:30,360
и подобное не будет

2510
02:11:30,360 --> 02:11:32,120
портить вам данные

2511
02:11:32,120 --> 02:11:34,900
на 128 байт

2512
02:11:34,900 --> 02:11:35,980
ниже стекпоинтера.

2513
02:11:35,980 --> 02:11:36,900
А у нас СВЦ актуально?

2514
02:11:37,540 --> 02:11:39,880
Нет. Это не СВЦ,

2515
02:11:40,060 --> 02:11:42,000
это операционка гарантирует.

2516
02:11:42,720 --> 02:11:42,900
А.

2517
02:11:43,440 --> 02:11:46,160
Ну, даже, я думаю, вот эта гарантия

2518
02:11:46,160 --> 02:11:46,960
уже олимпиада.

2519
02:11:47,540 --> 02:11:49,820
Я не верю, насколько эта антидашная конвенция

2520
02:11:49,820 --> 02:11:50,640
гарантировала.

2521
02:11:51,980 --> 02:11:53,620
Ну, здесь я уже так

2522
02:11:53,620 --> 02:11:55,240
затрудняюсь сказать,

2523
02:11:56,280 --> 02:11:57,140
чья это гарантия.

2524
02:11:57,200 --> 02:11:58,380
То есть под Linux это так.

2525
02:12:00,120 --> 02:12:01,720
Под другими системами, которые

2526
02:12:01,720 --> 02:12:03,800
используют подобную конвенцию,

2527
02:12:03,940 --> 02:12:04,760
так ли это?

2528
02:12:06,380 --> 02:12:07,640
Не могу сказать.

2529
02:12:09,400 --> 02:12:10,180
Ну, у нас так.

2530
02:12:10,940 --> 02:12:12,320
У нас только одна винда Linux.

2531
02:12:14,820 --> 02:12:15,900
Под MacOS

2532
02:12:15,900 --> 02:12:17,080
то же самое, что под Linux.

2533
02:12:19,140 --> 02:12:19,760
Ну, оно

2534
02:12:19,760 --> 02:12:21,420
BSD, на самом деле.

2535
02:12:21,980 --> 02:12:23,580
Тоже все время ядра, и там

2536
02:12:23,580 --> 02:12:24,240
то же самое.

2537
02:12:26,000 --> 02:12:27,620
Вот. Поэтому, если брать такие

2538
02:12:27,620 --> 02:12:29,840
крупные операционки, широко известные,

2539
02:12:30,480 --> 02:12:31,000
то вот

2540
02:12:31,000 --> 02:12:32,760
это правда.

2541
02:12:33,880 --> 02:12:36,020
Если брать какую-нибудь большую экзотику,

2542
02:12:36,200 --> 02:12:37,720
я не верю, что там

2543
02:12:37,720 --> 02:12:39,520
их редзон будет действовать. Но под Linux

2544
02:12:39,520 --> 02:12:40,940
это так.

2545
02:12:42,120 --> 02:12:43,100
А как под

2546
02:12:43,100 --> 02:12:45,400
System 5 вызывать

2547
02:12:45,400 --> 02:12:48,080
splitf, там, send, float, int, float?

2548
02:12:48,360 --> 02:12:49,240
Я же то, что сказал.

2549
02:12:50,180 --> 02:12:51,760
Первое, сочи себя, Гульен,

2550
02:12:51,980 --> 02:12:53,740
идет в r, d, i.

2551
02:12:54,900 --> 02:12:55,800
Второе, сочи себя,

2552
02:12:55,800 --> 02:12:57,820
в r, s, i.

2553
02:12:58,160 --> 02:12:59,540
Третье, сочи себя,

2554
02:12:59,760 --> 02:13:00,980
в r, d, x.

2555
02:13:01,760 --> 02:13:03,680
Первый, с плавающей точкой,

2556
02:13:03,840 --> 02:13:05,140
идет в x, n, 0.

2557
02:13:05,480 --> 02:13:08,320
Второе, с плавающей точкой, в x, n, 1.

2558
02:13:08,760 --> 02:13:10,160
И так, пока у вас не кончится

2559
02:13:10,160 --> 02:13:12,020
регистр. Когда регистры

2560
02:13:12,020 --> 02:13:13,720
кончились, то дальше

2561
02:13:13,720 --> 02:13:15,100
аргументы начинают

2562
02:13:15,100 --> 02:13:17,720
складываться на степ, в том

2563
02:13:17,720 --> 02:13:19,200
порядке, в котором

2564
02:13:19,200 --> 02:13:21,780
они у вас были

2565
02:13:21,980 --> 02:13:22,820
в аргументах.

2566
02:13:22,820 --> 02:13:24,200
И этот принтер, он

2567
02:13:24,200 --> 02:13:26,260
берет на себя ответственность,

2568
02:13:26,380 --> 02:13:28,920
какой регистр, в пользу какой.

2569
02:13:29,020 --> 02:13:30,620
Да. Почему и

2570
02:13:30,620 --> 02:13:31,520
важно

2571
02:13:31,520 --> 02:13:35,260
правильно указывать

2572
02:13:35,260 --> 02:13:36,520
в строке формата

2573
02:13:36,520 --> 02:13:38,640
вот процентик тип

2574
02:13:38,640 --> 02:13:40,040
и тип аргумента.

2575
02:13:41,100 --> 02:13:42,260
В традиционно убитом мире

2576
02:13:42,260 --> 02:13:43,200
вы можете

2577
02:13:43,200 --> 02:13:45,980
это соглашение

2578
02:13:45,980 --> 02:13:48,460
могло нарушать. Например, вы можете

2579
02:13:48,460 --> 02:13:50,480
сказать, я хочу напечатать

2580
02:13:50,480 --> 02:13:51,720
процентик,

2581
02:13:51,980 --> 02:13:55,060
ум, целое число без знаков,

2582
02:13:55,060 --> 02:13:57,060
и отдать туда флот.

2583
02:13:57,060 --> 02:14:00,060
И оно вам напечатает

2584
02:14:00,060 --> 02:14:02,060
представление флота,

2585
02:14:02,060 --> 02:14:04,060
как вот оно по битикам,

2586
02:14:04,060 --> 02:14:06,060
так сказать, по этикам

2587
02:14:06,060 --> 02:14:08,060
состоит.

2588
02:14:08,060 --> 02:14:10,060
В существенном убитом мире,

2589
02:14:10,060 --> 02:14:12,060
если вы такое сделаете,

2590
02:14:12,060 --> 02:14:14,060
вы получите мусор.

2591
02:14:14,060 --> 02:14:16,060
Потому что, когда

2592
02:14:16,060 --> 02:14:18,060
вы сказали, что у вас

2593
02:14:18,060 --> 02:14:20,060
аргумент сочисленный,

2594
02:14:20,060 --> 02:14:21,820
он будет искаться в целочисленном,

2595
02:14:21,820 --> 02:14:23,820
в разночисленном месте.

2596
02:14:23,820 --> 02:14:25,820
А если аргумент с плавающей точкой,

2597
02:14:25,820 --> 02:14:27,820
он будет искаться в месте

2598
02:14:27,820 --> 02:14:29,820
плавающей точки.

2599
02:14:29,820 --> 02:14:31,820
И под виндой

2600
02:14:31,820 --> 02:14:33,820
все, что вы получите, вы получите просто

2601
02:14:33,820 --> 02:14:35,820
мусор в этом месте, но у вас

2602
02:14:35,820 --> 02:14:37,820
ничего не сломается.

2603
02:14:37,820 --> 02:14:39,820
А под линуксом

2604
02:14:39,820 --> 02:14:41,820
у вас не просто будет мусор,

2605
02:14:41,820 --> 02:14:43,820
у вас еще все остальные аргументы

2606
02:14:43,820 --> 02:14:45,820
могут поехать.

2607
02:14:51,820 --> 02:14:53,820
И все остальные аргументы могут

2608
02:14:53,820 --> 02:14:55,820
появиться с отключением этого.

2609
02:14:55,820 --> 02:14:57,820
То, что...

2610
02:14:57,820 --> 02:14:59,820
Ну, есть флаг, как это называется.

2611
02:14:59,820 --> 02:15:01,820
Ну, вот.

2612
02:15:01,820 --> 02:15:03,820
Игре, значит, такого вам

2613
02:15:03,820 --> 02:15:05,820
не обещают.

2614
02:15:05,820 --> 02:15:07,820
Да.

2615
02:15:07,820 --> 02:15:09,820
Но вот

2616
02:15:09,820 --> 02:15:11,820
юзерстрейс...

2617
02:15:11,820 --> 02:15:13,820
Вообще, мы с вами в курсе про юзерстрейс.

2618
02:15:13,820 --> 02:15:15,820
Потому что

2619
02:15:15,820 --> 02:15:17,820
ядро — это отдельная история.

2620
02:15:17,820 --> 02:15:19,820
И ядро — это, честно говоря,

2621
02:15:19,820 --> 02:15:21,820
даже больше курса операционного, чем

2622
02:15:21,820 --> 02:15:23,820
смартфон.

2623
02:15:23,820 --> 02:15:25,820
То есть, я думаю,

2624
02:15:25,820 --> 02:15:27,820
может, это не будет прикольно,

2625
02:15:27,820 --> 02:15:29,820
но это специализировано

2626
02:15:29,820 --> 02:15:31,820
не совсем то,

2627
02:15:31,820 --> 02:15:33,820
чем мы занимаемся.

2628
02:15:33,820 --> 02:15:35,820
— Можете еще раз кратко повторить,

2629
02:15:35,820 --> 02:15:37,820
для чего вам нужно указывать

2630
02:15:37,820 --> 02:15:39,820
количество флотов, аргументов,

2631
02:15:39,820 --> 02:15:41,820
плеера и икс?

2632
02:15:41,820 --> 02:15:43,820
— Требуется по конвенции.

2633
02:15:43,820 --> 02:15:45,820
Конвенция требует, чтобы это было сделано.

2634
02:15:45,820 --> 02:15:47,820
Если этого не сделаешь,

2635
02:15:47,820 --> 02:15:49,820
у тебя принт реально покрапшет.

2636
02:15:49,820 --> 02:15:51,820
— Еще. Для чего нужен

2637
02:15:51,820 --> 02:15:53,820
R-flags?

2638
02:15:53,820 --> 02:15:55,820
— R-flags — это регистр флагов,

2639
02:15:55,820 --> 02:15:57,820
который теперь называется R,

2640
02:15:57,820 --> 02:15:59,820
потому что он стал

2641
02:15:59,820 --> 02:16:01,820
64-битным вместе со всеми остальными

2642
02:16:01,820 --> 02:16:03,820
эписками.

2643
02:16:03,820 --> 02:16:05,820
Да, но содержательные эпитеты у него

2644
02:16:05,820 --> 02:16:07,820
находятся все равно в нашей части,

2645
02:16:07,820 --> 02:16:09,820
как были, так и остались.

2646
02:16:09,820 --> 02:16:11,820
То есть флаги переноса, нуля

2647
02:16:11,820 --> 02:16:13,820
и подобное —

2648
02:16:13,820 --> 02:16:15,820
все они остались, по-прежнему

2649
02:16:15,820 --> 02:16:17,820
так же работают.

2650
02:16:17,820 --> 02:16:19,820
Просто регистр, как и все остальные,

2651
02:16:19,820 --> 02:16:21,820
теперь 64-битный.

2652
02:16:21,820 --> 02:16:23,820
— Пойдем.

2653
02:16:23,820 --> 02:16:25,820
— Просто про функции.

2654
02:16:25,820 --> 02:16:27,820
Какая функция принимает

2655
02:16:27,820 --> 02:16:29,820
флаговый инк и флот?

2656
02:16:29,820 --> 02:16:31,820
И если нам нужно передать в неправильном порядке,

2657
02:16:31,820 --> 02:16:33,820
то нам, в данном случае,

2658
02:16:33,820 --> 02:16:35,820
нужно представление флота и флот.

2659
02:16:35,820 --> 02:16:37,820
Ну, может быть, инк — специальный флот.

2660
02:16:37,820 --> 02:16:39,820
Ну, вместе с в.

2661
02:16:39,820 --> 02:16:41,820
Потому что, посмотрите, R-дай и

2662
02:16:41,820 --> 02:16:43,820
в основном ноль. — Нет, нет, нет.

2663
02:16:43,820 --> 02:16:45,820
Смотри, еще раз.

2664
02:16:45,820 --> 02:16:47,820
Если передать их в неправильном порядке,

2665
02:16:47,820 --> 02:16:49,820
то

2666
02:16:49,820 --> 02:16:51,820
сис-пайк

2667
02:16:51,820 --> 02:16:53,820
просто об этом

2668
02:16:53,820 --> 02:16:55,820
не узнает.

2669
02:16:55,820 --> 02:16:57,820
Он даже правильно будет

2670
02:16:57,820 --> 02:16:59,820
интерпретировать.

2671
02:16:59,820 --> 02:17:01,820
Нет, здесь не будет им представления делать.

2672
02:17:01,820 --> 02:17:03,820
Еще раз.

2673
02:17:03,820 --> 02:17:05,820
У тебя целочисленный

2674
02:17:05,820 --> 02:17:07,820
аргумент отправляется

2675
02:17:07,820 --> 02:17:09,820
в R-дай и

2676
02:17:09,820 --> 02:17:11,820
плавающая точка в xml.

2677
02:17:15,820 --> 02:17:17,820
То есть у тебя оно будет смотреть

2678
02:17:17,820 --> 02:17:19,820
вот в это место или в это место

2679
02:17:19,820 --> 02:17:21,820
в зависимости от

2680
02:17:21,820 --> 02:17:23,820
типа данных.

2681
02:17:23,820 --> 02:17:25,820
Да.

2682
02:17:25,820 --> 02:17:27,820
— Во-первых,

2683
02:17:29,820 --> 02:17:31,820
какая структура?

2684
02:17:31,820 --> 02:17:33,820
Они передаются в регистр?

2685
02:17:33,820 --> 02:17:35,820
— Еще раз.

2686
02:17:35,820 --> 02:17:37,820
С структурами там

2687
02:17:37,820 --> 02:17:39,820
темная история. Зависит от

2688
02:17:39,820 --> 02:17:41,820
размера структуры.

2689
02:17:41,820 --> 02:17:43,820
Если структуры маленькие,

2690
02:17:43,820 --> 02:17:45,820
которые уменьшаются

2691
02:17:45,820 --> 02:17:47,820
в регистре, они могут быть

2692
02:17:47,820 --> 02:17:49,820
переданы в регистр.

2693
02:17:49,820 --> 02:17:51,820
Если они в регистр не лезут,

2694
02:17:51,820 --> 02:17:53,820
они будут переданы на стеки.

2695
02:17:53,820 --> 02:17:55,820
Вот сколько там местных занимает.

2696
02:17:55,820 --> 02:17:57,820
И там тоже

2697
02:17:57,820 --> 02:17:59,820
разные хитрые штуки.

2698
02:17:59,820 --> 02:18:01,820
Если у тебя, скажем, второй аргумент

2699
02:18:01,820 --> 02:18:03,820
это вот большая структура,

2700
02:18:03,820 --> 02:18:05,820
которая в регистре не лезет.

2701
02:18:05,820 --> 02:18:07,820
Я, честно говоря, не помню, что там происходит,

2702
02:18:07,820 --> 02:18:09,820
но что-то дикое.

2703
02:18:11,820 --> 02:18:13,820
Может быть, указатель, да.

2704
02:18:13,820 --> 02:18:15,820
То есть

2705
02:18:15,820 --> 02:18:17,820
там что-то заморочено.

2706
02:18:17,820 --> 02:18:19,820
Но структуры может

2707
02:18:19,820 --> 02:18:21,820
сама целиком находиться, если это на стеке.

2708
02:18:21,820 --> 02:18:23,820
Не через регистр идет,

2709
02:18:23,820 --> 02:18:25,820
а просто, как говорится, функцию.

2710
02:18:25,820 --> 02:18:27,820
Скажем, 32 бита.

2711
02:18:27,820 --> 02:18:29,820
Оказывается, это структура.

2712
02:18:29,820 --> 02:18:31,820
Эта структура просто лезет на стеке.

2713
02:18:33,820 --> 02:18:35,820
— Еще в чем смысл зоны, если

2714
02:18:35,820 --> 02:18:37,820
функция, если нужны какие-то

2715
02:18:37,820 --> 02:18:39,820
переменные?

2716
02:18:39,820 --> 02:18:41,820
— В смысле в том, что если тебе нужно сохранять

2717
02:18:41,820 --> 02:18:43,820
меньше 128 байт

2718
02:18:43,820 --> 02:18:45,820
данных,

2719
02:18:45,820 --> 02:18:47,820
то ты можешь просто не трогать стекпоинт.

2720
02:18:49,820 --> 02:18:51,820
Такая мелкая оптимизация, что

2721
02:18:51,820 --> 02:18:53,820
стекпоинтер можете не опускать

2722
02:18:53,820 --> 02:18:55,820
и не возвращать на место.

2723
02:18:55,820 --> 02:18:57,820
— Все же, условно,

2724
02:18:57,820 --> 02:18:59,820
один раз опускается стекпоинтер,

2725
02:18:59,820 --> 02:19:01,820
и все параметры...

2726
02:19:01,820 --> 02:19:03,820
— А так ты можешь ноль раз

2727
02:19:03,820 --> 02:19:05,820
опускать стекпоинтер.

2728
02:19:05,820 --> 02:19:07,820
Если размер

2729
02:19:07,820 --> 02:19:09,820
всех твоих локальных

2730
02:19:09,820 --> 02:19:11,820
переменных не превышает

2731
02:19:11,820 --> 02:19:13,820
128 байт,

2732
02:19:13,820 --> 02:19:15,820
то ты стекпоинтер можешь

2733
02:19:15,820 --> 02:19:17,820
не опускать.

2734
02:19:17,820 --> 02:19:19,820
— И насколько сильно это оптимизирует?

2735
02:19:19,820 --> 02:19:21,820
— На одну команду.

2736
02:19:21,820 --> 02:19:23,820
— На две команды.

2737
02:19:25,820 --> 02:19:27,820
— Не допускаем записку на поднимающие.

2738
02:19:27,820 --> 02:19:29,820
— Да.

2739
02:19:29,820 --> 02:19:31,820
То есть вот такая просто

2740
02:19:31,820 --> 02:19:33,820
особенность.

2741
02:19:33,820 --> 02:19:35,820
Как сделать это?

2742
02:19:35,820 --> 02:19:37,820
Ты можешь

2743
02:19:37,820 --> 02:19:39,820
пользоваться этим, можешь не пользоваться.

2744
02:19:41,820 --> 02:19:43,820
Тебя никто

2745
02:19:43,820 --> 02:19:45,820
не заставляет использовать

2746
02:19:45,820 --> 02:19:47,820
эту Redzone.

2747
02:19:47,820 --> 02:19:49,820
Но если хочешь, ты можешь

2748
02:19:49,820 --> 02:19:51,820
использовать эту фичу.

2749
02:19:51,820 --> 02:19:53,820
Shadow Space — это более

2750
02:19:53,820 --> 02:19:55,820
взрослая штука. Вы должны

2751
02:19:55,820 --> 02:19:57,820
ее выделять, когда кого-то

2752
02:19:57,820 --> 02:19:59,820
вызываете. Не выделите —

2753
02:19:59,820 --> 02:20:01,820
он попортит вам стек.

2754
02:20:01,820 --> 02:20:03,820
А Redzone,

2755
02:20:03,820 --> 02:20:05,820
так как это ниже стекпоинтера,

2756
02:20:05,820 --> 02:20:07,820
то это заморочки операционной

2757
02:20:07,820 --> 02:20:09,820
системы, а не вас.

2758
02:20:09,820 --> 02:20:11,820
А для вас это чистый фича.

2759
02:20:11,820 --> 02:20:13,820
Не хотите — не пользуйтесь.

2760
02:20:13,820 --> 02:20:15,820
— То есть

2761
02:20:15,820 --> 02:20:17,820
в случае с Redzone,

2762
02:20:17,820 --> 02:20:19,820
я вам не буду выделять.

2763
02:20:19,820 --> 02:20:21,820
Сейчас.

2764
02:20:21,820 --> 02:20:23,820
В случае с Redzone

2765
02:20:23,820 --> 02:20:25,820
ты можешь

2766
02:20:25,820 --> 02:20:27,820
писать и ниже стекпоинтера

2767
02:20:27,820 --> 02:20:29,820
на 128 байт.

2768
02:20:29,820 --> 02:20:31,820
А в случае

2769
02:20:31,820 --> 02:20:33,820
с Shadow Space я

2770
02:20:33,820 --> 02:20:35,820
как пользователь...

2771
02:20:35,820 --> 02:20:37,820
— У тебя есть просто выше адреса

2772
02:20:37,820 --> 02:20:39,820
возврата, у тебя есть 32 байтика, которые

2773
02:20:39,820 --> 02:20:41,820
тоже вот тебе дают.

2774
02:20:43,820 --> 02:20:45,820
То есть Redzone тебе дает данные ниже

2775
02:20:45,820 --> 02:20:47,820
стекпоинтера, а Shadow Space

2776
02:20:47,820 --> 02:20:49,820
дает тебе место

2777
02:20:49,820 --> 02:20:51,820
выше адреса возврата.

2778
02:20:55,820 --> 02:20:57,820
— А стек

2779
02:20:57,820 --> 02:20:59,820
как портится в случае с Shadow Space?

2780
02:20:59,820 --> 02:21:01,820
— Никак не портится.

2781
02:21:01,820 --> 02:21:03,820
Даже он только что нарисовал

2782
02:21:03,820 --> 02:21:05,820
Shadow Space.

2783
02:21:05,820 --> 02:21:07,820
— Да, ладно.

2784
02:21:07,820 --> 02:21:09,820
Вы рассказывали историю, как...

2785
02:21:09,820 --> 02:21:11,820
— Я не

2786
02:21:11,820 --> 02:21:13,820
довыделил Shadow Space.

2787
02:21:13,820 --> 02:21:15,820
Я дал Shadow Space не 32 байтика,

2788
02:21:15,820 --> 02:21:17,820
а 8.

2789
02:21:17,820 --> 02:21:19,820
— Но это вы как пользователь, который

2790
02:21:19,820 --> 02:21:21,820
пишет программу.

2791
02:21:21,820 --> 02:21:23,820
— Как тот, который вызывает

2792
02:21:23,820 --> 02:21:25,820
функцию.

2793
02:21:25,820 --> 02:21:27,820
Я обратил

2794
02:21:27,820 --> 02:21:29,820
внимание, что Shadow Space

2795
02:21:29,820 --> 02:21:31,820
всегда, если нормально,

2796
02:21:31,820 --> 02:21:33,820
оно не привязано к размеру аргументов.

2797
02:21:35,820 --> 02:21:37,820
Исходно кажется,

2798
02:21:37,820 --> 02:21:39,820
если вы понимаете, зачем это сделано,

2799
02:21:39,820 --> 02:21:41,820
что оно должно соответствовать

2800
02:21:41,820 --> 02:21:43,820
аргументам, чтобы они

2801
02:21:43,820 --> 02:21:45,820
могли быть сброшены в степ.

2802
02:21:45,820 --> 02:21:47,820
Но оно,

2803
02:21:47,820 --> 02:21:49,820
как бы,

2804
02:21:49,820 --> 02:21:51,820
хоть для этого было спроектировано,

2805
02:21:51,820 --> 02:21:53,820
постулировано оно было не так.

2806
02:21:53,820 --> 02:21:55,820
Постулировано, что любая функция

2807
02:21:55,820 --> 02:21:57,820
получается 32 байтика.

2808
02:21:57,820 --> 02:21:59,820
Ну и здесь

2809
02:21:59,820 --> 02:22:01,820
в некотором смысле аналогично

2810
02:22:01,820 --> 02:22:03,820
постулировано, что

2811
02:22:03,820 --> 02:22:05,820
любая функция

2812
02:22:05,820 --> 02:22:07,820
получает вот этот Red Zone.

2813
02:22:07,820 --> 02:22:09,820
Но обратите внимание,

2814
02:22:09,820 --> 02:22:11,820
что Red Zone

2815
02:22:11,820 --> 02:22:13,820
полезна только

2816
02:22:13,820 --> 02:22:15,820
листовым функциям.

2817
02:22:15,820 --> 02:22:17,820
Если вы

2818
02:22:17,820 --> 02:22:19,820
кого-то вызываете,

2819
02:22:19,820 --> 02:22:21,820
то никакой Red Zone

2820
02:22:21,820 --> 02:22:23,820
у вас нет.

2821
02:22:23,820 --> 02:22:25,820
— У нас есть Red Zone,

2822
02:22:25,820 --> 02:22:27,820
я перед вызовом функции

2823
02:22:27,820 --> 02:22:29,820
ее поиспользую,

2824
02:22:29,820 --> 02:22:31,820
потом с длинной степ-поинтера вызову функцию.

2825
02:22:31,820 --> 02:22:33,820
— Да, но зачем тебе так делать,

2826
02:22:33,820 --> 02:22:35,820
когда ты можешь просто сразу

2827
02:22:35,820 --> 02:22:37,820
с длинной степ-поинтера?

2828
02:22:37,820 --> 02:22:39,820
— Ну да, мы просто к тому,

2829
02:22:39,820 --> 02:22:41,820
что если ты все равно собрал

2830
02:22:41,820 --> 02:22:43,820
с длинной степ-поинтер,

2831
02:22:43,820 --> 02:22:45,820
то ты можешь убрать.

2832
02:22:47,820 --> 02:22:49,820
Ну, насколько ты хочешь

2833
02:22:49,820 --> 02:22:51,820
настолько оптимизировать —

2834
02:22:51,820 --> 02:22:53,820
вопрос.

2835
02:22:53,820 --> 02:22:55,820
Обычно

2836
02:22:55,820 --> 02:22:57,820
не очень с этим

2837
02:22:57,820 --> 02:22:59,820
заморачиваются.

2838
02:22:59,820 --> 02:23:01,820
Бывает, конечно, что компиляторы

2839
02:23:01,820 --> 02:23:03,820
специальным образом обрабатывают

2840
02:23:03,820 --> 02:23:05,820
парочку начальных ифов.

2841
02:23:05,820 --> 02:23:07,820
Например, если ваша функция

2842
02:23:07,820 --> 02:23:09,820
начинается с иф какой-то аргумент

2843
02:23:09,820 --> 02:23:11,820
меньше нуля, тогда летел

2844
02:23:11,820 --> 02:23:13,820
какой-нибудь код возврата.

2845
02:23:13,820 --> 02:23:15,820
Вот такие ифы бывают,

2846
02:23:15,820 --> 02:23:17,820
что компиляторы ставят

2847
02:23:17,820 --> 02:23:19,820
очень рано,

2848
02:23:19,820 --> 02:23:21,820
раньше, чем стек-фрейм

2849
02:23:21,820 --> 02:23:23,820
вообще создается.

2850
02:23:23,820 --> 02:23:25,820
Но такое бывает не очень часто.

2851
02:23:25,820 --> 02:23:27,820
Как правило, функция начинается

2852
02:23:27,820 --> 02:23:29,820
с пролога, который

2853
02:23:29,820 --> 02:23:31,820
сохраняет регистры,

2854
02:23:31,820 --> 02:23:33,820
двигает стек-поинтер,

2855
02:23:33,820 --> 02:23:35,820
потом целая функция,

2856
02:23:35,820 --> 02:23:37,820
и в конце — эпилог,

2857
02:23:37,820 --> 02:23:39,820
который возвращается обратно.

2858
02:23:39,820 --> 02:23:41,820
— Ого!

2859
02:23:41,820 --> 02:23:45,820
Ну и на этом

2860
02:23:45,820 --> 02:23:47,820
про 64-битные

2861
02:23:47,820 --> 02:23:49,820
особенности, наверное,

2862
02:23:49,820 --> 02:23:51,820
все.

2863
02:23:51,820 --> 02:23:53,820
Еще есть замечание.

2864
02:23:53,820 --> 02:23:55,820
Вспоминаем, что под виндой

2865
02:23:55,820 --> 02:23:57,820
глобальные имена, они требовали

2866
02:23:57,820 --> 02:23:59,820
добавления начальных подчеркиваний.

2867
02:23:59,820 --> 02:24:01,820
Я вам говорил, это можно решить

2868
02:24:01,820 --> 02:24:03,820
просто ключиком.

2869
02:24:03,820 --> 02:24:05,820
Для нас —

2870
02:24:05,820 --> 02:24:07,820
подчеркивание в начале.

2871
02:24:07,820 --> 02:24:09,820
Под 64-битыми

2872
02:24:09,820 --> 02:24:11,820
никаких подчеркиваний,

2873
02:24:11,820 --> 02:24:13,820
потому что имена называются

2874
02:24:13,820 --> 02:24:15,820
вот как они есть, так и называются.

2875
02:24:15,820 --> 02:24:17,820
То есть это ключик

2876
02:24:17,820 --> 02:24:19,820
для добавления подчеркивания

2877
02:24:19,820 --> 02:24:21,820
в 64-битном мире под виндой

2878
02:24:21,820 --> 02:24:23,820
не нужен. Ваше название

2879
02:24:23,820 --> 02:24:25,820
один к одному, да.

2880
02:24:25,820 --> 02:24:27,820
— А 2D-тесты будут на винде?

2881
02:24:27,820 --> 02:24:29,820
— Там будет сказано.

2882
02:24:29,820 --> 02:24:31,820
Ну, фактически да. Там будет сказано,

2883
02:24:31,820 --> 02:24:33,820
какую коньянку использовать.

2884
02:24:33,820 --> 02:24:35,820
И, честно говоря, там

2885
02:24:35,820 --> 02:24:37,820
коньянки будет мало,

2886
02:24:37,820 --> 02:24:39,820
поэтому даже если вы пишете

2887
02:24:39,820 --> 02:24:41,820
некую другую... — А все можно

2888
02:24:41,820 --> 02:24:43,820
вызывать функцию там.

2889
02:24:43,820 --> 02:24:45,820
— Смотри, обычный

2890
02:24:45,820 --> 02:24:47,820
обычный

2891
02:24:47,820 --> 02:24:49,820
указатель конвенции —

2892
02:24:49,820 --> 02:24:51,820
это вот ситекл,

2893
02:24:51,820 --> 02:24:53,820
и так далее, да. Вот они,

2894
02:24:53,820 --> 02:24:55,820
как я уже сказал, влияют

2895
02:24:55,820 --> 02:24:57,820
только на 32 бита.

2896
02:24:57,820 --> 02:24:59,820
— А-а. — В 64-битном мире

2897
02:24:59,820 --> 02:25:01,820
на писательных мультиках

2898
02:25:01,820 --> 02:25:03,820
оно

2899
02:25:03,820 --> 02:25:05,820
скомпилируется, но компилятор

2900
02:25:05,820 --> 02:25:07,820
их проинновирует.

2901
02:25:07,820 --> 02:25:09,820
— А-а.

2902
02:25:09,820 --> 02:25:11,820
— Нет, в смысле,

2903
02:25:11,820 --> 02:25:13,820
компилятор их все так использует?

2904
02:25:13,820 --> 02:25:15,820
— Нет. Это

2905
02:25:15,820 --> 02:25:17,820
зависит от того, какой у вас

2906
02:25:17,820 --> 02:25:19,820
таргет,

2907
02:25:19,820 --> 02:25:21,820
под какую операционку

2908
02:25:21,820 --> 02:25:23,820
вы компилируетесь.

2909
02:25:23,820 --> 02:25:25,820
У компилятора есть таргет.

2910
02:25:25,820 --> 02:25:27,820
Если ничего не указывается,

2911
02:25:27,820 --> 02:25:29,820
то таргет — это ваша текущая

2912
02:25:29,820 --> 02:25:31,820
операционка.

2913
02:25:31,820 --> 02:25:33,820
Ну, а если компилятор

2914
02:25:33,820 --> 02:25:35,820
имеет кросс-компилированный, например,

2915
02:25:35,820 --> 02:25:37,820
слабый, то ты можешь

2916
02:25:37,820 --> 02:25:39,820
указать ему специальные ключи,

2917
02:25:39,820 --> 02:25:41,820
и тогда

2918
02:25:41,820 --> 02:25:43,820
он будет строить код

2919
02:25:43,820 --> 02:25:45,820
по правилам вот той системы,

2920
02:25:45,820 --> 02:25:47,820
под которую ты сказал,

2921
02:25:47,820 --> 02:25:49,820
какой у тебя таргет.

2922
02:25:51,820 --> 02:25:53,820
И, если говорить

2923
02:25:53,820 --> 02:25:55,820
про вот x86

2924
02:25:55,820 --> 02:25:57,820
и фланг, я знаю, что

2925
02:25:57,820 --> 02:25:59,820
у него есть магический

2926
02:25:59,820 --> 02:26:01,820
атрибут,

2927
02:26:01,820 --> 02:26:03,820
который вы можете поставить

2928
02:26:03,820 --> 02:26:05,820
на функцию через

2929
02:26:05,820 --> 02:26:07,820
два подчеркивания атрибута,

2930
02:26:07,820 --> 02:26:09,820
два подчеркивания

2931
02:26:09,820 --> 02:26:11,820
и вы можете

2932
02:26:11,820 --> 02:26:13,820
вот этим атрибутом

2933
02:26:13,820 --> 02:26:15,820
переключить

2934
02:26:15,820 --> 02:26:17,820
конвенцию вызова

2935
02:26:17,820 --> 02:26:19,820
конкретной функции

2936
02:26:19,820 --> 02:26:21,820
вот на другую.

2937
02:26:27,820 --> 02:26:29,820
Если вы можете сказать

2938
02:26:29,820 --> 02:26:31,820
компилятору, я хочу, чтобы

2939
02:26:31,820 --> 02:26:33,820
ты вот эту функцию сгенерировал

2940
02:26:33,820 --> 02:26:35,820
в такой конвенции вызова.

2941
02:26:37,820 --> 02:26:39,820
И он даже правильно сделает

2942
02:26:39,820 --> 02:26:41,820
вызов этой функции

2943
02:26:41,820 --> 02:26:43,820
из другого места. Другое дело,

2944
02:26:43,820 --> 02:26:45,820
что это жизнеспособно

2945
02:26:45,820 --> 02:26:47,820
только вот внутри вас.

2946
02:26:47,820 --> 02:26:49,820
Потому что

2947
02:26:49,820 --> 02:26:51,820
все внешние функции,

2948
02:26:51,820 --> 02:26:53,820
они, конечно же,

2949
02:26:53,820 --> 02:26:55,820
имеют дефолтную конвенцию.

2950
02:27:07,820 --> 02:27:09,820
А почему длинная система?

2951
02:27:09,820 --> 02:27:11,820
Потому что

2952
02:27:11,820 --> 02:27:13,820
обычно нормальный код

2953
02:27:13,820 --> 02:27:15,820
напрямую не вызывает.

2954
02:27:15,820 --> 02:27:17,820
Нормальный код вызывает

2955
02:27:17,820 --> 02:27:19,820
системные библиотеки,

2956
02:27:19,820 --> 02:27:21,820
которые уже вызывают СИСКОЛы.

2957
02:27:21,820 --> 02:27:23,820
Прямые СИСКОЛы это,

2958
02:27:23,820 --> 02:27:25,820
честно говоря, большая редкость

2959
02:27:25,820 --> 02:27:27,820
нормальных кодов.

2960
02:27:27,820 --> 02:27:29,820
То есть не всякие системные защиты

2961
02:27:29,820 --> 02:27:31,820
и бла-бла-бла.

2962
02:27:31,820 --> 02:27:33,820
Поэтому

2963
02:27:33,820 --> 02:27:35,820
открыть ту же самую

2964
02:27:35,820 --> 02:27:37,820
DLL-ку, подвинуться,

2965
02:27:37,820 --> 02:27:39,820
загрузить код и исполнять,

2966
02:27:39,820 --> 02:27:41,820
и оно

2967
02:27:41,820 --> 02:27:43,820
полностью работает.

2968
02:27:43,820 --> 02:27:45,820
Точнее, что я убит,

2969
02:27:45,820 --> 02:27:47,820
у меня там есть некоторые сложности,

2970
02:27:47,820 --> 02:27:49,820
но они связаны

2971
02:27:49,820 --> 02:27:51,820
чуть-чуть другим.

2972
02:27:51,820 --> 02:27:53,820
Они связаны

2973
02:27:53,820 --> 02:27:55,820
с TLS.

