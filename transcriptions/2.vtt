WEBVTT

00:00.000 --> 00:18.720
намного. Но есть особенность. Память состоит из страничек, о чём вы, наверное, помните, но о них, конечно, поговорим более подробно, но позже.

00:18.720 --> 00:30.120
И вот, в связи с особенностями каждой такой конфликционной системы, они стараются выделять физическую память только по мере необходимости.

00:31.580 --> 00:41.120
То, что у вас выделено под стек, на самом деле оно, в прямом смысле этого слова, не выделено.

00:42.320 --> 00:47.840
Оно только зарезервировано. В смысле, диапазон адресов зарезервирован под стек.

00:47.840 --> 00:47.880
Так.

00:47.880 --> 00:51.880
А физической памяти туда не сопоставлено.

00:53.080 --> 00:55.900
И в камере линкарных работают.

00:57.080 --> 00:59.240
В зрении памяти происходит следующее.

00:59.640 --> 01:10.320
Когда вы обращаетесь на одну страничку ближе, чем последняя выделенная, то у вас происходит фетч-фолл.

01:11.320 --> 01:13.000
Управление получает система.

01:13.000 --> 01:17.000
Система видит, что это фетч-фолл на стеке, где...

01:17.880 --> 01:21.260
Место быть должно, но оно еще не выделено.

01:21.780 --> 01:26.340
Выделяет и опускает вот эту вот гард-страничку на одну нишу.

01:27.440 --> 01:30.080
В итоге выделение происходит по одной страничке.

01:30.960 --> 01:36.420
Поэтому, если вы опустите стек-поинтер там, например, на 10 килобайт,

01:38.420 --> 01:44.140
то это означает, что у вас есть реальные шансы пропустить эту гард-страничку.

01:44.140 --> 01:47.140
И если вы обратитесь по вот этому новому значению,

01:47.880 --> 01:51.880
ESP, которое на 10 килобайт ниже,

01:51.880 --> 01:59.880
вы можете просто перешагнуть страничку, по которой операционка определяет, что стек нужно расширить.

02:00.880 --> 02:04.880
Соответственно, при удалении памяти больше странички,

02:04.880 --> 02:12.880
на стеке следует пройтись по каждой страничке, то есть с шагом 4 килобайта,

02:12.880 --> 02:15.880
и просто ее потрогать как-нибудь.

02:15.880 --> 02:17.580
Прочитать оттуда байтик, закрепить,

02:17.580 --> 02:19.580
записать туда байтик, неважно.

02:19.580 --> 02:24.580
Ну вот, совершив какое-то действие с шагом 4 килобайта,

02:24.580 --> 02:28.580
что, да, начиная, конечно, сверху, сверху по прорисовке,

02:28.580 --> 02:35.580
то у вас не могла произойти ситуация, что стек вот такой вот не выделен.

02:39.580 --> 02:41.580
Вот такая ситуация.

02:41.580 --> 02:45.580
В принципе, в первой лаборатории вы на этом и снизу шли,

02:45.580 --> 02:50.580
потому что нифига вам больше 4 килобайта данных.

02:50.580 --> 02:52.580
И вообще не надо.

02:53.580 --> 03:00.580
Но в следующих лабораторных это может быть критично.

03:00.580 --> 03:02.580
Понятно?

03:02.580 --> 03:06.580
Сейчас, еще раз. А чем грозит, если не пощупать странички?

03:06.580 --> 03:09.580
Если не пощупать, то, еще раз, выделение происходит,

03:09.580 --> 03:14.580
когда происходит падение на карт странички, вот на которой сразу за концом,

03:15.580 --> 03:20.580
если ты обходишь ее и обращаешься в следующую страничку,

03:20.580 --> 03:25.580
то оно не обрабатывается специальным образом, и программа просто падает.

03:25.580 --> 03:29.580
Нет, а пока со стороны программы или со стороны рисунка?

03:29.580 --> 03:33.580
Ну, вообще со стороны программы, потому что операционка постулирует такое поведение,

03:33.580 --> 03:37.580
поэтому это как бы метод документации.

03:37.580 --> 03:43.580
Так что у нас было на архитектуре, кто помнит еще,

03:43.580 --> 03:49.580
вот это задокументированное поведение, поэтому, если вы так не делаете,

03:49.580 --> 03:51.580
то виноваты вы.

03:53.580 --> 03:55.580
Это про Винду, да, было?

03:55.580 --> 03:59.580
Ну, про Винду это точно, про другие операционки я не уверен.

03:59.580 --> 04:02.580
Правильно сказать, специальные операционки.

04:02.580 --> 04:08.580
То есть они тоже так же лениво выделяют память, это точно.

04:08.580 --> 04:12.580
Но вот такие особенности этого ленивого выделения памяти,

04:12.580 --> 04:16.580
я не могу вам сказать настолько подробно.

04:20.580 --> 04:26.580
Ну, про эти странички еще раз, у нас это будет, но там, в конце курса.

04:26.580 --> 04:33.580
Потому что это такая чистая теория, никакие факты на это не предполагаются.

04:33.580 --> 04:40.580
Поэтому пока, пока имеет смысл представлять что-то более полезное.

04:40.580 --> 04:45.580
И на самом деле, можно пойти в две стороны.

04:45.580 --> 04:53.580
Можно либо пойти в 64 бита, либо пойти в плавающую точку.

04:53.580 --> 04:56.580
Вот, что вам больше нравится.

04:56.580 --> 04:59.580
Плавающая точка.

04:59.580 --> 05:04.580
Все, я говорю, плавающая точка, кто хочет.

05:04.580 --> 05:08.580
Раз, два, три, четыре, пять.

05:08.580 --> 05:10.580
Четыре бита.

05:10.580 --> 05:13.580
Раз, два, три, четыре, пять.

05:13.580 --> 05:14.580
Серьезно?

05:14.580 --> 05:16.580
А, шесть.

05:16.580 --> 05:19.580
Ну, вы же поднимайте руки, я могу считать.

05:19.580 --> 05:22.580
Раз, два, три, четыре, пять.

05:22.580 --> 05:24.580
Пять.

05:24.580 --> 05:25.580
Половина.

05:25.580 --> 05:26.580
Ты куда?

05:26.580 --> 05:27.580
Половина.

05:27.580 --> 05:30.580
Ну, вот половина победила.

05:30.580 --> 05:33.580
Значит, мы идем в 64 бита.

05:33.580 --> 05:36.580
В принципе, через два будет шутка.

05:36.580 --> 05:43.580
В принципе, через два будет шутка идти более исторически правильно.

05:43.580 --> 05:49.580
А через 64 бита идти, наверное, более практически полезно.

05:49.580 --> 05:54.580
Потому что 64 бита – это текущее состояние.

05:54.580 --> 06:04.580
И тогда можно рассчитывать, например, что в следующей лаборатории вы можете делать 32 или 64 бита.

06:04.580 --> 06:05.580
По вашим условиям.

06:06.580 --> 06:09.580
И первая лабораторная – это 32 бита.

06:09.580 --> 06:10.580
Да.

06:10.580 --> 06:13.580
Первая лабораторная – это 132 бита.

06:13.580 --> 06:19.580
И конвенция вызова – 7.

06:19.580 --> 06:22.580
Итак, 64 бита – что это такое?

06:22.580 --> 06:28.580
Это очередное 100-тысячное расширение архитектуры ИЦ-86.

06:28.580 --> 06:34.580
Во-первых, мы еще раз вспоминаем, что ИЦ-86 от рождения была какой архитектурой?

06:34.580 --> 06:35.580
16 битой.

06:35.580 --> 06:36.580
16 битой, да.

06:36.580 --> 06:48.580
Потом в супердалекий атлас времена процессора И-80386 добавилось 32-битное расширение в режим работы,

06:48.580 --> 06:50.580
а режим это тоже, как говорится, почек,

06:50.580 --> 07:01.580
который позволил использовать 32-битные регистры, 32-битную арифметику и, самое главное, 32-битную адресацию.

07:01.580 --> 07:05.580
Вы очень счастливы, что не застали 16-битный мир.

07:05.580 --> 07:10.580
Адресация в 16-битном мире была полным адом.

07:10.580 --> 07:22.580
Немножко, что там происходило, мы рассмотрим тоже попозже, но, чтобы не наказать вашу плохую психику, мы это поверхностно рассмотрим.

07:22.580 --> 07:24.580
Это было реально больно.

07:24.580 --> 07:31.580
Так вот, 32-битный мир позволил адресацию сильно упростить.

07:31.580 --> 07:41.580
И вот то, что происходит сегодня, 64 битов, не так уж принципиально изменилось.

07:41.580 --> 07:46.580
То есть 16-32 битов был очень существенный переход.

07:46.580 --> 07:54.580
32-64 такой существенно менее крупный, заметный и так далее.

07:54.580 --> 07:56.580
Но отчасти почему?

07:56.580 --> 08:00.580
Отчасти потому, что уже было намного больше состав.

08:00.580 --> 08:11.580
И поэтому соображения об обратной совместимости, о упрощении, портировании и так далее, также были намного более сильны.

08:11.580 --> 08:19.580
Если при переходе 16-32 народ прям ломал всё подряд ради светлого будущего,

08:19.580 --> 08:26.580
то вот 32-64 уже ломали, честно говоря, меньше, чем нужно было бы поломать.

08:26.580 --> 08:28.580
И поэтому наше будущее местами страдает на самом деле.

08:28.580 --> 08:30.580
И поэтому наше будущее местами страдает на самом деле.

08:30.580 --> 08:40.580
Это от того, что, не знаю, конечно, не доломали, но можно было бы лучше.

08:40.580 --> 08:44.580
Итак, 64-битный режим.

08:44.580 --> 08:47.580
Это специальный режим работы процессора.

08:47.580 --> 08:54.580
И особенность его, что всякие расширения, которые добавили в 64-битный режим,

08:54.580 --> 08:58.580
их сумели заковырять через специальную форму кодирования,

08:58.580 --> 09:00.580
через специальные префиксы,

09:00.580 --> 09:04.920
которые вы можете поставить перед командами, и в 16-битный режим.

09:05.760 --> 09:12.960
То есть, если ваш процессор умеет 32 бита, то 32-битные регистры и так далее

09:12.960 --> 09:16.980
доступны вам даже из 16-битного режима.

09:16.980 --> 09:32.280
Более того, честно говоря, внутри команды вида ADD, EAX, ECX и ADD, AX, CX

09:32.280 --> 09:38.540
это одна и та же команда, один и тот же код, и отличаются они только тем,

09:39.100 --> 09:44.260
что в каком режиме вы интерпретируете этот код.

09:44.260 --> 09:46.260
Если процессор работает...

09:46.980 --> 09:51.320
В 32-битном режиме, то он интерпретирует как EAX.

09:51.900 --> 09:55.500
Если в 16-битном режиме, то он интерпретирует как AX.

09:57.200 --> 10:03.380
И у вас есть специальный байтик, префикс изменения битности данных,

10:04.560 --> 10:09.560
который позволяет переключить на противоположную интерпретацию.

10:11.560 --> 10:15.720
Ну да, противоположная интерпретация.

10:16.140 --> 10:16.560
Поэтому...

10:16.980 --> 10:21.440
Когда вы пишете команду ADD, AX, CX в 32-битном режиме,

10:21.760 --> 10:26.800
она навалит длиннее, чем команда ADD, EAX, ECX.

10:27.860 --> 10:31.120
Но содержит тот же самый код, просто дополнительный префикс,

10:31.540 --> 10:34.080
что мы переключаемся в 16-битный режим.

10:34.640 --> 10:39.860
То есть 32-битное расширение, оно было добавлено вот так вот фактически везде.

10:40.720 --> 10:44.740
Через дополнительный префикс вы оказываетесь вот в противоположной битности.

10:45.540 --> 10:46.740
В 64-битном режиме...

10:46.980 --> 10:48.980
То есть 32-битное расширение, оно не такое.

10:49.980 --> 10:54.980
Вот так вот просто взять и добавить префикс, к сожалению, там уже набор...

10:55.980 --> 11:01.980
Это префикс вашей следующей команды в 16-битном режиме или префикс вашей следующей команды в 16-битном режиме?

11:02.980 --> 11:03.980
Нет, это именно на одну команду есть.

11:04.980 --> 11:09.980
То есть это как будто расширение кода команды.

11:10.980 --> 11:12.980
Это не переключение режима процесса.

11:13.980 --> 11:15.980
Это переключение интерпретации вот одной команды.

11:16.980 --> 11:17.980
Это не переключение этой команды.

11:18.980 --> 11:19.980
Да.

11:20.980 --> 11:22.980
То есть в другом режиме это тоже надо использовать?

11:23.980 --> 11:26.980
То есть еще раз, если ты хочешь команду ADD AXCX,

11:27.980 --> 11:31.980
то единственный способ ее закодировать, это использовать ADD.

11:32.980 --> 11:37.980
То есть это одна и та же команда с точки зрения кода.

11:38.980 --> 11:43.980
А интерпретация этого кода зависит а от режима работы процессора,

11:43.980 --> 11:48.980
б от наличия префикса переключения битности данных.

11:49.980 --> 11:52.980
То есть в 16-битном режиме вы можете переключить битность данных?

11:53.980 --> 11:54.980
Да.

11:55.980 --> 11:57.980
То есть если вы захотите проверить цель...

11:58.980 --> 12:01.980
8-битные регистры имеют свой собственный код,

12:02.980 --> 12:06.980
и они этим префиксом изменения битности не управляют.

12:07.980 --> 12:12.980
То есть вы можете добавить этот префикс, но он ничего не сделает с этой командой.

12:13.980 --> 12:17.980
Этот префикс переключает вам 16 или 32 бит.

12:18.980 --> 12:22.980
Если команда не использует 16 или 32 бит,

12:23.980 --> 12:26.980
то тогда этот префикс делает ничего.

12:29.980 --> 12:31.980
Большинство вот этих вот физических префиксов,

12:32.980 --> 12:37.980
они безобидны в плане того, что если вы ставите их в команду,

12:38.980 --> 12:42.980
которая неосмысленно взаимодействует с этим префиксом,

12:43.980 --> 12:45.980
то из-за этого ничего не происходит.

12:46.980 --> 12:50.980
Не все префиксы безобидны, но большинство вот так сидит.

12:52.980 --> 13:00.980
Окей. Будет ли вот команда x и x добавить префикс 67, 66 и дальше выход команды?

13:01.980 --> 13:02.980
Еще раз.

13:03.980 --> 13:05.980
То, что вы говорите, это префикс?

13:06.980 --> 13:07.980
66.

13:08.980 --> 13:10.980
А для адресов из плюсов 67?

13:11.980 --> 13:12.980
Да.

13:12.980 --> 13:13.980
Для команды вот этого надо.

13:14.980 --> 13:15.980
С регистрации давай 66.

13:16.980 --> 13:17.980
Ну, 67, 66.

13:18.980 --> 13:19.980
То есть даже два байта.

13:20.980 --> 13:21.980
А оно проразное?

13:22.980 --> 13:23.980
Другого не включают?

13:24.980 --> 13:28.980
Ну да, здесь как бы хотел опустить.

13:29.980 --> 13:31.980
На самом деле, с адресацией даже самое интересное,

13:32.980 --> 13:33.980
если команда обращается к памяти,

13:34.980 --> 13:36.980
у вас есть такой 16-битный режим адресации

13:37.980 --> 13:39.980
и 30-битный режим адресации.

13:39.980 --> 13:44.980
И опять-таки используется дефолт соответствующей битности,

13:45.980 --> 13:49.980
и вы можете при помощи другого префикса переключить,

13:50.980 --> 13:52.980
какого вида у вас адресация в команде.

13:53.980 --> 13:57.980
Адресация через вот 16-битный способ или адресация через 30-битный.

13:58.980 --> 13:59.980
Префикс кодировки.

14:00.980 --> 14:02.980
Префикс изменения битности адреса.

14:03.980 --> 14:04.980
Кодировки.

14:05.980 --> 14:06.980
В смысле?

14:06.980 --> 14:08.980
Еще раз, у нас здесь команда, она как-то закодирована.

14:09.980 --> 14:10.980
Да.

14:11.980 --> 14:13.980
Префикс, он как бы считается частью кода команды.

14:14.980 --> 14:15.980
Да, да, вот я правильно.

14:16.980 --> 14:17.980
А если у нас есть ADD формы,

14:18.980 --> 14:19.980
когда у нас одно слагаемое,

14:20.980 --> 14:21.980
и там появление определенного регистратора,

14:22.980 --> 14:23.980
однобайтное ADD?

14:24.980 --> 14:26.980
Ты что, про IELTS, ICH?

14:27.980 --> 14:32.980
Нет, нет, имеется в виду однобайтная длина команды 1 байт.

14:33.980 --> 14:34.980
Ну и что?

14:34.980 --> 14:35.980
Имеет один оперант, ADD.

14:36.980 --> 14:38.980
И она этот оперант прибавляет и не помнит какой-то регистр.

14:39.980 --> 14:40.980
По-моему, в IELTS всегда.

14:41.980 --> 14:44.980
Ну это типа как оптимизация, что мы в основном какой-то регистр часто что-то прибавляем,

14:45.980 --> 14:46.980
и мы хотим закодировать это в один байт.

14:47.980 --> 14:48.980
Нет, смотри.

14:49.980 --> 14:50.980
Нет, нет, погоди.

14:51.980 --> 14:52.980
Однобайтного прибавления нет,

14:53.980 --> 14:54.980
потому что просто чтобы закодировать константу,

14:55.980 --> 14:56.980
тебе нужно хотя бы один байт.

14:57.980 --> 14:58.980
Нет, нет, там...

14:59.980 --> 15:00.980
Есть команда ингредиентов.

15:01.980 --> 15:02.980
Нет, нет, есть именно ADD,

15:02.980 --> 15:05.980
там закодированный регистр куда-то добавляет,

15:06.980 --> 15:09.980
а мы указываем регистр, который добавляется к этому регистру.

15:10.980 --> 15:16.980
То есть, ну, условно ADD, IELTS, IELTS, он будет делать IELTS плюс равно IELTS.

15:17.980 --> 15:20.980
Вот, а как ты вот 16 и 32 бита?

15:21.980 --> 15:22.980
Хорошо.

15:23.980 --> 15:24.980
Вот у тебя эта команда, она вот какая?

15:25.980 --> 15:26.980
Ну да.

15:27.980 --> 15:31.980
Она работает с исходным, 16 битным регистром.

15:32.980 --> 15:35.980
Если она работает с 16 битным регистром как с данными,

15:36.980 --> 15:41.980
то в 32 битном мире она будет интерпретироваться как команда,

15:42.980 --> 15:44.980
работающая с аналогичным 32 битным регистром.

15:45.980 --> 15:47.980
Если ты ничего не делаешь, то этот код означает вот это.

15:48.980 --> 15:53.980
Если ты ставишь перед этим кодом префикс 0x66,

15:54.980 --> 16:00.980
то интерпретация, да, кто это, изменяется на противоположную.

16:00.980 --> 16:07.980
То есть, в 16 битном мире оно интерпретирует это как работу с 32 битным регистром,

16:08.980 --> 16:10.980
а с 32 битным как с 16 битным.

16:11.980 --> 16:14.980
То есть, еще раз, это интерпретация именно вот смысла команды.

16:15.980 --> 16:19.980
Сколько там байтиков команда образует, это неважно.

16:20.980 --> 16:26.980
Команда логически работает вот с этим регистром и процессором интерпретирует с таким образом.

16:26.980 --> 16:32.980
И все эти дефолтные регистры, они тоже ведут себя аналогично.

16:33.980 --> 16:38.980
То есть, переключается вот такой смысл битности команды.

16:39.980 --> 16:43.980
А можно ли мы в рантайме менять битность?

16:44.980 --> 16:45.980
Что, это в рантайме происходит?

16:46.980 --> 16:47.980
Не-не, не битность.

16:48.980 --> 16:49.980
Я понимаю, что там ссорятся.

16:50.980 --> 16:53.980
Я имею в виду, можем ли мы в рантайме, особенно если мы исполняем все это в битном режиме,

16:53.980 --> 16:55.980
если просто, типа, начать?

16:56.980 --> 16:57.980
А, ну да, все ровно.

16:58.980 --> 17:05.980
Переключить режим можно, но переключение режима, как режим работает, это при виде ровных действий.

17:06.980 --> 17:08.980
То есть, на это нужна права ядра системы.

17:09.980 --> 17:14.980
И если вы переключите режим, то система будет очень удивлена.

17:15.980 --> 17:18.980
Поэтому, если только не вы сами себе, а операционная система,

17:19.980 --> 17:22.980
даже если вы добудете себе эти права,

17:23.980 --> 17:24.980
вы не хотите это сделать.

17:25.980 --> 17:27.980
Потому что это покрашит операционную систему.

17:28.980 --> 17:30.980
Ну, если виртуальный 16-битный режим.

17:31.980 --> 17:32.980
Да?

17:33.980 --> 17:37.980
Ну, если режим работы процессора похожий, пока мы их можем благополучно игнорировать,

17:38.980 --> 17:43.980
я вам просто пока рассказываю ту часть, которая необходима для понимания происходящего.

17:44.980 --> 17:50.980
То есть, первый важный факт, что 3D-битное расширение, оно было такое вот покрывающее все.

17:50.980 --> 17:58.980
И возможность использования 32-бит связана с тем, ваш процессор 32-битный или нет.

17:59.980 --> 18:06.980
Из другого режима, ну, только небольшие усилия, и вы получаете все, что там имеет ваш процессор.

18:07.980 --> 18:12.980
В отличие от этого, 64-битный режим, это было совсем по-другому сделано.

18:13.980 --> 18:15.980
Оно было сделано следующим образом.

18:16.980 --> 18:19.980
Что вот эти всякие новые штучки, которые я вам расскажу сейчас,

18:20.980 --> 18:23.980
они все работают только в 64-битном режиме.

18:24.980 --> 18:27.980
То есть, то, что процессор умеет 64-бит,

18:29.980 --> 18:33.980
все это видно только из 64-битного режима.

18:36.980 --> 18:41.980
Из 32-битного и 16-ти вы никак не достучитесь до этих новых вещей.

18:43.980 --> 18:49.980
Поэтому вот 64-битные штучки, они привязаны к 64-битному режиму.

18:51.980 --> 18:53.980
Понятно?

18:54.980 --> 19:00.980
Вот. А 32-битные и 16-битные работают в режиме такой жесткой обратной совместимости,

19:01.980 --> 19:04.980
как они работали раньше, вот один в один и работают.

19:05.980 --> 19:08.980
Также небольшая историческая исправка по происходящему.

19:09.980 --> 19:13.980
Вообще, 64-битное расширение называется...

19:20.980 --> 19:22.980
Он D64.

19:22.980 --> 19:24.980
Потому что это AMD-шный расширение.

19:25.980 --> 19:29.980
Большинство расширений, которые мы рассматривали, они Intel-ские.

19:29.980 --> 19:34.980
Ну, потому что Intel создает такие структуры и так далее.

19:34.980 --> 19:39.980
Но вот в 64-битном мире ситуация изменилась.

19:39.980 --> 19:43.980
А именно, были времена N64.

19:44.980 --> 19:47.980
И Intel хотели...

19:47.980 --> 19:53.980
Было понимание, что надо переходить на 64-битную архитектуру.

19:53.980 --> 19:55.980
Почему, кстати говоря?

19:59.980 --> 20:02.980
Да. Проблемы с адресами.

20:03.980 --> 20:13.980
И были всякие докладки, которые позволяли операционной системе использовать больше, чем 4 гигабайта памяти.

20:13.980 --> 20:16.980
Но вот без страданий...

20:16.980 --> 20:20.980
Прикладному софту доступно максимум 4 гигабайта.

20:21.980 --> 20:27.980
Притом, по факту, вам даже, скорее всего, доступны не 4 гигабайта, а 2.

20:28.980 --> 20:33.980
В связи с тем, как обычно устроены операционные системы...

20:34.980 --> 20:40.980
Операционные системы любят резервировать половину адресного пространства под себя.

20:41.980 --> 20:44.980
Поэтому из 4 гигабайт возможных адресов...

20:44.980 --> 20:50.980
Система резервирует под себя половину. Обычно это верхняя половина.

20:50.980 --> 20:57.980
То есть у вас доступно вашему ходу 2 гигабайта адресов.

20:58.980 --> 21:05.980
И всякие способы, как нарызать эти 2 гигабайта, они, конечно, были и существуют.

21:05.980 --> 21:07.980
Но это откровенно больно.

21:09.980 --> 21:12.980
Поэтому, чтобы не страдать...

21:12.980 --> 21:17.980
И чтобы можно было пользоваться все возрастающими объемами оперативки...

21:18.980 --> 21:24.980
Всем была понятна необходимость перехода на 64-битную арифметику.

21:25.980 --> 21:27.980
И изменение размера указателя...

21:27.980 --> 21:33.980
Это достаточно фундаментальное изменение, чтобы сказать, что это новый режим работы.

21:33.980 --> 21:36.980
Потому что, ну, все сломается.

21:36.980 --> 21:39.980
Здесь все сломается, поэтому...

21:39.980 --> 21:41.980
Это несовместимо.

21:41.980 --> 21:44.980
Почему верхняя?

21:44.980 --> 21:47.980
Ну, так выбрали.

21:47.980 --> 21:49.980
И, типа, нижние адреса...

21:49.980 --> 21:53.980
Там точно, вот, пацаны, около нуля что-то резервируют.

21:53.980 --> 22:00.980
Нет, около нуля резервируются ради облегчения поиска ошибок.

22:00.980 --> 22:07.980
Исключительно ради того, чтобы 0-пойнтеры не обращались четко узнать куда, а обладали впадением.

22:07.980 --> 22:09.980
Там тоже летом гигабайты не было?

22:09.980 --> 22:10.980
Нет, не лучше.

22:10.980 --> 22:12.980
Там порядка 64-ки добавились.

22:12.980 --> 22:15.980
Ну, опять-таки, от системы зависит.

22:15.980 --> 22:18.980
И вот это вообще не принципиально.

22:18.980 --> 22:26.980
На самом деле, если вы явно попросите операционку, то вы можете выделить память в нуле.

22:26.980 --> 22:29.980
То есть, она по диполу так не делает.

22:29.980 --> 22:37.980
Но, к примеру, раньше можно было сказать, вот, на низкоуровневыми командами операционки...

22:37.980 --> 22:39.980
Давай, вот, отобразим.

22:39.980 --> 22:42.980
Кусок вот этих вот адресов куда-нибудь.

22:42.980 --> 22:48.980
И можно было сделать 0-пойнтер, через который все работает.

22:48.980 --> 22:50.980
Но, еще раз.

22:50.980 --> 22:55.980
Это было очень такое неожиданное поведение.

22:55.980 --> 23:02.980
И работало в одной недочери в плане того, что компиляторы, еще раз не забывайте, проявляют всякий нездоровый цвет.

23:02.980 --> 23:08.980
А именно, компиляторы знают, что по 0-пойнтеру ничего быть не может.

23:09.980 --> 23:16.980
Поэтому, в тех местах, где компиляторы не используют интеллект в этом месте,

23:16.980 --> 23:21.980
после такого выделения памяти, у вас действительно, сквозь 0-пойнтер работает.

23:21.980 --> 23:28.980
Но, в тех местах, где компиляторы проявляют интеллект, у вас сломается.

23:28.980 --> 23:33.980
То есть, этот адрес, он будет посчитан как невалидный.

23:33.980 --> 23:38.980
Более того, 0-пойнтеры, они нередко используются как значение для вот такого...

23:39.980 --> 23:45.980
несуществующего результата или аргумента.

23:45.980 --> 23:54.980
Поэтому, даже если вы выделите там память, это значение просто будет сигнализировать и проверяться как несуществующее значение.

23:54.980 --> 24:05.980
Поэтому, чтобы не заморачиваться с подобным, и чтобы облегчить оплавку, операционки в районе 0 не выделяют память.

24:05.980 --> 24:07.980
Но это не какая-то техническая особенность.

24:07.980 --> 24:08.980
Это вот...

24:09.980 --> 24:12.980
когда я полностью сорву...

24:12.980 --> 24:14.980
0 и больше.

24:14.980 --> 24:15.980
Да.

24:15.980 --> 24:17.980
На XF6 умолчание в 0-м текст на лице.

24:17.980 --> 24:18.980
В 0-м?

24:18.980 --> 24:21.980
На XF6 умолчание в 0-м районе становится текстом.

24:21.980 --> 24:23.980
С 0-го и выше.

24:23.980 --> 24:25.980
Еще раз. Какой? 086, что ли?

24:25.980 --> 24:30.980
XF6. Это операционная система учебная под респект.

24:30.980 --> 24:32.980
А, ну, может быть.

24:32.980 --> 24:35.980
Учебная операционная система может делать что угодно.

24:35.980 --> 24:38.980
Но вот реальные операционки в 0 стараются не мать.

24:39.980 --> 24:41.980
Потому что они не могут мать.

24:41.980 --> 24:45.980
Но они стараются так не делать, чтобы не удивлять слов.

24:45.980 --> 24:48.980
Потому что вот про ньюпоинтеры.

24:48.980 --> 24:50.980
А, есть соглашение.

24:50.980 --> 24:53.980
И Б, это помощь в оплавке.

24:53.980 --> 25:01.980
То есть, если вы там забежали, лучше упасть, чем тихо писать непонятно какие-то бреда.

25:01.980 --> 25:04.980
Это все отсутствие прикосновений?

25:04.980 --> 25:06.980
Нет, это только другое собственно.

25:06.980 --> 25:07.980
Но это еще раз.

25:07.980 --> 25:10.980
Это оплавка.

25:10.980 --> 25:13.980
Вот.

25:13.980 --> 25:15.980
Так, что мы куда-то ушли?

25:15.980 --> 25:17.980
Что у вас осталось?

25:17.980 --> 25:21.980
Хотя, 4664.

25:21.980 --> 25:23.980
Битный режим.

25:23.980 --> 25:24.980
Зачем ему это?

25:24.980 --> 25:26.980
А, нет, парадочное пространство.

25:26.980 --> 25:28.980
То есть, еще раз.

25:28.980 --> 25:33.980
Несмотря на то, что у вас адресного пространства 4 гигабайта,

25:33.980 --> 25:36.980
фактически в программе доступно порядка двух.

25:36.980 --> 25:40.980
Ну, при помощи некоторого количества страданий и извращений,

25:40.980 --> 25:44.980
вы можете выбить в операционке 3 гигабайта.

25:44.980 --> 25:47.980
Но вот больше вряд ли.

25:47.980 --> 25:51.980
Нет, это опять-таки нужно включить режим гидрат,

25:51.980 --> 25:59.980
для того, чтобы операционка просто по-другому разделила адресное пространство между ведром и визуалом.

25:59.980 --> 26:04.980
Поэтому, ну, стала понятна необходимость того,

26:04.980 --> 26:09.980
чтобы перейти на 64-битную адресацию.

26:09.980 --> 26:12.980
И Intel решили сделать следующее.

26:12.980 --> 26:16.980
Они решили, что, ну, хватит уже пинать x86,

26:16.980 --> 26:21.980
надо сделать новую, крутую, прогрессивную,

26:21.980 --> 26:24.980
а самое главное, такую архитектуру,

26:24.980 --> 26:28.980
на которую лицензии будет только у нас, ни у кого больше.

26:28.980 --> 26:33.980
Чтобы всякие AMD и прочие не портили,

26:33.980 --> 26:36.980
не портили им бизнес.

26:36.980 --> 26:41.980
И сделали штуку под названием Itanium.

26:41.980 --> 26:50.980
Itanium, которая в сокращении называется IA64,

26:50.980 --> 26:52.980
если вы увидите.

26:52.980 --> 26:57.980
Вот такое название. Это Itanium.

26:57.980 --> 27:01.980
Но Itanium оказался Итаником.

27:01.980 --> 27:03.980
Народ его так окрестил.

27:03.980 --> 27:08.980
А именно, там были разного рода проблемы.

27:08.980 --> 27:12.980
И технические, и всякие логические, и маркетинговые.

27:12.980 --> 27:16.980
Ну, в общем, оно не взлетело.

27:16.980 --> 27:21.980
Да, еще раз, это была другая совершенно архитектура,

27:21.980 --> 27:24.980
несовместимая с x86.

27:24.980 --> 27:31.980
Там были некоторые возможности по аппаратной помощи в эмуляции x86,

27:31.980 --> 27:34.980
но они работали настолько плохо,

27:34.980 --> 27:39.980
что чисто программная эмуляция, которую допилили там через некоторое время,

27:39.980 --> 27:45.980
работала быстрее, чем через эти аппаратные команды поддержки.

27:45.980 --> 27:48.980
То есть настолько там было все плохо.

27:48.980 --> 27:57.980
Вот. И всякую там youtube и подобное портировали на Itanium очень быстро.

27:57.980 --> 28:00.980
Но вот портировать этот прикладной стоп,

28:00.980 --> 28:04.980
это удовольствие дорогое, медленное.

28:04.980 --> 28:09.980
И в режиме эмуляции оно работало, как я уже сказал, весьма пошире.

28:09.980 --> 28:13.980
А стоило, о буй, господи.

28:13.980 --> 28:20.980
И там всякие дедлайны они тоже многократно нарушали.

28:20.980 --> 28:24.980
Поэтому все это, ну, не взлетело.

28:24.980 --> 28:27.980
А почему эмуляция быстрее была?

28:27.980 --> 28:29.980
Ну, там криво было сделано.

28:29.980 --> 28:31.980
Оно работало как медленно.

28:31.980 --> 28:32.980
Ну, железки.

28:32.980 --> 28:34.980
Там были и всякие принципиальные проблемы.

28:34.980 --> 28:37.980
Например, размер страничек там был любой.

28:37.980 --> 28:39.980
Там были странички 8-килобайтные,

28:39.980 --> 28:42.980
тогда их, по-моему, существует 6-4-килобайтные.

28:42.980 --> 28:44.980
И через большие странички и меньшие,

28:44.980 --> 28:48.980
они вылились по щекам, по щекам.

28:48.980 --> 28:53.980
То есть там было много всяких технических и маркетинговых,

28:53.980 --> 28:55.980
и всяких других проблем.

28:55.980 --> 28:58.980
В итоге оно не взлетело.

28:58.980 --> 29:00.980
Когда народ, конечно, не было, что испугался.

29:00.980 --> 29:04.980
Вот, сейчас тут и все выпустят, захватят.

29:04.980 --> 29:07.980
Новая такая фута-архитектура.

29:09.980 --> 29:14.980
И где-то через год, ну так, не очень далеко от ИА-64,

29:14.980 --> 29:20.980
АМДшники выпустили свою попытку 64-бит,

29:20.980 --> 29:22.980
которая называлась АМД-64,

29:22.980 --> 29:26.980
и заключалась в том, что давайте закостылим

29:26.980 --> 29:30.980
новый режим к x86,

29:30.980 --> 29:37.980
где вы можете держать процессор в старом 64-битном режиме,

29:37.980 --> 29:41.980
и оно будет работать прямо как раньше, один в один,

29:41.980 --> 29:43.980
с полной скоростью,

29:43.980 --> 29:45.980
никаких проблем,

29:45.980 --> 29:48.980
а можете перейти в 64-битный режим,

29:48.980 --> 29:50.980
там у вас будут новые вкусняшки,

29:50.980 --> 29:55.980
и даже из 64-битного режима есть режим совместимости,

29:56.980 --> 30:00.980
для, вот, юзерспейса прикладного софта,

30:00.980 --> 30:05.980
который также работает прямо вот практически один в один,

30:05.980 --> 30:06.980
как и раньше.

30:06.980 --> 30:10.980
То есть, чтобы перейти вот на АМД-64,

30:10.980 --> 30:13.980
не нужно ничего прикомпилировать,

30:13.980 --> 30:18.980
вы можете использовать вообще этот процессор в x86-битном режиме,

30:18.980 --> 30:20.980
он будет работать с полной скоростью,

30:20.980 --> 30:24.980
захотите 64-бита, вам нужна 64-битная операционка,

30:24.980 --> 30:26.980
64-битные дрова,

30:26.980 --> 30:29.980
а юзерспейс вы можете продолжить использовать

30:29.980 --> 30:32.980
рассеянный 2-битный вместе с 64-битным,

30:32.980 --> 30:35.980
ну, то есть максимально удобный переход,

30:35.980 --> 30:38.980
не больный ни с какой точки зрения.

30:38.980 --> 30:44.980
И вот всё это, оно одновременно совпало

30:44.980 --> 30:49.980
с выходом очень удачной архитектуры АМД-шной,

30:49.980 --> 30:52.980
это был процессор Athlon 64,

30:52.980 --> 30:55.980
который был технически просто очень удачный.

30:56.980 --> 30:58.980
Он и сам по себе хорошо работал,

30:58.980 --> 31:03.980
и там случились довольно существенные изменения архитектурные,

31:03.980 --> 31:06.980
что контроллер памяти встроили в ядро,

31:06.980 --> 31:09.980
раньше он находился в отдельной мехосхеме Северный мост,

31:09.980 --> 31:12.980
то есть там ещё доступ к памяти сильно ускорился,

31:12.980 --> 31:15.980
поэтому вот эти вот процессоры АМД-64,

31:15.980 --> 31:18.980
они в клочья рвали всё интеловское,

31:18.980 --> 31:21.980
и по цене в том числе.

31:21.980 --> 31:24.980
Поэтому народ, конечно же,

31:24.980 --> 31:27.980
вообще не хотел покупать эти ПИА,

31:27.980 --> 31:30.980
и массово покупал у рабочих.

31:30.980 --> 31:33.980
То есть там был период времени,

31:33.980 --> 31:36.980
когда все топовые процессы, они были АМД-шными,

31:36.980 --> 31:39.980
ну, что, собственно говоря, наблюдается, честно говоря, и сегодня.

31:39.980 --> 31:46.980
И у него снова такая полоса страданий и фигней.

31:46.980 --> 31:53.980
Вот. Поэтому, если вы увидите название АМД-64,

31:54.980 --> 32:01.980
то вот это вот просто название 64-х битвы архитектуры ПИА-86.

32:01.980 --> 32:08.980
И потом, когда стало понятно, что Даня вернулся,

32:08.980 --> 32:11.980
АМД-64 действительно успешно,

32:11.980 --> 32:16.980
им, по-моему, пришлось поддержать АМД-64-решение.

32:16.980 --> 32:19.980
Конечно, они не могли его назвать АМД-64,

32:19.980 --> 32:23.980
это, по-моему, в какой-то документации обозначается.

32:24.980 --> 32:27.980
Но, в смысле, вот это не меняется.

32:27.980 --> 32:30.980
Хотя потом такое более нейтральное название,

32:30.980 --> 32:38.980
как Х-86-64 и даже еще, короче, Х-64.

32:38.980 --> 32:40.980
Вот это вот все полные синонимы.

32:40.980 --> 32:43.980
Вот это — это совсем другое,

32:43.980 --> 32:46.980
а вот это — это полные синонимы.

32:46.980 --> 32:48.980
— А у них права были у АМД?

32:48.980 --> 32:52.980
— Знаешь, что делать? С правами там интересная вещь.

32:52.980 --> 32:58.980
Современная Х-86-архитектура, она покрыта патентами,

32:58.980 --> 33:01.980
и она покрыта патентами весьма плотно

33:01.980 --> 33:04.980
и со стороны Intel, и со стороны АМД.

33:04.980 --> 33:07.980
Если любая из этих компашек объявит,

33:07.980 --> 33:11.980
что мы не разрешаем пользоваться нашими патентами,

33:11.980 --> 33:17.980
то другой не сможет сделать современный процессор на Х-86.

33:17.980 --> 33:21.980
То есть у них там сейчас полная взаимозависимость,

33:22.980 --> 33:25.980
и мирная договоренность о том,

33:25.980 --> 33:29.980
что другая компашка может пользоваться без проблем

33:29.980 --> 33:31.980
патентами другой компашки.

33:31.980 --> 33:35.980
— Так у них же изначально вот...

33:35.980 --> 33:36.980
— Нет, еще раз.

33:36.980 --> 33:41.980
Исходно Intel выдала разрешение на использование Х-86,

33:41.980 --> 33:44.980
ну, базовое для Х-86,

33:44.980 --> 33:47.980
всякие расширения и прочее.

33:47.980 --> 33:50.980
Там, конечно же, Intel пытались отсудить по максимуму,

33:50.980 --> 33:52.980
если бы они тут не лезли,

33:52.980 --> 33:54.980
и решали бы убить.

33:54.980 --> 33:56.980
Но вот в современном мире

33:56.980 --> 34:00.980
там у них полная взаимная зависимость.

34:00.980 --> 34:03.980
То есть если АМДшный патент убрать,

34:03.980 --> 34:09.980
то он не сможет сделать Х-86 процессор, и наоборот.

34:09.980 --> 34:12.980
А вот техническое решение только подчеркивает.

34:12.980 --> 34:16.980
То есть это вообще чисто АМДшный решение.

34:16.980 --> 34:18.980
Почему, ну, по крайней мере, раньше,

34:18.980 --> 34:21.980
когда еще и А-64, и А-97 все забыли,

34:21.980 --> 34:24.980
там всякие графа еще включаются,

34:24.980 --> 34:27.980
народ, наверное, редко выбирал

34:27.980 --> 34:30.980
всякие парики из папочки А-64,

34:30.980 --> 34:33.980
потому что у меня не АМД процессор,

34:33.980 --> 34:36.980
а АМД-64 и А-64.

34:36.980 --> 34:38.980
Правильный выбор — АМД-64.

34:38.980 --> 34:41.980
И, важно, у вас там Intel процессоры не Intel,

34:41.980 --> 34:44.980
потому что это название 64-метрового режима.

34:44.980 --> 34:47.980
Но сейчас уже так редко встречается,

34:47.980 --> 34:50.980
сейчас уже на ноль встречается либо Х-64,

34:50.980 --> 34:52.980
такая самая короткая форма,

34:52.980 --> 34:55.980
либо Х-86.

34:55.980 --> 34:59.980
Почему 64, если реально адресуется 48?

34:59.980 --> 35:02.980
Потому что указателем у вас используются

35:02.980 --> 35:06.980
шестничные узлы числа.

35:06.980 --> 35:09.980
Там есть, конечно, особенности,

35:09.980 --> 35:11.980
сколько из них используется,

35:11.980 --> 35:14.980
и некоторые специальные правила,

35:14.980 --> 35:18.980
но, честно говоря, адреса шестничные нет.

35:18.980 --> 35:22.980
Поэтому 64 — это нормальное название.

35:22.980 --> 35:26.980
И вот эти вот особенности, они не принципиальные.

35:26.980 --> 35:28.980
Это такие технические ограничения,

35:28.980 --> 35:32.980
но ничто не мешает выпустить процессор,

35:32.980 --> 35:35.980
который имеет полную поддержку

35:35.980 --> 35:38.980
всех 64-бит адресов

35:38.980 --> 35:41.980
и ничего не сломает их со всех.

35:41.980 --> 35:43.980
Понятно?

35:43.980 --> 35:47.980
То есть это нормально, совершенно правильно,

35:47.980 --> 35:50.980
вызывать это 64-бит адрес.

35:50.980 --> 35:51.980
— Ну, это, кстати, не проблема,

35:51.980 --> 35:53.980
кстати, соц, который будет работать только на одном конце,

35:53.980 --> 35:55.980
и он просто сломается из-за того,

35:55.980 --> 35:58.980
что там, наверное, некоторые предположения.

35:58.980 --> 35:59.980
— Ничего, конечно.

35:59.980 --> 36:01.980
— Потому что некоторый соц

36:01.980 --> 36:02.980
все же может сломаться от того,

36:02.980 --> 36:06.980
что адреса 48 поднимется до 64.

36:06.980 --> 36:08.980
— Ну, знаешь...

36:08.980 --> 36:10.980
— Специфический соц, он может.

36:10.980 --> 36:13.980
— Это как всякие системы защиты сломались,

36:13.980 --> 36:15.980
ковидоинтелсы выпустили

36:15.980 --> 36:17.980
процессор с асимметричным ядром.

36:17.980 --> 36:20.980
— Ну, конечно, наверняка кто-то где-то сломается.

36:20.980 --> 36:23.980
Это такая известная история,

36:23.980 --> 36:28.980
что вот там новая версия текстового редактора,

36:28.980 --> 36:30.980
мы там пофиксили багу,

36:30.980 --> 36:33.980
которая, когда вы зажимаете пробел,

36:33.980 --> 36:38.980
нагревает процессор на 100 градусов,

36:38.980 --> 36:41.980
а в ответ пишет пользователь

36:41.980 --> 36:45.980
«Ой, верните обратно, у меня там не работает control,

36:45.980 --> 36:48.980
поэтому я и сделал скрипт,

36:48.980 --> 36:53.980
что если температура процессора поднимается до 90 градусов,

36:53.980 --> 36:56.980
а вы интерпретируете, как будто я нажал control,

36:56.980 --> 36:59.980
поэтому, верните все обратно,

36:59.980 --> 37:01.980
я хочу старое поведение».

37:01.980 --> 37:04.980
То есть наверняка кто-то

37:04.980 --> 37:06.980
так же себя может вести,

37:06.980 --> 37:09.980
но это его личные проблемы.

37:09.980 --> 37:13.980
В целом, такое наблюдаться неровно.

37:13.980 --> 37:19.980
Итак, вот еще раз,

37:19.980 --> 37:22.980
все это — полные синонимы,

37:22.980 --> 37:25.980
поэтому если вы где-то видите AMD 64,

37:25.980 --> 37:27.980
это просто шестидесятый репитмин

37:27.980 --> 37:29.980
в режиме x86,

37:29.980 --> 37:31.980
ни больше, ни меньше,

37:31.980 --> 37:33.980
длинный вот такой у вас процессор,

37:33.980 --> 37:36.980
ни толстый — никакой разницы.

37:36.980 --> 37:38.980
Что у нас произошло

37:38.980 --> 37:41.980
в этом самом шестидесятый репитмин x86?

37:41.980 --> 37:42.980
Ну, первое,

37:42.980 --> 37:44.980
вы уже догадываетесь,

37:44.980 --> 37:46.980
регистры расширили.

38:00.980 --> 38:02.980
Регистры расширили,

38:02.980 --> 38:07.980
и теперь то, что было eax,

38:07.980 --> 38:10.980
стало rax.

38:12.980 --> 38:14.980
То есть картинка вот такая.

38:14.980 --> 38:16.980
Все это вместе.

38:16.980 --> 38:21.980
rax — это eax,

38:21.980 --> 38:27.980
аax — h,

38:27.980 --> 38:34.980
а l — 0,

38:34.980 --> 38:38.980
и x86 — 0,

38:38.980 --> 38:40.980
и x86 — 0,

38:40.980 --> 38:42.980
и y — 0,

38:42.980 --> 38:44.980
и x86 — 0,

38:44.980 --> 38:46.980
и y — 0,

38:46.980 --> 38:48.980
и Ñ — 0.

38:48.980 --> 38:51.980
Т.е. все эти гибкие сложности

38:51.980 --> 39:00.980
набрасываются в рамках

39:00.980 --> 39:02.980
резерва,

39:02.980 --> 39:04.980
насколько я upon the whole

39:04.980 --> 39:07.980
ierz interval

39:07.980 --> 39:08.980
5000p.

39:08.980 --> 39:15.720
что у них вот такого разрезания не было.

39:17.340 --> 39:23.600
И им давали возможность обращения к младшим восьмидетикам.

39:25.360 --> 39:32.420
То есть у этих регистров у них была вот такая форма,

39:33.420 --> 39:36.900
которая означает младшие восьмидетики.

39:36.900 --> 39:38.280
Вот аналога H нет.

39:38.980 --> 39:39.860
Почему?

39:40.740 --> 39:41.800
Ну, потому что не нужно.

39:44.660 --> 39:47.080
На самом деле для SP это нафиг не нужно,

39:47.700 --> 39:52.640
но ввиду симметрии кодирования оно там тоже появилось.

39:55.000 --> 39:58.840
То есть у вас есть доступ теперь ко всем регистрам

39:58.840 --> 40:03.960
к младшим восьми, шестнадцати, тридцати двум и шестидесяти четырем.

40:08.980 --> 40:18.660
Потом, в одно из самых вкусных, добавили новых регистров общего назначения.

40:18.660 --> 40:30.660
Регистры эти называются R8 по R15.

40:30.660 --> 40:34.660
Вот какие названия сцеплены.

40:34.660 --> 40:38.600
Это шестидесяти четырехбитные формы.

40:38.600 --> 40:38.820
Это шестидесяти четырехбитные формы.

40:38.820 --> 40:38.900
Это шестидесяти четырехбитные формы.

40:38.900 --> 40:42.900
У них также есть тридцать два, шестнадцать и восемь,

40:42.900 --> 40:54.340
которые называются R8D, R8V, R8B.

40:54.340 --> 40:55.780
Но опять, регистры не важны.

41:03.780 --> 41:07.440
Это восемь регистров общего назначения.

41:07.440 --> 41:08.740
Такие как...

41:08.740 --> 41:11.240
ЕАХ, ЕЦХ и так далее.

41:13.020 --> 41:13.600
Вот-вот.

41:14.240 --> 41:15.200
Точно так же.

41:17.240 --> 41:23.740
Но у них коротенькие формы образуются по другой системе.

41:25.020 --> 41:26.040
По более выгодной.

41:30.740 --> 41:34.740
Как поделаться инструкцией с ЕЦХ?

41:36.740 --> 41:38.660
Ну, на самом деле,

41:38.740 --> 41:44.740
кодирование там, по большей части, тридцать двухбитное.

41:44.740 --> 41:49.740
То есть большинство команд в шестидесяти четырехбитном режиме

41:49.740 --> 41:52.740
в дефолте тридцать двухбитное.

41:52.740 --> 41:58.740
Для того, чтобы закодировать что-то новенькое,

41:58.740 --> 42:02.740
то есть вот R-регистр шириной,

42:02.740 --> 42:04.740
или вот эти новые регистры,

42:04.740 --> 42:07.740
там нужно добавить специальный префикс.

42:07.740 --> 42:08.580
Там нужно добавить специальный префикс.

42:08.580 --> 42:11.580
Префикс называется REX.

42:16.580 --> 42:24.580
И имеет коды от 0x40 до 0x41.

42:27.580 --> 42:30.580
Если только курсы кодирования,

42:30.580 --> 42:34.580
то это были такие специальные короткие формы

42:34.580 --> 42:37.580
для команд INC, DEC и DIST.

42:38.580 --> 42:41.580
Сейчас эти короткие формы забрали,

42:41.580 --> 42:43.580
то есть команды INC, DEC остались,

42:43.580 --> 42:46.580
но у них остались только полные формы.

42:46.580 --> 42:49.580
А короткие формы забрали под префикс,

42:49.580 --> 42:55.580
который позволяет вам закодировать вот эти новые регистры.

42:55.580 --> 42:59.580
Вообще система кодирования, она минимально изменилась.

42:59.580 --> 43:03.580
Но для того, чтобы обращаться к новым регистрам,

43:03.580 --> 43:07.580
поле, которое кодировало индексы регистра,

43:07.580 --> 43:10.580
оно уже было трехбитовое.

43:10.580 --> 43:12.580
Регистра стало 16,

43:12.580 --> 43:17.580
и вам нужно теперь использовать 4 бита для индекса регистра.

43:17.580 --> 43:20.580
Вот этот дополнительный бит,

43:20.580 --> 43:23.580
он и берется из префикса REX.

43:23.580 --> 43:26.580
То есть вот эти вот единички,

43:26.580 --> 43:32.580
это битовые расширения полей,

43:32.580 --> 43:35.580
которые используются в обычном коде команды,

43:35.580 --> 43:36.580
позволяющие вам закодировать.

43:36.580 --> 43:39.580
Эти расширенные регистры.

43:39.580 --> 43:44.580
И в связи с этим есть еще одна особенность,

43:44.580 --> 43:52.580
а именно одной команде нельзя мешать аж регистры

43:52.580 --> 44:00.580
и что угодно новое.

44:00.580 --> 44:03.580
Почему?

44:03.580 --> 44:04.580
Потому что вот эти вот,

44:04.580 --> 44:12.580
формы, которые SPL, WPL, откуда они взялись?

44:12.580 --> 44:17.580
Это те коды, которые раньше кодировали аж регистры.

44:17.580 --> 44:23.580
А в новой системе кодирования,

44:23.580 --> 44:26.580
они кодируют теперь не аж регистры,

44:26.580 --> 44:29.580
а младшие 8 бит других регистров.

44:29.580 --> 44:32.580
Из этого следует, что просто технически,

44:32.580 --> 44:40.580
если вы используете новую индексацию регистров,

44:40.580 --> 44:42.580
то есть у вас есть префикс,

44:42.580 --> 44:47.580
то аж регистры вы не способны теперь закодировать.

44:47.580 --> 44:51.580
То есть аж регистры, они не были убраны,

44:51.580 --> 44:55.580
но вы не всегда можете на них достучаться

44:55.580 --> 44:58.580
в зависимости от того, что вы используете.

44:58.580 --> 45:00.580
То есть какая-нибудь команда

45:00.580 --> 45:04.580
может сказать, что мов а аж запятая ц л осталась.

45:04.580 --> 45:06.580
Нет проблем.

45:06.580 --> 45:08.580
Но сказать, например,

45:08.580 --> 45:13.580
мов а аж запятая р 8 б невозможно.

45:13.580 --> 45:17.580
Потому что, если вы используете обширное кодирование

45:17.580 --> 45:20.580
для того, чтобы обратиться к р 8 б,

45:20.580 --> 45:23.580
то кода для а аж просто нет.

45:23.580 --> 45:27.580
А аж, то что раньше кодировало а аж,

45:27.580 --> 45:29.580
теперь это будет WPL.

45:30.580 --> 45:35.580
Вот пометьте себе, что в одной команде

45:35.580 --> 45:39.580
нельзя использовать одновременно аж регистры

45:39.580 --> 45:42.580
и любой новый регистр.

45:42.580 --> 45:51.580
И R, потом SPL, WPL или там RAX.

45:51.580 --> 45:56.580
Любой регистр, которого не было в 3D-умережении,

45:56.580 --> 45:59.580
нельзя использовать вместе с аж регистрами,

45:59.580 --> 46:01.580
в одной команде.

46:01.580 --> 46:04.580
Потому что для обращения к этому новому регистру

46:04.580 --> 46:06.580
нужен префикс.

46:06.580 --> 46:11.580
А префикс переключает значение этих цифр.

46:11.580 --> 46:13.580
Нет, не его новый регистр,

46:13.580 --> 46:22.580
а в эти самые WPL, SPL, SIL, DIL.

46:22.580 --> 46:23.580
Вот.

46:23.580 --> 46:25.580
Оно сюда приходит.

46:29.580 --> 46:31.580
Ну, не сказать, что это нормально.

46:31.580 --> 46:33.580
Просто нет.

46:33.580 --> 46:34.580
Правильно.

46:34.580 --> 46:36.580
А что бы мы скодировали?

46:36.580 --> 46:39.580
Ну, хоть вот в моменте исполнения...

46:39.580 --> 46:41.580
Нет, ты не сумеешь выразить такую мысль,

46:41.580 --> 46:43.580
это низкий интервью.

46:45.580 --> 46:47.580
Причем можно спросить,

46:47.580 --> 46:50.580
а вот у нас мы можем условно считать 15 б,

46:50.580 --> 46:51.580
а записать только 8 б?

46:51.580 --> 46:52.580
Да, конечно.

46:52.580 --> 46:55.580
А у нас старшая часть будет аннулироваться?

46:55.580 --> 46:57.580
Вот, сейчас я про это скажу.

46:57.580 --> 46:58.580
Ну...

46:58.580 --> 47:00.580
Хорошо, сейчас скажу.

47:00.580 --> 47:02.580
Да, здесь есть особенность,

47:02.580 --> 47:04.580
она заключается в следующем,

47:04.580 --> 47:10.580
что когда вы пишете в 32 младших бита

47:10.580 --> 47:15.580
и ровно в 32 младших бита любого регистра,

47:15.580 --> 47:21.580
например, mov.eax, там, ecx,

47:21.580 --> 47:26.580
то в этом случае старшие 32 бита обнуляются.

47:28.580 --> 47:31.580
Вот, обязательно пометьте.

47:31.580 --> 47:32.580
Еще раз, правильно.

47:32.580 --> 47:38.580
Если команда пишет 32-битную часть регистра

47:38.580 --> 47:41.580
любого, старого, нового, неважно,

47:41.580 --> 47:46.580
то старшие 32 бита обнуляются.

47:46.580 --> 47:50.580
То есть на самом деле команда пишет 10 дисков,

47:50.580 --> 47:53.580
после пишет 0 в старшую часть.

47:53.580 --> 47:57.580
Если вы пишете не 32-битную часть,

47:57.580 --> 48:01.580
например, вот пишите 16 бит, 8, 8,

48:01.580 --> 48:04.580
то ничего подобного не происходит.

48:04.580 --> 48:07.580
То есть как раньше запись mov.eax

48:07.580 --> 48:11.580
не трогала старшие 16 бит,

48:11.580 --> 48:14.580
так и эти она тоже не трогает.

48:16.580 --> 48:19.580
Поэтому только запись 32-битной порции

48:19.580 --> 48:22.580
имеет вот такую особенность.

48:22.580 --> 48:25.580
Можно ли я считать, что

48:25.580 --> 48:29.580
когда мы пишем в 8 или в 16,

48:29.580 --> 48:34.580
и у нас, по сути, не трогается остальная часть,

48:34.580 --> 48:39.580
то это, по сути, мы читаем свой же регистр

48:39.580 --> 48:44.580
и просто маску накидываем и делаем или с этой частью.

48:44.580 --> 48:48.580
То есть на самом деле у нас происходит чтение,

48:48.580 --> 48:51.580
может, из этого регистра читали данные

48:51.580 --> 48:52.580
перед тем, как мы его пишем?

48:52.580 --> 48:54.580
Ну, скорее не столько чтение,

48:54.580 --> 48:56.580
а есть ли зависимость

48:56.580 --> 48:59.580
по исходному значению этого регистра.

48:59.580 --> 49:01.580
Вот так вот я рассказываю.

49:01.580 --> 49:02.580
Да, есть.

49:02.580 --> 49:05.580
Вернее, там есть разные режимы в разных процессорах,

49:05.580 --> 49:07.580
но, как правило,

49:07.580 --> 49:10.580
наверное, проще считать, что есть.

49:10.580 --> 49:12.580
Потому что в разных процессорах

49:12.580 --> 49:13.580
там были разные фичи

49:13.580 --> 49:16.580
про вот 8-битные части и так далее,

49:16.580 --> 49:18.580
но в современных эти фичи,

49:18.580 --> 49:19.580
я так понимаю,

49:19.580 --> 49:22.580
они все меньше актуальны.

49:22.580 --> 49:24.580
Есть специальные такие режимы,

49:24.580 --> 49:26.580
а есть маленькие кусочки.

49:26.580 --> 49:31.580
И оно будет зависимое.

49:31.580 --> 49:33.580
Но у нас, видите, там есть флаг,

49:33.580 --> 49:35.580
например, у Armani есть флаг из Merging,

49:35.580 --> 49:37.580
который динамический,

49:37.580 --> 49:38.580
и если он смерджется,

49:38.580 --> 49:41.580
то он не замерзает.

49:41.580 --> 49:43.580
А если не смерджется,

49:43.580 --> 49:45.580
то он замерзает, по-скольку.

49:45.580 --> 49:47.580
И этот флаг зависит.

49:47.580 --> 49:50.580
Нет, здесь никаких флагов по этому поводу нет,

49:50.580 --> 49:52.580
но вот это вот зависимость

49:52.580 --> 49:54.580
в плане того, чтобы,

49:54.580 --> 49:55.580
если вы делаете, например,

49:55.580 --> 49:58.580
скажите,

49:58.580 --> 50:05.580
mov ax constant,

50:05.580 --> 50:07.580
то вот эта команда

50:07.580 --> 50:09.580
означает, что ее результат

50:09.580 --> 50:13.580
зависит от предыдущего значения rax.

50:13.580 --> 50:14.580
Ну да, да, да.

50:14.580 --> 50:15.580
Я вот про что.

50:15.580 --> 50:19.580
А если вы делаете mov eax constant,

50:19.580 --> 50:22.580
то эта команда пишет весь регистр,

50:22.580 --> 50:25.580
и поэтому зависимости от того,

50:25.580 --> 50:28.580
что с этим регистром делали раньше, нет.

50:28.580 --> 50:31.580
На правильность это не влияет,

50:31.580 --> 50:35.580
но это влияет на эффективность работы,

50:35.580 --> 50:38.580
когда вы смотрите, какая команда какой зависит,

50:38.580 --> 50:41.580
что там суперскаляра может одновременно исполнить.

50:41.580 --> 50:43.580
В этом плане, конечно, рекомендуется

50:43.580 --> 50:45.580
писать весь регистр.

50:45.580 --> 50:47.580
Это означает, что рекомендуется

50:47.580 --> 50:50.580
писать хотя бы 32 бита.

50:50.580 --> 50:52.580
И еще последствия.

50:52.580 --> 50:54.580
Тоже важное.

50:54.580 --> 50:57.580
Я вам сказал, что такая дефолтная битность

50:57.580 --> 50:59.580
в 64-битном режиме

50:59.580 --> 51:01.580
все равно 32 бита.

51:01.580 --> 51:05.580
Поэтому выгоднее использовать команду

51:09.580 --> 51:11.580
а не команду

51:15.580 --> 51:16.580
Почему?

51:16.580 --> 51:18.580
Потому что результат одинаковый,

51:18.580 --> 51:21.580
а эта команда на 1 байт короче.

51:21.580 --> 51:24.580
Там нет реакс-префикса.

51:24.580 --> 51:26.580
С другой стороны,

51:26.580 --> 51:29.580
если вы ксорите, например, R8,

51:29.580 --> 51:33.580
то вот ксорите вы R8 или R8D,

51:33.580 --> 51:35.580
никакой разницы.

51:35.580 --> 51:38.580
Эти команды занимают одинаковый размер,

51:38.580 --> 51:41.580
работают с одинаковой скоростью,

51:41.580 --> 51:43.580
вообще-то разница.

51:43.580 --> 51:45.580
Потому что для кодирования R8

51:45.580 --> 51:47.580
вам реакс все равно нужен.

51:47.580 --> 51:50.580
А вот для таких старых регистров,

51:50.580 --> 51:53.580
выгоднее использовать Е-формы,

51:53.580 --> 51:57.580
потому что оно тогда будет кодироваться на 1 байт короче,

51:57.580 --> 52:00.580
если вам нужно занурение старшей части.

52:00.580 --> 52:01.580
Да.

52:06.580 --> 52:07.580
Да.

52:07.580 --> 52:09.580
Потому что просто загрузка 32 бита

52:09.580 --> 52:12.580
уже обнуряет старшую часть.

52:16.580 --> 52:17.580
Да.

52:17.580 --> 52:18.580
Тоже самое.

52:18.580 --> 52:21.580
Но я ихс на 1 байт короче кодирую,

52:21.580 --> 52:24.580
потому что оно не требует реакс-префикса.

52:24.580 --> 52:27.580
Так что если вы смотрите на код компилятора,

52:27.580 --> 52:29.580
вот ответ на вопрос,

52:29.580 --> 52:32.580
почему компиляторы выглядят такими

52:32.580 --> 52:34.580
тридцатиноубитными командочки,

52:34.580 --> 52:36.580
даже если у вас в этом регистре

52:36.580 --> 52:38.580
лежит шестнечетыреубитное число.

52:38.580 --> 52:41.580
Потому что действия эквивалентные,

52:41.580 --> 52:45.580
а кодируются короче.

52:45.580 --> 52:47.580
И в этом месте даже есть

52:47.580 --> 52:50.580
такой один забавный хак.

52:50.580 --> 52:52.580
Я бы даже так сказал.

52:53.580 --> 52:58.580
Кто знает про код 0x90?

53:00.580 --> 53:02.580
Что это за код такой?

53:02.580 --> 53:04.580
Это ноб.

53:05.580 --> 53:06.580
Ну это ноб,

53:06.580 --> 53:09.580
это как бы официальный ноб.

53:09.580 --> 53:11.580
А если технически,

53:11.580 --> 53:15.580
то какому действию это соответствует?

53:17.580 --> 53:19.580
Нет.

53:19.580 --> 53:21.580
Нет.

53:30.580 --> 53:33.580
И это действительно был ноб

53:33.580 --> 53:36.580
в шестнадцати и тридцатиноубитном режиме.

53:36.580 --> 53:39.580
Но теперь обратите внимание.

53:39.580 --> 53:41.580
Вот это новое правило

53:41.580 --> 53:43.580
зануления старшей части

53:43.580 --> 53:46.580
означает, что эта команда не ноб.

53:46.580 --> 53:48.580
Потому что она должна

53:48.580 --> 53:51.580
занулять старшую половину Rx.

53:51.580 --> 53:55.580
Но, так как официально в документации

53:55.580 --> 53:57.580
сказано, что это ноб,

53:57.580 --> 54:01.580
то оно не зануляет ничего.

54:01.580 --> 54:03.580
Это действительно ноб.

54:03.580 --> 54:05.580
То есть в программе об код

54:05.580 --> 54:07.580
поставили там официальный if.

54:07.580 --> 54:10.580
Несмотря на то, что вот оно как бы

54:10.580 --> 54:12.580
соответствует коду этой команды,

54:12.580 --> 54:15.580
но на самом деле это честный ноб.

54:15.580 --> 54:17.580
То есть если мы сами эту команду напишем,

54:17.580 --> 54:19.580
то тоже ничего не произойдет?

54:19.580 --> 54:21.580
Это уже зависит от.

54:21.580 --> 54:24.580
Потому что у команды XTHG

54:24.580 --> 54:27.580
есть несколько вариантов кода.

54:27.580 --> 54:30.580
И если оно сконфилируется

54:30.580 --> 54:33.580
в код 0x90,

54:33.580 --> 54:35.580
то это будет ноб.

54:35.580 --> 54:37.580
А если оно сконфилирует себя

54:37.580 --> 54:40.580
в полную форму XTHG,

54:40.580 --> 54:42.580
то оно будет обнулять.

54:42.580 --> 54:44.580
И я так понимаю,

54:44.580 --> 54:46.580
что современные компиляторы,

54:46.580 --> 54:49.580
если вы их просите вот так вот сконфилировать,

54:49.580 --> 54:51.580
они вам будут сконфилировать в полную форму,

54:51.580 --> 54:53.580
как раз специально,

54:53.580 --> 54:55.580
чтобы вы получили вот тот эффект,

54:55.580 --> 54:57.580
который просили.

54:57.580 --> 54:59.580
Потому что, наверное, вы просили обнулить

54:59.580 --> 55:02.580
старшую часть реки.

55:02.580 --> 55:04.580
То есть вот этот вот код,

55:04.580 --> 55:08.580
он имеет специальную обработку.

55:08.580 --> 55:10.580
Несмотря на то, что он как будто

55:10.580 --> 55:12.580
соответствует команде XTHG,

55:12.580 --> 55:15.580
в фактически любительном мире

55:15.580 --> 55:17.580
это уже не так.

55:17.580 --> 55:22.580
Это такой честный специальный случай.

55:22.580 --> 55:25.580
А ноб?

55:25.580 --> 55:29.580
Нет операции и ничего не делает.

55:29.580 --> 55:31.580
Обращаю ваше внимание,

55:31.580 --> 55:36.580
что на x86 ноб имеют код не 0.

55:36.580 --> 55:39.580
Довольно популярно в разных архитектурах

55:39.580 --> 55:42.580
для ноба выбирать код 0.

55:42.580 --> 55:45.580
Так вот, 0 на x86

55:45.580 --> 55:47.580
это не только ноб,

55:47.580 --> 55:49.580
это двухбайтовая команда,

55:49.580 --> 55:52.580
которая обращается в память.

55:52.580 --> 55:55.580
Поэтому, если вы наткнетесь на исполнение

55:55.580 --> 55:57.580
кучи нулей как кода,

55:57.580 --> 55:59.580
вы с высокой вероятностью

55:59.580 --> 56:01.580
очень быстро покрашитесь.

56:01.580 --> 56:03.580
Потому что будете обращаться

56:03.580 --> 56:06.580
в чёрт его знает куда в память.

56:08.580 --> 56:10.580
Поэтому переход на генерацию

56:10.580 --> 56:13.580
вставляете юдэдвэр.

56:13.580 --> 56:15.580
Ну дэдвэр бывает, что кобелятор вставляют.

56:15.580 --> 56:18.580
Но на самом деле, качтые заполнения

56:18.580 --> 56:21.580
гораздо чаще используются

56:21.580 --> 56:23.580
вот этот код.

56:24.580 --> 56:27.580
Этот код соответствует команде

56:27.580 --> 56:29.580
int3.

56:29.580 --> 56:31.580
Вы вылезете в апперчик.

56:31.580 --> 56:34.580
Но после у меня int3 под другое используется

56:34.580 --> 56:37.580
а юдэдвэр именно под некорректную позицию.

56:37.580 --> 56:39.580
Нет, мы тут тратим места.

56:40.580 --> 56:45.540
Посреди кода, когда у вас там функции выравниваются на что-то,

56:45.960 --> 56:47.980
вот они обычно заполняются вот так.

56:50.300 --> 56:54.340
У D2, я знаю, компиляторы в духе сланга и ПЦЦ

56:54.340 --> 56:58.260
любят ставить, если ваша функция описана как no return,

56:59.040 --> 57:01.840
то вместо команды read ставится UD2.

57:02.620 --> 57:03.500
Вот так они любят ставить.

57:03.500 --> 57:08.540
А всякие заполнения обычно происходят вот через UD3.

57:10.580 --> 57:12.440
Почему не нопами?

57:14.100 --> 57:19.220
Потому что если D2 здесь оказался, то что-то незапланированное произошло.

57:19.240 --> 57:20.580
Нет, я видел, как заполняют нопами.

57:20.880 --> 57:22.740
Я видел и N3, и видел нопы.

57:23.320 --> 57:26.840
Ну, когда я встал, это заполнение в том месте,

57:27.100 --> 57:30.460
которое рассчитано на то, что его будут исполнять.

57:30.820 --> 57:35.960
А N3 это заполнение, которое рассчитано, что его не будут исполнять.

57:36.520 --> 57:39.460
Например, вот эти дырки между функциями.

57:40.580 --> 57:45.620
Вот там рассчитано на то, что туда при нормальном исполнении ты не попадешь.

57:46.520 --> 57:49.440
Если говорить про выравнивание внутри функции,

57:49.800 --> 57:50.940
то, конечно, это нопа.

57:53.400 --> 57:56.240
Ну, кстати говоря, это не единственная форма нопа.

57:57.020 --> 58:01.960
Нопа есть, ну, как уже некоторое время назад добавили,

58:02.400 --> 58:06.520
еще всякие такие многобайтовые формы.

58:08.140 --> 58:10.340
Вы можете считать мультибайт.

58:10.580 --> 58:15.940
Ну, командочки, которые делают ноп, ну, кодируются большим числом байтиков

58:16.340 --> 58:22.380
для того, чтобы не спамить много команд, а использовать более жирные команды.

58:22.740 --> 58:23.940
Ну, такое тоже встречается.

58:26.760 --> 58:31.100
Почему именно N3, а не запланированная команда невалидная,

58:31.240 --> 58:34.900
которая делает действия, которые приводят к крашу?

58:35.380 --> 58:38.620
Ну, N3 тоже приводит к крашу, если у тебя отрядчик не подключен.

58:40.580 --> 58:46.080
То есть, если отрядчик подключен, оно цивилизованно вываливается в отрядчик.

58:46.580 --> 58:51.580
Так что, с точки зрения того, чтобы покрашиться, N3 без отрядчика себя также крашит.

58:52.580 --> 58:57.580
Поэтому не забывайте убирать N3 из кода, если вы его используете.

58:59.580 --> 59:01.580
Без отрядчика N3 крашит.

59:03.580 --> 59:06.580
Ну, можно еще и сектор ханда поставить.

59:07.580 --> 59:08.580
Система зависит.

59:10.580 --> 59:16.580
Так, это были регистры.

59:18.580 --> 59:23.580
Следующий важный вопрос, который нужно посмотреть, это адресация.

59:40.580 --> 59:49.580
Сейчас я вам нарисую третью великую табличку.

59:50.580 --> 59:55.580
Про то, как можно адресоваться через различные видные регистры.

59:56.580 --> 59:57.580
Она выглядит так.

01:00:03.580 --> 01:00:07.580
На первой позиции может быть любой регистр общего назначения.

01:00:07.580 --> 01:00:30.580
Например, плюс на втором что угодно, кроме РСП, умножить на, как и раньше, плюс...

01:00:31.580 --> 01:00:33.580
Давайте набор всех.

01:00:37.580 --> 01:00:38.580
Вот так.

01:00:57.580 --> 01:01:01.580
Да, construction pointer теперь называется A.

01:01:03.580 --> 01:01:06.580
И даже можно участвовать в адресации.

01:01:07.580 --> 01:01:09.580
Это касается и относительной адресации.

01:01:12.580 --> 01:01:14.580
Ну вот, давайте посмотрим на эту картинку.

01:01:15.580 --> 01:01:22.580
У нее есть исключения, но вот это вот то, что случается почти всегда.

01:01:26.580 --> 01:01:31.580
Во-первых, то, что было в 32 битах, оно практически остается.

01:01:33.580 --> 01:01:36.580
Вы можете использовать новый регистр общего назначения

01:01:36.580 --> 01:01:38.580
без всяких уменьшений.

01:01:38.580 --> 01:01:40.580
Так же, как и раньше.

01:01:40.580 --> 01:01:41.580
Все то же самое.

01:01:41.580 --> 01:01:45.580
Второй аргумент можно умножить на 2, 4, 8.

01:01:45.580 --> 01:01:47.580
Можно не умножать.

01:01:47.580 --> 01:01:49.580
Какие особенности?

01:01:49.580 --> 01:01:50.580
Особенность номер один.

01:01:50.580 --> 01:01:53.580
Обратите внимание на смещение.

01:01:55.580 --> 01:01:57.580
32 битное смещение.

01:01:58.580 --> 01:02:04.580
На самом деле, эта печальная история вообще справедлива для всех команд.

01:02:04.580 --> 01:02:05.580
За исключением двух.

01:02:05.580 --> 01:02:14.580
За исключением двух команд нигде абсолютно нет 64-битных константов.

01:02:15.580 --> 01:02:19.580
То есть все константы, которые вы можете указать в командах,

01:02:20.580 --> 01:02:25.580
за исключением двух команд, 32-битные максимум.

01:02:27.580 --> 01:02:34.580
То есть, например, сказать ADD регистр, запятая 64-битная константа невозможно.

01:02:36.580 --> 01:02:40.580
Константы не расширены до 64-битных.

01:02:43.580 --> 01:02:49.580
И в адресах также вот эта вот константа, она 32-битная максимум.

01:02:52.580 --> 01:02:54.580
При том, сознательно или беззнательно.

01:02:55.580 --> 01:02:57.580
Какой ответ был раньше?

01:02:57.580 --> 01:02:58.580
Неважный.

01:02:58.580 --> 01:02:59.580
Неважный.

01:02:59.580 --> 01:03:00.580
А теперь ответ?

01:03:00.580 --> 01:03:01.580
Важный.

01:03:01.580 --> 01:03:02.580
И сознательный.

01:03:02.580 --> 01:03:06.580
Потому что видимость константы меньше видимости адреса.

01:03:06.580 --> 01:03:09.580
Поэтому как константы расширяются, важно.

01:03:09.580 --> 01:03:12.580
И константы расширяются как число со знаками.

01:03:12.580 --> 01:03:21.580
Вы можете адресовываться на плюс-минус 2 гигабайта относительно адреса заданного регистром.

01:03:23.580 --> 01:03:31.580
Кроме того, вместо первой части, где у вас регистры, может выступать регистр RIP.

01:03:32.580 --> 01:03:35.580
RIP это ваше текущее положение.

01:03:35.580 --> 01:03:41.580
Даже более точно, это адрес начала следующей команды за вашей командой.

01:03:44.580 --> 01:03:54.580
И поэтому в 64-битном мире адресация, как всяким константам и подобным вещам, она обычно RIP-относительная.

01:03:54.580 --> 01:04:00.580
Потому что ваши константы, они скорее всего находятся недалеко от вас.

01:04:00.580 --> 01:04:01.580
Поэтому вы можете...

01:04:02.580 --> 01:04:10.580
Вы можете через небольшое смещение относительно вашей позиции до них добраться.

01:04:10.580 --> 01:04:16.580
Обращение по абсолютному адресу в 64-битном мире очень затруднено.

01:04:20.580 --> 01:04:22.580
Еще раз.

01:04:22.580 --> 01:04:26.580
64-битные команды почти нигде не используются.

01:04:26.580 --> 01:04:28.580
Есть только два исключения.

01:04:28.580 --> 01:04:30.580
Вот запишите себе эти исключения.

01:04:32.580 --> 01:04:56.580
Во-первых, 64-битные константы можно использовать в команде mov.

01:04:56.580 --> 01:05:00.580
reg64.const64.

01:05:00.580 --> 01:05:10.580
То есть, чтобы записать в 64-битный регистр 64-битную константу.

01:05:10.580 --> 01:05:18.580
И второе исключение это mov.

01:05:18.580 --> 01:05:24.580
...

01:05:24.580 --> 01:05:28.580
В обратную сторону тоже можно.

01:05:28.580 --> 01:05:32.580
Где аккумулятор это...

01:05:42.580 --> 01:05:52.580
То есть, вы можете прочитать или записать аккумулятор по адресу 64-битной константы.

01:05:52.580 --> 01:05:54.580
...

01:05:54.580 --> 01:05:56.580
И это единственные команды,

01:05:56.580 --> 01:06:00.580
которые оперируют 64-битными числами.

01:06:00.580 --> 01:06:04.580
В смысле, значениями, заданными в коде команды.

01:06:04.580 --> 01:06:08.580
Все остальные константы, которые вы используете,

01:06:08.580 --> 01:06:12.580
они все максимум 32-битные.

01:06:16.580 --> 01:06:18.580
Вот такая печальная история.

01:06:20.580 --> 01:06:22.580
Почему это важно?

01:06:22.580 --> 01:06:24.580
Потому что

01:06:24.580 --> 01:06:26.580
нередко то, что вы использовали,

01:06:26.580 --> 01:06:28.580
было константами.

01:06:28.580 --> 01:06:30.580
Например,

01:06:30.580 --> 01:06:32.580
когда вы писали

01:06:32.580 --> 01:06:34.580
push

01:06:34.580 --> 01:06:36.580
push

01:06:36.580 --> 01:06:38.580
push

01:06:38.580 --> 01:06:40.580
метка.

01:06:40.580 --> 01:06:42.580
Что такое метка?

01:06:42.580 --> 01:06:44.580
Это константа.

01:06:44.580 --> 01:06:46.580
Это константа.

01:06:46.580 --> 01:06:48.580
Просто эту константу

01:06:48.580 --> 01:06:50.580
вычисляет компилятор

01:06:50.580 --> 01:06:52.580
во время компиляции,

01:06:52.580 --> 01:06:54.580
где эта метка

01:06:54.580 --> 01:06:56.580
расположится в памяти.

01:06:56.580 --> 01:06:58.580
Соответственно, теперь

01:06:58.580 --> 01:07:00.580
такая команда невозможна.

01:07:00.580 --> 01:07:02.580
Потому что

01:07:02.580 --> 01:07:04.580
ваша метка расположится в памяти

01:07:04.580 --> 01:07:06.580
где-то по 64-битному адресу.

01:07:08.580 --> 01:07:10.580
А запушить

01:07:10.580 --> 01:07:12.580
вот здесь

01:07:12.580 --> 01:07:14.580
вы можете указать только

01:07:14.580 --> 01:07:16.580
32-битное значение.

01:07:18.580 --> 01:07:20.580
Понятно?

01:07:20.580 --> 01:07:22.580
Поэтому вот так вот запушить

01:07:22.580 --> 01:07:24.580
адрес метки

01:07:24.580 --> 01:07:26.580
невозможно.

01:07:28.580 --> 01:07:30.580
Все, что вы можете сделать,

01:07:30.580 --> 01:07:32.580
это movregister, запятая метка,

01:07:32.580 --> 01:07:34.580
потом pushregister,

01:07:34.580 --> 01:07:36.580
и то там есть особенности.

01:07:40.580 --> 01:07:42.580
Как правило,

01:07:42.580 --> 01:07:44.580
movregister

01:07:44.580 --> 01:07:48.160
таб.

01:07:51.160 --> 01:07:53.380
Атак, London?

01:07:53.380 --> 01:07:54.180
Да.

01:07:54.180 --> 01:07:54.800
Так!

01:07:54.900 --> 01:07:55.640
Пин MTG резка!

01:07:55.640 --> 01:07:57.380
Потом кичу!

01:07:57.380 --> 01:07:59.420
Так потенциально можно!

01:07:59.420 --> 01:08:00.420
Но так, честно говоря,

01:08:00.420 --> 01:08:02.580
не очень хорошо

01:08:02.580 --> 01:08:04.340
в связи

01:08:04.340 --> 01:08:06.460
с некоторыми доступными

01:08:06.460 --> 01:08:06.980
как оно компилируется

01:08:06.980 --> 01:08:08.260
или линкуется

01:08:09.100 --> 01:08:10.580
ize the location.

01:08:10.580 --> 01:08:12.580
Вы хотите писать

01:08:12.580 --> 01:08:13.160
вот так.

01:08:14.580 --> 01:08:34.100
И, да, я не помню, какой дефолт у нас, ясно, у нас не совсем правильный дефолт.

01:08:34.100 --> 01:08:37.360
Вначале нужно сказать еще где.

01:08:41.200 --> 01:08:43.820
Нужно ли это говорить на основе, не помню.

01:08:44.580 --> 01:08:47.120
Надо посмотреть, про что это.

01:08:47.620 --> 01:08:53.000
Про то, что когда вы в дефолтере в режиме указываете метку,

01:08:53.420 --> 01:08:57.560
то метка компилируется не как адрес этой метки,

01:08:57.560 --> 01:09:11.800
а как rip плюс смещение относительно адреса следующей команды.

01:09:12.100 --> 01:09:13.840
И вот это то, что вы хотите.

01:09:14.580 --> 01:09:17.200
Вы хотите вот такую форму вот здесь.

01:09:23.680 --> 01:09:26.680
То есть, ясно, нужно было точно говорить дефолт, реал.

01:09:27.220 --> 01:09:30.280
А вот у нас, ну, какой дефолт, реал, не реал, я не помню.

01:09:30.280 --> 01:09:34.620
И вот это, чтобы пихать на 64-х метрах.

01:09:35.420 --> 01:09:37.160
Чтобы ее как-то использовать, да.

01:09:37.860 --> 01:09:40.780
Вернее, это вот, смотри, вот это ваша метка,

01:09:41.580 --> 01:09:44.560
которая располагается где-то недалеко от вас.

01:09:44.580 --> 01:09:55.940
Да, конечно.

01:09:56.660 --> 01:09:58.040
Вот, справа табличка.

01:09:59.980 --> 01:10:03.780
Но это предсказуемое смещение относительно rip

01:10:03.780 --> 01:10:06.060
обычно то, что вы хотите.

01:10:06.980 --> 01:10:09.660
Потому что эта метка располагается, скорее всего,

01:10:09.760 --> 01:10:12.260
ну, не дальше, чем 2 гигабайта от вашего кода.

01:10:13.260 --> 01:10:14.560
Если вы пишете данную метку.

01:10:14.580 --> 01:10:17.840
Что исполняемую, конечно, библиотеку.

01:10:18.540 --> 01:10:21.600
Он явно имеет размеры меньше, чем 2 гигабайта.

01:10:22.120 --> 01:10:24.260
Поэтому относительно кода, если вы шагнете,

01:10:24.420 --> 01:10:27.520
пусть будет 2 гигабайта, будет 0.

01:10:28.120 --> 01:10:29.240
Какой вопрос?

01:10:29.600 --> 01:10:32.740
Можно ли просто обстоять размеры, если это 4 гигабайта?

01:10:33.860 --> 01:10:34.540
Нет.

01:10:35.080 --> 01:10:36.260
Там присутствует некая форма.

01:10:40.820 --> 01:10:44.060
В некоторых командах есть возможность

01:10:44.580 --> 01:10:47.340
использования более коротких констант.

01:10:47.340 --> 01:10:49.140
Например, адресат.

01:10:49.140 --> 01:10:53.340
Там есть форма с 8-битыми константами.

01:10:53.340 --> 01:10:56.080
Если ваша константа умещается в 8 бит,

01:10:56.080 --> 01:10:59.580
будет использована короткая форма, константа.

01:10:59.580 --> 01:11:04.340
Но, например, там какой-нибудь mov, константа,

01:11:04.340 --> 01:11:07.340
там будет полная форма без сокращения.

01:11:09.340 --> 01:11:12.340
Ну и на самом деле это не так уж критично.

01:11:14.580 --> 01:11:20.340
Конечно, имеет смысл экономить размер кода,

01:11:20.340 --> 01:11:23.340
но там, где оно бесплатно остается.

01:11:23.340 --> 01:11:30.340
Но если бы каждая вторая команда мог по автосету относительно RDI

01:11:30.340 --> 01:11:32.340
на число меньше, чем 1 байт?

01:11:32.340 --> 01:11:33.340
Нет.

01:11:33.340 --> 01:11:37.340
Но у меня пример буквально такой есть.

01:11:37.340 --> 01:11:39.340
Какой-то странный пример.

01:11:39.340 --> 01:11:41.340
Почему вы хотели транспайлер?

01:11:41.340 --> 01:11:43.340
Не знаю.

01:11:43.340 --> 01:11:46.340
Внутренности должны как-то активизироваться.

01:11:46.340 --> 01:11:48.340
А нужно ли?

01:11:48.340 --> 01:11:52.340
Ну, вообще, если так массово, то да, может.

01:11:53.340 --> 01:11:56.340
Ускорить-то, конечно, но только нужно ли ускорять?

01:11:56.340 --> 01:12:00.340
Ну, это уже не взрослый вопрос.

01:12:02.340 --> 01:12:04.340
Итак, понятно?

01:12:06.340 --> 01:12:08.340
А, и еще такой вопрос.

01:12:08.340 --> 01:12:12.340
Можно ли указать регистр не 64-битные, а 13-битные в адресе?

01:12:13.340 --> 01:12:15.340
Еще раз.

01:12:15.340 --> 01:12:22.340
У вас есть адресация 32-битная, 16-битная и 64-битная.

01:12:22.340 --> 01:12:26.340
Вы можете использовать в 64-битном режиме

01:12:26.340 --> 01:12:29.340
32-битную адресацию?

01:12:29.340 --> 01:12:30.340
Зачем?

01:12:30.340 --> 01:12:32.340
А мешать их внутренности?

01:12:32.340 --> 01:12:33.340
Нет.

01:12:33.340 --> 01:12:38.340
Ну, вот, смотри, здесь нет возможности указать регистры разной длительности.

01:12:38.340 --> 01:12:41.340
Просто у меня, видимо, бета-ассемблер,

01:12:41.340 --> 01:12:46.340
считающий, что uax, смешанный с rdi, это rax плюс rdi.

01:12:46.340 --> 01:12:49.340
Ну, да, это он так проявил интеллект,

01:12:49.340 --> 01:12:52.340
что, типа, видимо, хотел все равно,

01:12:52.340 --> 01:12:55.340
а аккумулятор, то есть, назвал его неправильно,

01:12:55.340 --> 01:13:00.340
поэтому мы его, как бы, автоматически проапгрейдим.

01:13:01.340 --> 01:13:02.340
Сейчас.

01:13:03.340 --> 01:13:05.340
Интересное замечание.

01:13:07.340 --> 01:13:10.340
Что еще можно сказать?

01:13:11.340 --> 01:13:20.340
Так.

01:13:20.340 --> 01:13:22.340
Ну, теперь...

01:13:22.340 --> 01:13:25.340
Да, есть еще интересные вещи.

01:13:29.340 --> 01:13:34.340
А именно, вот переход в 64-бита,

01:13:34.340 --> 01:13:37.340
также AMD-шники...

01:13:39.340 --> 01:13:41.340
Поэтому можно...

01:13:41.340 --> 01:13:46.340
Пусть чуть ли не слегка почистить обходы.

01:13:46.340 --> 01:13:50.340
А именно все вот эти новые расширения команд,

01:13:50.340 --> 01:13:52.340
они, конечно, очень страдают.

01:13:52.340 --> 01:13:53.340
Почему?

01:13:53.340 --> 01:13:55.340
Потому что их надо кодировать.

01:13:56.340 --> 01:14:00.340
А коротких кодов давно уже не осталось.

01:14:00.340 --> 01:14:03.340
Так мы же говорили про это, когда...

01:14:03.340 --> 01:14:04.340
Сейчас скажу.

01:14:04.340 --> 01:14:06.340
Когда добавляли prefix-refix, нет?

01:14:06.340 --> 01:14:07.340
Нет.

01:14:07.340 --> 01:14:14.340
Префикс — это про добавление вообще, как бы, поведения к обычным командам.

01:14:14.340 --> 01:14:17.340
А я говорю про добавление команд.

01:14:18.340 --> 01:14:21.340
То есть то, что вот мы дальше рассмотрим,

01:14:21.340 --> 01:14:23.340
всякие там сиф-команды,

01:14:23.340 --> 01:14:27.340
всякие AVX-512 и прочие,

01:14:27.340 --> 01:14:29.340
вот эти все модные штучки,

01:14:29.340 --> 01:14:31.340
они требуют новых кодов.

01:14:31.340 --> 01:14:33.340
Для новых именно команд.

01:14:33.340 --> 01:14:35.340
Не просто для новой формы старых команд,

01:14:35.340 --> 01:14:36.340
а для новой команды.

01:14:37.340 --> 01:14:40.340
И вот эти вот новые формы команд,

01:14:40.340 --> 01:14:42.340
то есть новые команды,

01:14:42.340 --> 01:14:44.340
откуда взять им новые коды?

01:14:44.340 --> 01:14:48.340
Потому что коды давно кончились.

01:14:48.340 --> 01:14:52.340
Поэтому приходится использовать кучу всяких префиксов.

01:14:52.340 --> 01:14:55.340
Префикс такой, префикс такой,

01:14:55.340 --> 01:14:59.340
и теперь у нас есть немножко кодового пространства,

01:14:59.340 --> 01:15:01.340
которое еще не занято.

01:15:01.340 --> 01:15:05.340
Поэтому новые команды, они нередко очень длинные

01:15:05.340 --> 01:15:06.340
по своему тому.

01:15:07.340 --> 01:15:09.340
Другой стороны,

01:15:09.340 --> 01:15:12.340
в базовом наборе таких коротких команд

01:15:12.340 --> 01:15:15.340
существует довольно немало команд,

01:15:15.340 --> 01:15:18.340
которые никому нафиг давно не нужны.

01:15:18.340 --> 01:15:21.340
И AVD-шники по поводу того,

01:15:21.340 --> 01:15:23.340
что у нас новый режим работает,

01:15:23.340 --> 01:15:27.340
соответственно, у нас нет совместимости ни с каким софтом,

01:15:27.340 --> 01:15:30.340
решили, что это прекрасное время

01:15:30.340 --> 01:15:34.340
почистить и некоторые команды выкинуть.

01:15:34.340 --> 01:15:36.340
То есть эти команды,

01:15:36.340 --> 01:15:39.340
они по-прежнему существуют и работают,

01:15:39.340 --> 01:15:43.340
как и раньше работали в текстовом битовом режиме,

01:15:43.340 --> 01:15:46.340
но из шифинического битового режима их выкинули,

01:15:46.340 --> 01:15:48.340
их коды почистили.

01:15:48.340 --> 01:15:52.340
Теперь эти коды этим командам не соответствуют.

01:15:52.340 --> 01:15:56.340
И эти коды можно использовать под что-нибудь,

01:15:56.340 --> 01:15:58.340
ну, такой резерв на будущее.

01:15:58.340 --> 01:16:00.340
Что это за команды?

01:16:00.340 --> 01:16:03.340
Во-первых, это группа команд,

01:16:03.340 --> 01:16:05.340
так называемые двоичные команды,

01:16:05.340 --> 01:16:08.340
двоично-десятичные реплики.

01:16:23.340 --> 01:16:27.340
Это такие команды, как

01:16:27.340 --> 01:16:30.340
va-a-a,

01:16:30.340 --> 01:16:32.340
есть такая команда,

01:16:35.340 --> 01:16:36.340
да.

01:16:36.340 --> 01:16:38.340
Раньше, когда открывались документации,

01:16:38.340 --> 01:16:40.340
это была первая команда,

01:16:40.340 --> 01:16:42.340
которую вы видите.

01:16:42.340 --> 01:16:44.340
a-a-m,

01:16:44.340 --> 01:16:46.340
das

01:16:46.340 --> 01:16:48.340
и подобные.

01:16:48.340 --> 01:16:51.340
Там их, по-моему, было.

01:16:51.340 --> 01:16:53.340
Про что это?

01:16:53.340 --> 01:16:54.340
Как я вам сказал,

01:16:54.340 --> 01:16:57.340
про так называемую двоично-десятичную ритмичку.

01:16:57.340 --> 01:16:59.340
Кто-нибудь в курсе чего-нибудь?

01:16:59.340 --> 01:17:01.340
Ну, для часов.

01:17:01.340 --> 01:17:03.340
Что?

01:17:03.340 --> 01:17:07.340
Для часов, там уже, типа, 10 цифр используются.

01:17:07.340 --> 01:17:11.340
При этом хочется быстро поучаствовать.

01:17:11.340 --> 01:17:13.340
Ну, смотрите.

01:17:13.340 --> 01:17:18.340
Это система, где каждый байт

01:17:22.340 --> 01:17:25.340
используется для кодирования

01:17:25.340 --> 01:17:27.340
одной десятичной.

01:17:27.340 --> 01:17:30.340
двух десятичных цифр.

01:17:30.340 --> 01:17:31.340
Да.

01:17:31.340 --> 01:17:34.340
Binary coded decim.

01:17:34.340 --> 01:17:37.340
То есть это десятичное число,

01:17:37.340 --> 01:17:40.340
которое закодировано в двоичной системе.

01:17:40.340 --> 01:17:43.340
То есть у вас каждый байтинг

01:17:43.340 --> 01:17:47.340
имеет значение от 0 до 99.

01:17:53.340 --> 01:17:57.340
И в исходном наборе x86

01:17:57.340 --> 01:17:59.340
были команды, которые

01:17:59.340 --> 01:18:01.340
помогали среди людей,

01:18:01.340 --> 01:18:03.340
с ритмитикой такой формы.

01:18:03.340 --> 01:18:05.340
В зависимости от того,

01:18:05.340 --> 01:18:07.340
что вы за командой делаете,

01:18:07.340 --> 01:18:09.340
там происходила

01:18:09.340 --> 01:18:11.340
либо коррекция до,

01:18:11.340 --> 01:18:13.340
либо коррекция после операции.

01:18:13.340 --> 01:18:15.340
То есть там в зависимости от того,

01:18:15.340 --> 01:18:17.340
как вы делаете сложение

01:18:17.340 --> 01:18:19.340
или умножение,

01:18:19.340 --> 01:18:21.340
вам нужно было

01:18:21.340 --> 01:18:23.340
поставить вот эту команду

01:18:23.340 --> 01:18:25.340
до или после этой ритмической команды

01:18:25.340 --> 01:18:27.340
с такими числами,

01:18:27.340 --> 01:18:29.340
чтобы получился результат

01:18:29.340 --> 01:18:31.340
снова в такой же форме.

01:18:31.340 --> 01:18:33.340
Ну, костыли, ужас.

01:18:33.340 --> 01:18:35.340
Да, да.

01:18:35.340 --> 01:18:37.340
Вот эти костыли,

01:18:37.340 --> 01:18:39.340
они доблестно сохранялись

01:18:39.340 --> 01:18:41.340
в системе команд.

01:18:41.340 --> 01:18:43.340
Конечно, они были реализованы

01:18:43.340 --> 01:18:45.340
не в железе, а в микрокоде,

01:18:45.340 --> 01:18:47.340
но тем не менее

01:18:47.340 --> 01:18:49.340
они доблестно работали.

01:18:49.340 --> 01:18:51.340
И вот сейчас эти команды

01:18:51.340 --> 01:18:53.340
таки наконец выкинули,

01:18:53.340 --> 01:18:55.340
чтобы освободить их коды

01:18:55.340 --> 01:18:57.340
под что-то ложненькое.

01:18:57.340 --> 01:18:59.340
Вот.

01:18:59.340 --> 01:19:01.340
Ничего не хочется использовать

01:19:01.340 --> 01:19:03.340
огромные коды

01:19:03.340 --> 01:19:05.340
с 10 префиксами,

01:19:05.340 --> 01:19:07.340
как для других вещей.

01:19:07.340 --> 01:19:09.340
Потом выкинули команды.

01:19:09.340 --> 01:19:11.340
Так это вообще бесполезные команды,

01:19:11.340 --> 01:19:13.340
их в компилятор никогда не сгенерят.

01:19:13.340 --> 01:19:15.340
Да.

01:19:15.340 --> 01:19:17.340
Это не значит,

01:19:17.340 --> 01:19:19.340
что их никто не использует.

01:19:19.340 --> 01:19:21.340
Да, очень много такого.

01:19:21.340 --> 01:19:23.340
Системы защиты!

01:19:23.340 --> 01:19:25.340
Пусть спокоен.

01:19:25.340 --> 01:19:27.340
Наверняка это кто-то использует.

01:19:27.340 --> 01:19:29.340
Да.

01:19:29.340 --> 01:19:31.340
Да, они просто обожают

01:19:31.340 --> 01:19:33.340
всякие извращенные команды,

01:19:33.340 --> 01:19:35.340
чтобы усложнить вам реверс

01:19:35.340 --> 01:19:37.340
того, что у них происходит.

01:19:37.340 --> 01:19:39.340
Поэтому не волнуйтесь,

01:19:39.340 --> 01:19:41.340
даже самые извращенные команды

01:19:41.340 --> 01:19:43.340
наверняка кому-то нужны.

01:19:43.340 --> 01:19:45.340
А как же вот это сообщество людей,

01:19:45.340 --> 01:19:47.340
которые пишут нечитабельный код?

01:19:47.340 --> 01:19:49.340
Нет, это не нечитабельный код,

01:19:49.340 --> 01:19:51.340
это специально

01:19:51.340 --> 01:19:53.340
запрещенный код.

01:19:53.340 --> 01:19:55.340
А как же это сообщество людей,

01:19:55.340 --> 01:19:57.340
которые пишут нечитабельный код?

01:19:57.340 --> 01:19:59.340
Специально

01:19:59.340 --> 01:20:01.340
запутывание.

01:20:01.340 --> 01:20:03.340
Нечитабельный код потом компилируется

01:20:03.340 --> 01:20:05.340
во что-то нормальное,

01:20:05.340 --> 01:20:07.340
но такое он не будет компилироваться.

01:20:07.340 --> 01:20:09.340
Да, это немножко про другое.

01:20:09.340 --> 01:20:11.340
Так вот, bound и int.

01:20:11.340 --> 01:20:13.340
Что это такое?

01:20:13.340 --> 01:20:15.340
Это команды, которые могут

01:20:15.340 --> 01:20:17.340
сгенерировать вам

01:20:17.340 --> 01:20:19.340
исключения, аппаратные исключения,

01:20:19.340 --> 01:20:21.340
а не плюсовые.

01:20:21.340 --> 01:20:23.340
В зависимости от чего.

01:20:23.340 --> 01:20:25.340
Например, bound предназначалось

01:20:25.340 --> 01:20:27.340
для проверки

01:20:27.340 --> 01:20:29.340
границ индексов, массивов,

01:20:29.340 --> 01:20:31.340
что типа вы там записываете

01:20:31.340 --> 01:20:33.340
границу куда-то,

01:20:33.340 --> 01:20:35.340
потом индекс куда-то,

01:20:35.340 --> 01:20:37.340
делаете команду bound,

01:20:37.340 --> 01:20:39.340
и если индекс не попадает в этот диапазон,

01:20:39.340 --> 01:20:41.340
то эта команда генерирует

01:20:41.340 --> 01:20:43.340
исключения.

01:20:43.340 --> 01:20:45.340
Но

01:20:45.340 --> 01:20:47.340
в современном мире

01:20:47.340 --> 01:20:49.340
генерируются исключения,

01:20:49.340 --> 01:20:51.340
это последнее, что вы хотите.

01:20:51.340 --> 01:20:53.340
Потому что это дико медленно,

01:20:53.340 --> 01:20:55.340
и там все вот эти границы

01:20:55.340 --> 01:20:57.340
более 16-пильные.

01:20:57.340 --> 01:20:59.340
Абсолютно бесполезная команда

01:20:59.340 --> 01:21:01.340
по современным меркам

01:21:01.340 --> 01:21:03.340
в ту же сторону.

01:21:09.340 --> 01:21:11.340
Вот, может быть, расширение

01:21:11.340 --> 01:21:13.340
на хоряло

01:21:13.340 --> 01:21:15.340
получилось

01:21:15.340 --> 01:21:17.340
интересным.

01:21:17.340 --> 01:21:19.340
Но в 32-пильном мире

01:21:19.340 --> 01:21:21.340
просто уже никто не использует эту команду.

01:21:21.340 --> 01:21:23.340
В 16-пильном когда-то ее использовали,

01:21:23.340 --> 01:21:25.340
а чтобы это использовать

01:21:25.340 --> 01:21:27.340
в 32-пильном мире, неразумно.

01:21:27.340 --> 01:21:29.340
Ну, еще раз,

01:21:29.340 --> 01:21:31.340
чтобы ее кто-то использовал,

01:21:31.340 --> 01:21:33.340
я не разу не видел.

01:21:33.340 --> 01:21:35.340
Может быть, ее действительно

01:21:35.340 --> 01:21:37.340
честно расширили,

01:21:37.340 --> 01:21:39.340
но в 1286-м

01:21:39.340 --> 01:21:41.340
никого она не использовала.

01:21:41.340 --> 01:21:43.340
Вот.

01:21:43.340 --> 01:21:45.340
Потом

01:21:45.340 --> 01:21:47.340
довольно полезная

01:21:47.340 --> 01:21:49.340
команда

01:21:49.340 --> 01:21:51.340
S-A-L-C,

01:21:51.340 --> 01:21:53.340
у которого

01:21:53.340 --> 01:21:55.340
есть

01:21:55.340 --> 01:21:57.340
команды,

01:21:57.340 --> 01:21:59.340
которые долгое время

01:21:59.340 --> 01:22:01.340
вообще не признавали ее существованием.

01:22:01.340 --> 01:22:03.340
То есть она была долго

01:22:03.340 --> 01:22:05.340
недокументированной командой,

01:22:05.340 --> 01:22:07.340
которой в документации

01:22:07.340 --> 01:22:09.340
не значилось, но

01:22:09.340 --> 01:22:11.340
про нее, наверное, было известно.

01:22:11.340 --> 01:22:13.340
Вообще, команда довольно прикольная,

01:22:13.340 --> 01:22:15.340
которая ставит А-Л

01:22:15.340 --> 01:22:17.340
всей витики

01:22:17.340 --> 01:22:19.340
в то состояние, которое имеет

01:22:19.340 --> 01:22:21.340
флаг C-F.

01:22:21.340 --> 01:22:23.340
То есть она ставит А-Л

01:22:23.340 --> 01:22:25.340
то, ну, довольно прикольно,

01:22:25.340 --> 01:22:27.340
потому что всякие команды,

01:22:27.340 --> 01:22:29.340
которые ставят

01:22:29.340 --> 01:22:31.340
регистр состояния

01:22:31.340 --> 01:22:33.340
в зависимости от флагов,

01:22:33.340 --> 01:22:35.340
они обычно ставят 0 или 1.

01:22:35.340 --> 01:22:37.340
А эта штука ставит 0

01:22:37.340 --> 01:22:39.340
или FF,

01:22:39.340 --> 01:22:41.340
поэтому ей пользовались.

01:22:41.340 --> 01:22:43.340
Ну, вот ее, например.

01:22:43.340 --> 01:22:45.340
S-A-L-L?

01:22:45.340 --> 01:22:47.340
Ну, это для C-F.

01:22:47.340 --> 01:22:49.340
А для C-F есть?

01:22:49.340 --> 01:22:51.340
Ну, в принципе, да.

01:22:51.340 --> 01:22:53.340
Ну, в принципе, да.

01:22:53.340 --> 01:22:55.340
Она, не знаю,

01:22:55.340 --> 01:22:57.340
сладенькая, что-то такое.

01:22:57.340 --> 01:22:59.340
Была какая-то особенность,

01:22:59.340 --> 01:23:01.340
почему ее много людей использовали.

01:23:01.340 --> 01:23:03.340
А вот следующая будет

01:23:03.340 --> 01:23:05.340
у нас в чайнике.

01:23:23.340 --> 01:23:25.340
Пуша-пупа выкинуть.

01:23:25.340 --> 01:23:27.340
Пуша-пупа выкинуть.

01:23:27.340 --> 01:23:29.340
То есть теперь

01:23:29.340 --> 01:23:31.340
нет команды сохранить

01:23:31.340 --> 01:23:33.340
все регистры

01:23:33.340 --> 01:23:35.340
общего назначения

01:23:35.340 --> 01:23:37.340
в стэк одной команды.

01:23:37.340 --> 01:23:39.340
Вместо того, чтобы

01:23:39.340 --> 01:23:41.340
расширять старые

01:23:41.340 --> 01:23:43.340
пуша-пупа на 16 регистров,

01:23:43.340 --> 01:23:45.340
они решили,

01:23:45.340 --> 01:23:47.340
что проще выберите

01:23:47.340 --> 01:23:49.340
и теперь

01:23:49.340 --> 01:23:51.340
нет такой проблемы.

01:23:51.340 --> 01:23:53.340
Ребята,

01:23:53.340 --> 01:23:55.340
когда нужно?

01:23:55.340 --> 01:23:57.340
Ну, редко, когда нужно,

01:23:57.340 --> 01:23:59.340
но студенты ее обычно любят.

01:23:59.340 --> 01:24:01.340
Почему?

01:24:01.340 --> 01:24:03.340
Потому что сохранить все регистры

01:24:03.340 --> 01:24:05.340
на всякий случай.

01:24:05.340 --> 01:24:07.340
Вы обращайте внимание,

01:24:07.340 --> 01:24:09.340
что выкинуть.

01:24:13.340 --> 01:24:15.340
Потом вы выкинули

01:24:15.340 --> 01:24:17.340
там некоторое количество команд,

01:24:17.340 --> 01:24:19.340
которые работают

01:24:19.340 --> 01:24:21.340
с сегментными регистрами,

01:24:21.340 --> 01:24:23.340
но до сегментных регистров

01:24:23.340 --> 01:24:25.340
их еще не нашли,

01:24:25.340 --> 01:24:27.340
поэтому я это поскидываю.

01:24:27.340 --> 01:24:29.340
Выкинули

01:24:29.340 --> 01:24:31.340
некоторые формы команды

01:24:31.340 --> 01:24:33.340
jump и pull.

01:24:45.340 --> 01:24:47.340
Абсолютно дальние

01:24:47.340 --> 01:24:49.340
переходы,

01:24:49.340 --> 01:24:51.340
но вы пока все равно не знаете,

01:24:51.340 --> 01:24:53.340
что это дальние переходы,

01:24:53.340 --> 01:24:55.340
причем и более.

01:24:55.340 --> 01:24:57.340
Передописные.

01:24:57.340 --> 01:24:59.340
Фар. Дальние.

01:25:03.340 --> 01:25:05.340
Там есть понятие

01:25:05.340 --> 01:25:07.340
называемых близких переходов

01:25:07.340 --> 01:25:09.340
и дальних переходов.

01:25:09.340 --> 01:25:11.340
Все переходы,

01:25:11.340 --> 01:25:13.340
которые вы пользовались,

01:25:13.340 --> 01:25:15.340
они все ближние.

01:25:15.340 --> 01:25:17.340
Про дальние переходы

01:25:17.340 --> 01:25:19.340
тоже сильно потом.

01:25:19.340 --> 01:25:21.340
Поэтому некоторые формы

01:25:21.340 --> 01:25:23.340
pull, jump,

01:25:23.340 --> 01:25:25.340
pull.

01:25:25.340 --> 01:25:27.340
Но это на самом деле

01:25:27.340 --> 01:25:29.340
хоть и печально.

01:25:29.340 --> 01:25:31.340
Вот это я почувствовал,

01:25:31.340 --> 01:25:33.340
что вообще хотелось.

01:25:33.340 --> 01:25:35.340
И из забавного

01:25:37.340 --> 01:25:39.340
выкинули команды

01:25:53.340 --> 01:25:55.340
C-Center, C-Z.

01:25:55.340 --> 01:25:57.340
Про что это?

01:25:59.340 --> 01:26:01.340
Мы, в принципе, упоминали,

01:26:01.340 --> 01:26:03.340
когда говорили про команды

01:26:03.340 --> 01:26:05.340
кинг, что через кинг

01:26:05.340 --> 01:26:07.340
это такой старый

01:26:07.340 --> 01:26:09.340
способ вызова

01:26:09.340 --> 01:26:11.340
ядра.

01:26:11.340 --> 01:26:13.340
Тяжелый,

01:26:13.340 --> 01:26:15.340
до сих пор еще как-то

01:26:15.340 --> 01:26:17.340
поддерживается, но не рекомендуется,

01:26:17.340 --> 01:26:19.340
потому что это

01:26:19.340 --> 01:26:21.340
не для него.

01:26:21.340 --> 01:26:23.340
Предназначенный для таких

01:26:23.340 --> 01:26:25.340
вещей, как прерывание

01:26:25.340 --> 01:26:27.340
от железа, а не чтобы

01:26:27.340 --> 01:26:29.340
по 100-500 раз

01:26:29.340 --> 01:26:31.340
взорвать ядро из лидер-спейса.

01:26:31.340 --> 01:26:33.340
Поэтому, для того, чтобы

01:26:33.340 --> 01:26:35.340
ускорить вот этот вот

01:26:35.340 --> 01:26:37.340
переход в ядро

01:26:37.340 --> 01:26:39.340
и возврат обратно,

01:26:39.340 --> 01:26:41.340
сделали специальные команды.

01:26:41.340 --> 01:26:43.340
Во-первых, сделали

01:26:43.340 --> 01:26:45.340
их интеловцы и назвали их

01:26:45.340 --> 01:26:47.340
C-Center, C-Exit.

01:26:47.340 --> 01:26:49.340
Что это за команды?

01:26:49.340 --> 01:26:51.340
Это команды без аргументов,

01:26:51.340 --> 01:26:53.340
которые делают

01:26:53.340 --> 01:26:55.340
джамп

01:26:55.340 --> 01:26:57.340
между уровнями перелегий

01:26:57.340 --> 01:26:59.340
из третьего кольца

01:26:59.340 --> 01:27:01.340
юзер-спейса в нулевое кольцо

01:27:01.340 --> 01:27:03.340
Kernel Space

01:27:03.340 --> 01:27:05.340
это C-Enter, и C-Exit

01:27:05.340 --> 01:27:07.340
это джамп обратно.

01:27:07.340 --> 01:27:09.340
В какое место они джампуют?

01:27:09.340 --> 01:27:11.340
Туда,

01:27:11.340 --> 01:27:13.340
куда настроено специальными

01:27:13.340 --> 01:27:15.340
MSR-регистрами.

01:27:15.340 --> 01:27:17.340
Мы говорили, что есть

01:27:17.340 --> 01:27:19.340
специальные машино-специфичные регистры,

01:27:19.340 --> 01:27:21.340
которые просто тучат.

01:27:21.340 --> 01:27:23.340
И вот

01:27:23.340 --> 01:27:25.340
два этих регистра

01:27:25.340 --> 01:27:27.340
определяют, куда переход

01:27:27.340 --> 01:27:29.340
по C-Center,

01:27:29.340 --> 01:27:31.340
куда переход по C-Exit.

01:27:31.340 --> 01:27:33.340
То есть это командный вид

01:27:33.340 --> 01:27:35.340
джамп в ядро,

01:27:35.340 --> 01:27:37.340
джамп обратно.

01:27:37.340 --> 01:27:39.340
AMD-шники

01:27:39.340 --> 01:27:41.340
сделали свой аналог

01:27:41.340 --> 01:27:43.340
для

01:27:43.340 --> 01:27:45.340
быстрого вызова ядра.

01:27:53.340 --> 01:27:55.340
Давайте я здесь напишу.

01:28:01.340 --> 01:28:03.340
Сейчас я вам это покажу.

01:28:03.340 --> 01:28:05.340
Здесь

01:28:05.340 --> 01:28:07.340
интересная история.

01:28:09.340 --> 01:28:11.340
AMD-шные, смотрите,

01:28:11.340 --> 01:28:13.340
командуют. Это...

01:28:21.340 --> 01:28:23.340
C-Cell.

01:28:23.340 --> 01:28:25.340
Это командный

01:28:25.340 --> 01:28:27.340
вид

01:28:27.340 --> 01:28:29.340
колл

01:28:29.340 --> 01:28:31.340
в ядро.

01:28:31.340 --> 01:28:33.340
То есть они также без аргументов

01:28:33.340 --> 01:28:35.340
в плане куда

01:28:35.340 --> 01:28:37.340
перейти.

01:28:37.340 --> 01:28:39.340
И куда переходит C-Cell

01:28:39.340 --> 01:28:41.340
определяется MSR-ом

01:28:41.340 --> 01:28:43.340
машино-специфичным регистром.

01:28:43.340 --> 01:28:45.340
Но C-Cell,

01:28:45.340 --> 01:28:47.340
в отличие от C-Enter,

01:28:47.340 --> 01:28:49.340
сохраняет на стеке адрес возврата,

01:28:49.340 --> 01:28:51.340
откуда из юзерспейса

01:28:51.340 --> 01:28:53.340
вы вызвали

01:28:53.340 --> 01:28:55.340
ядро.

01:28:55.340 --> 01:28:57.340
И C-Thread возвращает вас

01:28:57.340 --> 01:28:59.340
в это место.

01:28:59.340 --> 01:29:01.340
То есть интерфейс C-Enter, C-Exit

01:29:01.340 --> 01:29:03.340
требует, что у вас

01:29:03.340 --> 01:29:05.340
в юзерспейсе было фиксированное

01:29:05.340 --> 01:29:07.340
место, откуда вы

01:29:07.340 --> 01:29:09.340
вызываете ядро, и куда ядро

01:29:09.340 --> 01:29:11.340
возвращается.

01:29:11.340 --> 01:29:13.340
А C-Cell, C-Thread

01:29:13.340 --> 01:29:15.340
вы можете делать вот вызов

01:29:15.340 --> 01:29:17.340
ядра почти откуда угодно

01:29:17.340 --> 01:29:19.340
и не париться, чтобы

01:29:19.340 --> 01:29:21.340
вот ядро с юзерспейсом договорилось.

01:29:21.340 --> 01:29:23.340
Так что,

01:29:23.340 --> 01:29:25.340
вот, AMD-шники, конечно, поддержали

01:29:25.340 --> 01:29:27.340
Intel-овские команды, потому что

01:29:27.340 --> 01:29:29.340
они поддерживают все Intel-овское,

01:29:29.340 --> 01:29:31.340
и добавили свои команды.

01:29:31.340 --> 01:29:33.340
Угадайте, какие команды

01:29:33.340 --> 01:29:35.340
использовали красивые убитые

01:29:35.340 --> 01:29:37.340
операционки?

01:29:39.340 --> 01:29:41.340
Потому что они

01:29:41.340 --> 01:29:43.340
есть и на Intel-овских просах,

01:29:43.340 --> 01:29:45.340
и на AMD-шниках.

01:29:45.340 --> 01:29:47.340
Зачем писать вот под это,

01:29:47.340 --> 01:29:49.340
когда этих команд

01:29:49.340 --> 01:29:51.340
на Intel-овских просах нет?

01:29:51.340 --> 01:29:53.340
Intel-овцы, конечно, не ставят.

01:29:53.340 --> 01:29:55.340
Поэтому все пользовались

01:29:55.340 --> 01:29:57.340
этими командами.

01:29:57.340 --> 01:29:59.340
Поэтому, AMD-шники,

01:29:59.340 --> 01:30:01.340
когда

01:30:01.340 --> 01:30:03.340
вот разрабатывали 64-битное

01:30:03.340 --> 01:30:05.340
расширение, они сказали, что

01:30:05.340 --> 01:30:07.340
в 64-битном режиме

01:30:07.340 --> 01:30:09.340
эти команды

01:30:09.340 --> 01:30:11.340
выброшены, нет, они не

01:30:11.340 --> 01:30:13.340
работают.

01:30:13.340 --> 01:30:15.340
Соответственно, ядро

01:30:15.340 --> 01:30:17.340
только так можно вызывать,

01:30:17.340 --> 01:30:19.340
ну и через NT, ну NT понятно,

01:30:19.340 --> 01:30:21.340
и не очень интересно.

01:30:21.340 --> 01:30:23.340
А Intel-овцы, когда поддерживают

01:30:23.340 --> 01:30:25.340
AMD-шное расширение, они его поддерживали

01:30:25.340 --> 01:30:27.340
но целиком.

01:30:27.340 --> 01:30:29.340
Поэтому они и syscall, и sysread

01:30:29.340 --> 01:30:31.340
поддержали, но только

01:30:31.340 --> 01:30:33.340
в 64-битном режиме.

01:30:33.340 --> 01:30:35.340
Соответственно, на Intel-овских

01:30:35.340 --> 01:30:37.340
просах sysenter, sysexit

01:30:37.340 --> 01:30:39.340
работает и в 32, и в 64-бит.

01:30:39.340 --> 01:30:41.340
Поэтому ты сейчас читаешь

01:30:41.340 --> 01:30:43.340
Intel-овскую документацию.

01:30:43.340 --> 01:30:45.340
А на AMD-шных

01:30:45.340 --> 01:30:47.340
просах это

01:30:47.340 --> 01:30:49.340
существует только в 32-битном

01:30:49.340 --> 01:30:51.340
режиме, а это

01:30:51.340 --> 01:30:53.340
существует везде.

01:30:53.340 --> 01:30:55.340
Но таким образом,

01:30:55.340 --> 01:30:57.340
AMD-шники заставили 64-битные

01:30:57.340 --> 01:30:59.340
операционки использовать

01:30:59.340 --> 01:31:01.340
вот этот интерфейс

01:31:01.340 --> 01:31:03.340
для вызова ядра.

01:31:03.340 --> 01:31:05.340
Вот такой вот у них

01:31:05.340 --> 01:31:07.340
тройленд

01:31:07.340 --> 01:31:09.340
для ядра

01:31:09.340 --> 01:31:11.340
и пропихивания своих форм

01:31:11.340 --> 01:31:13.340
каналов.

01:31:13.340 --> 01:31:15.340
А еще раз, а почему Intel

01:31:15.340 --> 01:31:17.340
просто не использует?

01:31:17.340 --> 01:31:19.340
Медленно.

01:31:19.340 --> 01:31:21.340
Этот интерфейс гораздо быстрее, чем Intel.

01:31:23.340 --> 01:31:25.340
Ну и вообще,

01:31:25.340 --> 01:31:27.340
их пытаются, по-моему, выпилить

01:31:27.340 --> 01:31:29.340
из ядра, как они и Linux.

01:31:29.340 --> 01:31:31.340
Ну да.

01:31:31.340 --> 01:31:33.340
Я читал, что там

01:31:33.340 --> 01:31:35.340
хотят, ну если дохватно,

01:31:35.340 --> 01:31:37.340
то понятно, что дохватно,

01:31:37.340 --> 01:31:39.340
просто он этот факт по дефолту

01:31:39.340 --> 01:31:41.340
еще поддерживает, или по дефолту

01:31:41.340 --> 01:31:43.340
его уже переключили, уже нет.

01:31:43.340 --> 01:31:45.340
Ну да, хотят, но перетянуты,

01:31:45.340 --> 01:31:47.340
потому что это тяжелый интерфейс

01:31:47.340 --> 01:31:49.340
и практически не особо

01:31:49.340 --> 01:31:51.340
кому-то нужен.

01:31:51.340 --> 01:31:53.340
То есть нормальные программы

01:31:53.340 --> 01:31:55.340
используют либо просто

01:31:55.340 --> 01:31:57.340
вызов библиотек,

01:31:57.340 --> 01:31:59.340
которые уже идут в ядро,

01:31:59.340 --> 01:32:01.340
а нормальные библиотеки используют

01:32:01.340 --> 01:32:03.340
правильный механизм,

01:32:03.340 --> 01:32:05.340
чтобы быстро отправиться в ядро,

01:32:05.340 --> 01:32:07.340
а не тормознуть

01:32:07.340 --> 01:32:09.340
через интерфейс.

01:32:17.340 --> 01:32:19.340
Чтобы использовать эти команды,

01:32:19.340 --> 01:32:21.340
тебе нужно знать,

01:32:21.340 --> 01:32:23.340
где твоя операционка в юзерспейсе

01:32:23.340 --> 01:32:25.340
держит вот эту пару

01:32:25.340 --> 01:32:27.340
sys.enter

01:32:27.340 --> 01:32:29.340
для sys.exe.

01:32:29.340 --> 01:32:31.340
...

01:32:31.340 --> 01:32:33.340
...

01:32:33.340 --> 01:32:35.340
...

01:32:35.340 --> 01:32:37.340
...

01:32:37.340 --> 01:32:39.340
...

01:32:39.340 --> 01:32:41.340
...

01:32:41.340 --> 01:32:43.340
...

01:32:43.340 --> 01:32:45.340
...

01:32:45.340 --> 01:32:47.340
...

01:32:47.340 --> 01:32:49.340
...

01:32:49.340 --> 01:32:51.340
...

01:32:51.340 --> 01:32:53.340
...

01:32:53.340 --> 01:32:55.340
...

01:32:55.340 --> 01:32:57.340
...

01:32:57.340 --> 01:32:59.340
...

01:32:59.340 --> 01:33:01.340
...

01:33:01.340 --> 01:33:03.340
...

01:33:03.340 --> 01:33:05.340
...

01:33:05.340 --> 01:33:07.340
...

01:33:07.340 --> 01:33:09.340
...

01:33:09.340 --> 01:33:13.340
...

01:33:13.340 --> 01:33:15.340
...

01:33:15.340 --> 01:33:17.340
...

01:33:17.340 --> 01:33:19.340
...

01:33:19.340 --> 01:33:31.340
Это уже четвертая табличка.

01:33:31.340 --> 01:33:41.340
В принципе, да. Только это не про это, а про то, как передавать аргументы,

01:33:41.340 --> 01:33:48.340
про эти диски и всякое такое.

01:33:48.340 --> 01:33:55.340
Из хорошего в физически убитом мире всего две конвенции есть.

01:33:55.340 --> 01:34:04.340
Да, там существуют некоторые вариации на тему, но они не существенны.

01:34:04.340 --> 01:34:10.340
Вот такого дикого запаха, как было в принципе, там нет.

01:34:10.340 --> 01:34:11.340
Ничего же.

01:34:11.340 --> 01:34:13.340
Какого запаха используют?

01:34:13.340 --> 01:34:15.340
Ну, мне кажется, Дельфи используют.

01:34:15.340 --> 01:34:20.340
Дельфи, мне кажется, используют.

01:34:20.340 --> 01:34:23.340
У меня вообще не существовало Дельфи, поэтому не могу сказать.

01:34:23.340 --> 01:34:27.340
Одно я уже что-то ковырял и все.

01:34:27.340 --> 01:34:30.340
И вот оно очень даже множество.

01:34:30.340 --> 01:34:36.340
Я его открывал, ужаснулся и закрыл.

01:34:36.340 --> 01:34:40.340
Нет, я открывал код Дельфи.

01:34:40.340 --> 01:34:41.340
Страдал.

01:34:41.340 --> 01:34:42.340
Страдал.

01:34:42.340 --> 01:34:45.340
Вообще, Дельфи гнирюет очень фаршиво.

01:34:45.340 --> 01:34:47.340
Его прям очень больно читать.

01:34:47.340 --> 01:34:53.340
Там для того, чтобы сделать кто-то аналог строкопивая из одной строчки в другую,

01:34:53.340 --> 01:35:00.340
там выложены, по-моему, три уровня выложенности функций, чтобы сделать это действие.

01:35:00.340 --> 01:35:03.340
То есть нормально, если что-то не компилировать, просто inline,

01:35:03.340 --> 01:35:06.340
то у тебя такой мелкий цикл, который очевиден.

01:35:06.340 --> 01:35:10.340
А там функция вызывает функцию, вызывает функцию, которая в итоге все,

01:35:10.340 --> 01:35:13.340
что делает строкопивая.

01:35:13.340 --> 01:35:16.340
Очень больно читается.

01:35:16.340 --> 01:35:19.340
Итак, конверсии вызова.

01:35:19.340 --> 01:35:28.340
Во-первых, рассмотрим штуку, которая называется FastCon64.

01:35:28.340 --> 01:35:36.340
Обратите внимание, в отличие от того зоопарка, который был в крестоюбитом мире и назывался FastCon,

01:35:36.340 --> 01:35:39.340
FastCon64 — это жесткая конверсия.

01:35:39.340 --> 01:35:45.340
Это жесткая конкретная конверсия вызова без всяких неоднозначностей.

01:35:45.340 --> 01:35:51.340
И это единственная конверсия вызова 64-х видов под Windows.

01:35:51.340 --> 01:35:57.340
То есть вы, в принципе, можете сказать там в своем коде два подчеркивания CDECAL,

01:35:57.340 --> 01:36:01.340
два подчеркивания STDECAL в C-шном коде.

01:36:01.340 --> 01:36:06.340
Оно будет компилятором прочитано и жестко заебывается.

01:36:06.340 --> 01:36:08.340
Потому что используется только...

01:36:09.340 --> 01:36:12.340
Только одна конверсия.

01:36:12.340 --> 01:36:17.340
И вот эти подобные комментарии будут просто игнорироваться.

01:36:17.340 --> 01:36:19.340
Что здесь происходит?

01:36:19.340 --> 01:36:20.340
— Игнорируются только виды. — Что?

01:36:20.340 --> 01:36:23.340
— Игнорируются только виды. — Тоже игнорируются.

01:36:23.340 --> 01:36:26.340
Там тоже только один вариант.

01:36:26.340 --> 01:36:29.340
Но другой.

01:36:29.340 --> 01:36:31.340
Итак, что здесь происходит?

01:36:31.340 --> 01:36:35.340
Как следует из названия, это конверсия вида FastCon.

01:36:35.340 --> 01:36:37.340
То есть она использует...

01:36:37.340 --> 01:36:42.340
Регистры для передачи некоторого количества аргументов.

01:36:42.340 --> 01:36:48.340
И регистры следующие.

01:36:48.340 --> 01:36:51.340
Аргументы.

01:36:51.340 --> 01:36:53.340
RCX,

01:36:53.340 --> 01:36:55.340
RDX,

01:36:55.340 --> 01:36:57.340
R8,

01:36:57.340 --> 01:37:00.340
R9.

01:37:00.340 --> 01:37:03.340
— Это два аргумента? — Да.

01:37:03.340 --> 01:37:06.340
То есть первые четыре аргумента.

01:37:06.340 --> 01:37:09.340
И двух регистров.

01:37:09.340 --> 01:37:13.340
— Их три, да? — Да.

01:37:13.340 --> 01:37:19.340
Или...

01:37:19.340 --> 01:37:23.340
ХММ 0 по 3.

01:37:23.340 --> 01:37:28.340
Ну и вот это вот последствия того, что мы ведем не исторически.

01:37:28.340 --> 01:37:32.340
Эти ХММ-регистры — это про плавающую точку.

01:37:32.340 --> 01:37:35.340
Его мы поскидываем пока.

01:37:35.340 --> 01:37:40.340
Поэтому отметьте себе вот это вот замечание.

01:37:40.340 --> 01:37:44.340
Это будет про ровные числа.

01:37:44.340 --> 01:37:49.340
То есть если первые аргументы кто-то был фло,

01:37:49.340 --> 01:37:51.340
что плавающая точка,

01:37:51.340 --> 01:37:57.340
то он пойдет в соответствующий ХММ-регистр.

01:37:57.340 --> 01:38:01.340
Обратите внимание на слово «или».

01:38:01.340 --> 01:38:04.340
Это означает, что первый аргумент

01:38:04.340 --> 01:38:07.340
идет либо в РЦХ,

01:38:07.340 --> 01:38:10.340
либо в ХММ 0.

01:38:10.340 --> 01:38:12.340
В зависимости от его типа.

01:38:12.340 --> 01:38:14.340
Если он числочисленный,

01:38:14.340 --> 01:38:16.340
то в РЦХ.

01:38:16.340 --> 01:38:18.340
Если есть плавающая точка,

01:38:18.340 --> 01:38:20.340
то в ХММ 0.

01:38:20.340 --> 01:38:23.340
А второй аргумент идет куда?

01:38:23.340 --> 01:38:25.340
Или в РДХ,

01:38:25.340 --> 01:38:28.340
или в СММ 1.

01:38:28.340 --> 01:38:30.340
И куда шел первый аргумент —

01:38:30.340 --> 01:38:32.340
вообще неважно.

01:38:32.340 --> 01:38:35.340
То есть первые четыре аргумента

01:38:35.340 --> 01:38:37.340
идут в эти регистры.

01:38:37.340 --> 01:38:40.340
А нельзя ли восемь аргументов?

01:38:40.340 --> 01:38:41.340
Нет.

01:38:41.340 --> 01:38:42.340
Еще раз.

01:38:42.340 --> 01:38:44.340
Оно вот так вот поскидывается.

01:38:44.340 --> 01:38:46.340
Первые четыре аргумента через регистры.

01:38:46.340 --> 01:38:50.340
И эти регистры фиксированы следующим образом.

01:38:54.340 --> 01:38:57.340
То есть можно мешать РЦХ и ХММ,

01:38:57.340 --> 01:38:59.340
но только четыре регистра.

01:38:59.340 --> 01:39:00.340
Еще раз.

01:39:00.340 --> 01:39:04.340
Они отвечаются в зависимости от типа аргументов.

01:39:04.340 --> 01:39:06.340
Целочисленные аргументы,

01:39:06.340 --> 01:39:08.340
целые числа и указатели

01:39:08.340 --> 01:39:11.340
идут в обычные регистры.

01:39:11.340 --> 01:39:15.340
Плавающая точка идет сюда.

01:39:15.340 --> 01:39:18.340
И первые четыре аргумента в регистрах.

01:39:18.340 --> 01:39:20.340
Просто в каком регистре

01:39:20.340 --> 01:39:22.340
зависит от типа аргументов.

01:39:22.340 --> 01:39:25.340
А почему нельзя восемь аргументов?

01:39:25.340 --> 01:39:27.340
Потому что так постулировали.

01:39:27.340 --> 01:39:29.340
Почему так постулировали?

01:39:30.340 --> 01:39:32.340
Потому что нужно было как-то постулировать,

01:39:32.340 --> 01:39:34.340
и они постулировали вот так.

01:39:34.340 --> 01:39:37.340
На самом деле это имеет смысл.

01:39:37.340 --> 01:39:39.340
Мы увидим уже попозже.

01:39:39.340 --> 01:39:41.340
А если у меня один Инт, один Флот?

01:39:41.340 --> 01:39:42.340
Как я их отправлю?

01:39:42.340 --> 01:39:43.340
Я что ж не догадался.

01:39:43.340 --> 01:39:44.340
Я не уловил.

01:39:44.340 --> 01:39:47.340
Инт, Флот в ХММ-1.

01:39:47.340 --> 01:39:49.340
То есть если первый у тебя Инт,

01:39:49.340 --> 01:39:50.340
а потом Флот,

01:39:50.340 --> 01:39:52.340
то Инт идет в РЦХ,

01:39:52.340 --> 01:39:54.340
Флот в ХММ-1.

01:39:54.340 --> 01:39:57.340
То есть соотношение вот такое.

01:39:57.340 --> 01:39:58.340
Или туда, или туда.

01:40:00.340 --> 01:40:02.340
То есть Инт возвращает Флот на РЦХ.

01:40:02.340 --> 01:40:03.340
Возвращает, да.

01:40:03.340 --> 01:40:05.340
Мы же не дошли до этого.

01:40:05.340 --> 01:40:06.340
Ну да, да.

01:40:06.340 --> 01:40:07.340
Мы же не дошли,

01:40:07.340 --> 01:40:09.340
мы возвращаем на франшизу.

01:40:12.340 --> 01:40:13.340
Так.

01:40:13.340 --> 01:40:16.340
Теперь какие регистры нужно сохранять?

01:40:20.340 --> 01:40:22.340
Сохранять нужно.

01:40:30.340 --> 01:40:42.340
다면

01:40:42.340 --> 01:40:49.340
Aziku

01:40:50.340 --> 01:40:51.340
И вот это вот.

01:40:51.340 --> 01:40:53.340
Боль, страдания

01:40:54.740 --> 01:40:55.340
и поумедяции.

01:40:56.340 --> 01:40:57.340
И что значит

01:40:57.340 --> 01:40:59.340
обидно?

01:40:59.340 --> 01:41:15.340
Нет. Пока до СМА мы не дошли, давай так, о будущем. Говорю, что вот эту конвенцию составлял козел, который вообще не имеет мозга и не думал о будущем.

01:41:15.340 --> 01:41:36.100
Вот всякое вот это разумно, окей, понятно, что они имеют в виду, имеют свои плюсы, к этому нет претензий. Вот это полный идиотизм, страдания, боль и неадекватность. Но, к сожалению, с этим уже ничего не сделать.

01:41:36.100 --> 01:41:43.320
— Сейчас, то есть, типа, все вот эти регистры и вот эти?

01:41:43.320 --> 01:41:45.260
— Да. Нет, ну вот это просто норм.

01:41:45.340 --> 01:41:55.840
В этом нет ничего плохого. А вот это очень больно, глупо и так далее. Но почему, пока не знаете. Потому что мы вот идем этим другим путем.

01:41:55.840 --> 01:41:57.340
— Потому что мы скипали свою точку.

01:41:57.340 --> 01:42:08.340
— Да. Мы поскипали правую точку и синт, поэтому это вот залегай на будущее, пометьте себе, попозже поймете почему.

01:42:08.340 --> 01:42:13.340
— А вызывающая стаканчик?

01:42:13.340 --> 01:42:15.340
— Покрик.

01:42:15.340 --> 01:42:25.340
— Вызываемая функция — эти регистры, если хочешь менять, то должна вернуть в исходное состояние.

01:42:25.340 --> 01:42:32.340
В тридцатилюбительном мире у нас было вот так вот. Ну, только Е. Вот видишь, очень похоже.

01:42:32.340 --> 01:42:33.340
— ЕВХ.

01:42:33.340 --> 01:42:41.340
— ЕВХ, ЕВП, ЕСА, ЕДА. То есть вот это вот прям как вывел в тридцатилюбительном мире, только R.

01:42:41.340 --> 01:42:43.340
Вот это новые регистры — тоже норм.

01:42:43.340 --> 01:42:53.340
Вот это — большая, но вы ее пока не знаете.

01:42:53.340 --> 01:42:59.340
Возвращаемое значение.

01:42:59.340 --> 01:43:01.340
Результат.

01:43:01.340 --> 01:43:05.340
В.

01:43:05.340 --> 01:43:11.340
Сказать лучше.

01:43:11.340 --> 01:43:17.340
Аккумуляторе.

01:43:17.340 --> 01:43:19.340
Я вот так напишу.

01:43:19.340 --> 01:43:25.340
Или...

01:43:25.340 --> 01:43:27.340
— Это ХММО.

01:43:27.340 --> 01:43:29.340
— ХММО, да.

01:43:29.340 --> 01:43:35.340
Потому что это поплавающая точка.

01:43:35.340 --> 01:43:39.340
На самом деле нужно будет небольшую штучку добавить.

01:43:39.340 --> 01:43:41.340
И в тридцатилюбительной конвенции поплавающая точка.

01:43:41.340 --> 01:43:45.340
Но я вам думаю, поплавающая точка — это последующая точка.

01:43:45.340 --> 01:43:47.340
Занятие.

01:43:47.340 --> 01:43:49.340
Поэтому так. Отложил.

01:43:49.340 --> 01:43:51.340
А здесь уж.

01:43:51.340 --> 01:43:53.340
Сейчас мы все целиком рассматриваем.

01:43:53.340 --> 01:43:55.340
Наверное, довольно тесно здесь связано.

01:43:55.340 --> 01:43:57.340
С происходящим. Поэтому...

01:43:57.340 --> 01:44:01.340
— А если больше, то указатель сюда подороже записан.

01:44:01.340 --> 01:44:03.340
— Да.

01:44:03.340 --> 01:44:05.340
Если у вас аргументов больше,

01:44:05.340 --> 01:44:07.340
то аргументы идут на стейки.

01:44:07.340 --> 01:44:11.340
Если возвращаемое значение

01:44:11.340 --> 01:44:13.340
не лезет

01:44:13.340 --> 01:44:15.340
в аккумулятор,

01:44:15.340 --> 01:44:17.340
то то же самое, что было в тридцатилюбительном мире,

01:44:17.340 --> 01:44:19.340
это тоже нулевым значением указатель.

01:44:19.340 --> 01:44:21.340
И поэтому указатель

01:44:21.340 --> 01:44:23.340
будет сохранять значение.

01:44:23.340 --> 01:44:25.340
И идеи эти такие еще.

01:44:25.340 --> 01:44:27.340
— То есть ИСИ возможно вызвать

01:44:27.340 --> 01:44:29.340
спецплюсными методами.

01:44:29.340 --> 01:44:31.340
— Да.

01:44:31.340 --> 01:44:33.340
То есть здесь нет всяких извращений

01:44:33.340 --> 01:44:35.340
про

01:44:35.340 --> 01:44:37.340
РЦХ или еще что-нибудь.

01:44:37.340 --> 01:44:39.340
— Да.

01:44:45.340 --> 01:44:47.340
— Другое дело, что, по-моему,

01:44:47.340 --> 01:44:49.340
там порядок,

01:44:49.340 --> 01:44:51.340
который крупное

01:44:51.340 --> 01:44:53.340
возвращаемое значение

01:44:53.340 --> 01:44:55.340
и ЗИС.

01:44:55.340 --> 01:44:57.340
По-моему, там Microsoft.

01:44:57.340 --> 01:44:59.340
Я, правда, не помню точно. Надо уточнить.

01:44:59.340 --> 01:45:01.340
В каком порядке идут эти

01:45:01.340 --> 01:45:03.340
аргументы.

01:45:03.340 --> 01:45:05.340
— Это в конвенции начали?

01:45:05.340 --> 01:45:07.340
— Да. Единственная конвенция,

01:45:07.340 --> 01:45:09.340
которая была в тридцатилюбительном мире.

01:45:09.340 --> 01:45:11.340
— Мы же говорили две.

01:45:11.340 --> 01:45:13.340
— Нет. В шестидесятилюбительном мире

01:45:13.340 --> 01:45:15.340
все конвенции. Одна обендована,

01:45:15.340 --> 01:45:17.340
другая не обендована. Поэтому,

01:45:17.340 --> 01:45:19.340
когда у вас есть операционка,

01:45:19.340 --> 01:45:21.340
то вы строго привязаны

01:45:21.340 --> 01:45:23.340
к одной конвенции.

01:45:23.340 --> 01:45:25.340
— А.

01:45:25.340 --> 01:45:27.340
— Вот.

01:45:27.340 --> 01:45:29.340
Поэтому всякие комментарии в коде

01:45:29.340 --> 01:45:31.340
про конвенцию игнорируются,

01:45:31.340 --> 01:45:33.340
потому что какую конвенцию использовать

01:45:33.340 --> 01:45:35.340
определяется таргетом под какую

01:45:35.340 --> 01:45:37.340
конвенцию.

01:45:37.340 --> 01:45:39.340
Потому что у вас один вариант,

01:45:39.340 --> 01:45:41.340
что использовать.

01:45:41.340 --> 01:45:43.340
Так.

01:45:43.340 --> 01:45:45.340
Какие еще

01:45:45.340 --> 01:45:47.340
базовые расходы

01:45:47.340 --> 01:45:49.340
носите?

01:45:49.340 --> 01:45:51.340
— Конвенция.

01:45:51.340 --> 01:45:53.340
Я смотрю, какая-то мудро-красная

01:45:53.340 --> 01:45:55.340
операционка. Она просто где-то

01:45:55.340 --> 01:45:57.340
внутри себя указывается?

01:45:57.340 --> 01:45:59.340
— Ваша операционка должна постулировать,

01:45:59.340 --> 01:46:01.340
какую конвенцию использует она,

01:46:01.340 --> 01:46:03.340
системные библиотеки и прочее.

01:46:03.340 --> 01:46:05.340
— Такой вопрос.

01:46:05.340 --> 01:46:07.340
Если у меня код

01:46:07.340 --> 01:46:09.340
генерированный с фронтами,

01:46:09.340 --> 01:46:11.340
и он использует CSW-конвенцию...

01:46:11.340 --> 01:46:13.340
— Если он внутри себя использует,

01:46:13.340 --> 01:46:15.340
то никто об этом не узнает,

01:46:15.340 --> 01:46:17.340
пока он не взаимодействует

01:46:17.340 --> 01:46:19.340
никак с внешним миром.

01:46:19.340 --> 01:46:21.340
— Да.

01:46:21.340 --> 01:46:23.340
И вот, если я буду пытаться

01:46:23.340 --> 01:46:25.340
записать код на людей,

01:46:25.340 --> 01:46:27.340
мне надо писать про ставки,

01:46:27.340 --> 01:46:29.340
которые будут конвертировать...

01:46:29.340 --> 01:46:31.340
— Если он внутри себя это использует

01:46:31.340 --> 01:46:33.340
и ни с кем не взаимодействует,

01:46:33.340 --> 01:46:35.340
если его вызывают,

01:46:35.340 --> 01:46:37.340
то все будет так.

01:46:37.340 --> 01:46:39.340
— Да. Надо писать про ставки,

01:46:39.340 --> 01:46:41.340
которые будут конвертировать

01:46:41.340 --> 01:46:43.340
обе магазины по-другому.

01:46:43.340 --> 01:46:45.340
— Да. Вообще проще просто

01:46:45.340 --> 01:46:47.340
компилировать.

01:46:47.340 --> 01:46:49.340
Потому что целом мы можем сказать,

01:46:49.340 --> 01:46:51.340
что компилируют это обе.

01:46:51.340 --> 01:46:53.340
— Это G-code.

01:46:53.340 --> 01:46:55.340
— Только еще раз.

01:46:55.340 --> 01:46:57.340
— Я не использую G-code.

01:46:57.340 --> 01:46:59.340
— Я думаю, что компиляторы

01:46:59.340 --> 01:47:01.340
умеют использовать разные обе.

01:47:01.340 --> 01:47:03.340
— Ну, это уже твои проблемы.

01:47:03.340 --> 01:47:05.340
— Ну, это уже твои проблемы.

01:47:05.340 --> 01:47:07.340
— Потому что мне надо писать

01:47:07.340 --> 01:47:09.340
за ручками про ставки,

01:47:09.340 --> 01:47:11.340
которые будут конвертировать

01:47:11.340 --> 01:47:13.340
один обе.

01:47:13.340 --> 01:47:15.340
— И просто компилировать

01:47:15.340 --> 01:47:17.340
другой обе.

01:47:17.340 --> 01:47:19.340
— Можно, например,

01:47:19.340 --> 01:47:21.340
аналогистами писать.

01:47:27.340 --> 01:47:29.340
— Так, это были базовые штучки.

01:47:29.340 --> 01:47:31.340
И еще

01:47:31.340 --> 01:47:33.340
в 64-битных конвенциях

01:47:33.340 --> 01:47:35.340
есть

01:47:35.340 --> 01:47:37.340
и в той, и в той фича.

01:47:37.340 --> 01:47:39.340
Не знаю, как это

01:47:39.340 --> 01:47:41.340
по-другому назвать.

01:47:49.340 --> 01:47:51.340
Здесь она называется

01:47:51.340 --> 01:47:53.340
shadow space.

01:47:59.340 --> 01:48:01.340
Что это такое?

01:48:01.340 --> 01:48:03.340
Shadow space —

01:48:03.340 --> 01:48:05.340
это специальная конфигурация

01:48:05.340 --> 01:48:07.340
стэка,

01:48:07.340 --> 01:48:09.340
которая выглядит

01:48:09.340 --> 01:48:11.340
следующим образом.

01:48:13.340 --> 01:48:15.340
Вот.

01:48:15.340 --> 01:48:17.340
Как выглядит стэк

01:48:17.340 --> 01:48:19.340
в функции, когда ее

01:48:19.340 --> 01:48:21.340
вызовут.

01:48:23.340 --> 01:48:25.340
Вот здесь адрес возврата.

01:48:25.340 --> 01:48:27.340
Здесь вы там

01:48:27.340 --> 01:48:29.340
сохраняете всякие

01:48:29.340 --> 01:48:31.340
быстрые ваши локальные

01:48:31.340 --> 01:48:33.340
предметы, да,

01:48:33.340 --> 01:48:35.340
на его адресе старшего.

01:48:35.340 --> 01:48:37.340
И вот здесь

01:48:37.340 --> 01:48:39.340
у вас аргументы, функции,

01:48:39.340 --> 01:48:41.340
которые не вызовут людей.

01:48:41.340 --> 01:48:43.340
Понятно, да?

01:48:43.340 --> 01:48:45.340
Так вот,

01:48:45.340 --> 01:48:47.340
shadow space —

01:48:47.340 --> 01:48:49.340
это вот это место.

01:48:51.340 --> 01:48:53.340
Это между

01:48:53.340 --> 01:48:55.340
аргументами и ритмами?

01:48:55.340 --> 01:48:57.340
Да.

01:48:57.340 --> 01:48:59.340
32 байта.

01:48:59.340 --> 01:49:01.340
Здесь пошли уже аргументы.

01:49:01.340 --> 01:49:03.340
арг...

01:49:03.340 --> 01:49:05.340
арг...

01:49:05.340 --> 01:49:07.340
Ну, если считать, что это арг 0,

01:49:07.340 --> 01:49:09.340
то это будет

01:49:09.340 --> 01:49:11.340
арг 4, арг 5,

01:49:11.340 --> 01:49:13.340
и так далее.

01:49:17.340 --> 01:49:19.340
Смотрите,

01:49:19.340 --> 01:49:21.340
у вас после

01:49:21.340 --> 01:49:23.340
адреса возврата

01:49:23.340 --> 01:49:25.340
и перед аргументами

01:49:25.340 --> 01:49:27.340
есть 32 байта пространства,

01:49:27.340 --> 01:49:29.340
которое вы можете использовать

01:49:29.340 --> 01:49:31.340
как хотите.

01:49:31.340 --> 01:49:33.340
Зачем?

01:49:33.340 --> 01:49:35.340
Ну, на самом деле,

01:49:35.340 --> 01:49:37.340
это не доказаться даже.

01:49:37.340 --> 01:49:39.340
Вы указаете?

01:49:39.340 --> 01:49:41.340
Нет.

01:49:41.340 --> 01:49:43.340
Нет.

01:49:43.340 --> 01:49:45.340
Кто добавляет

01:49:45.340 --> 01:49:47.340
большого количества

01:49:47.340 --> 01:49:49.340
заморочек

01:49:49.340 --> 01:49:51.340
к конвенциям вызовов?

01:49:51.340 --> 01:49:53.340
Нет.

01:49:53.340 --> 01:49:55.340
Вы уже слышали это слово

01:49:55.340 --> 01:49:57.340
в прошлый раз.

01:49:57.340 --> 01:49:59.340
Сейчас еще раз.

01:49:59.340 --> 01:50:01.340
Пора.

01:50:01.340 --> 01:50:03.340
Функции

01:50:03.340 --> 01:50:05.340
с неизвестным количеством аргументов.

01:50:05.340 --> 01:50:07.340
Смотрите.

01:50:07.340 --> 01:50:09.340
Чем удобно

01:50:09.340 --> 01:50:11.340
это Shadow Space?

01:50:11.340 --> 01:50:13.340
32 байта

01:50:13.340 --> 01:50:15.340
это как раз место,

01:50:15.340 --> 01:50:17.340
чтобы сбросить

01:50:17.340 --> 01:50:19.340
эти аргументы

01:50:19.340 --> 01:50:21.340
из регистров

01:50:21.340 --> 01:50:23.340
на стэп

01:50:23.340 --> 01:50:25.340
и получить

01:50:25.340 --> 01:50:27.340
обычную линейную

01:50:27.340 --> 01:50:29.340
адресацию, как

01:50:29.340 --> 01:50:31.340
в вашем аргументе.

01:50:31.340 --> 01:50:33.340
Проблема

01:50:33.340 --> 01:50:35.340
с вараргами,

01:50:35.340 --> 01:50:37.340
когда у вас фастхол,

01:50:37.340 --> 01:50:39.340
что вы должны специальным образом

01:50:39.340 --> 01:50:41.340
обрабатывать несколько

01:50:41.340 --> 01:50:43.340
начальных значений,

01:50:43.340 --> 01:50:45.340
а потом по-другому

01:50:45.340 --> 01:50:47.340
все остальные аргументы.

01:50:47.340 --> 01:50:49.340
А здесь вы можете

01:50:49.340 --> 01:50:51.340
ваши специальные значения

01:50:51.340 --> 01:50:53.340
из регистров сбросить

01:50:53.340 --> 01:50:55.340
на стэп и получить

01:50:55.340 --> 01:50:57.340
унифицированную адресацию

01:50:57.340 --> 01:50:59.340
ко всем аргументам,

01:50:59.340 --> 01:51:01.340
которые есть в вашем аргументе.

01:51:01.340 --> 01:51:03.340
Это реально упрощается

01:51:03.340 --> 01:51:05.340
относительно всяких других

01:51:05.340 --> 01:51:07.340
фастхол-вариантов.

01:51:07.340 --> 01:51:09.340
Ты можешь это сделать.

01:51:09.340 --> 01:51:11.340
Ты не обязан это делать.

01:51:11.340 --> 01:51:13.340
Но у тебя есть место,

01:51:13.340 --> 01:51:15.340
куда ты можешь сбросить

01:51:15.340 --> 01:51:17.340
и сделать простую индексацию

01:51:17.340 --> 01:51:19.340
для варарг-функций.

01:51:19.340 --> 01:51:21.340
Это просто место,

01:51:21.340 --> 01:51:23.340
которое ты можешь использовать

01:51:23.340 --> 01:51:25.340
как хочешь.

01:51:25.340 --> 01:51:27.340
Оно явно предназначалось

01:51:27.340 --> 01:51:29.340
в вашем аргументе.

01:51:29.340 --> 01:51:31.340
Но никто не запрещает

01:51:31.340 --> 01:51:33.340
использовать его как ты хочешь.

01:51:33.340 --> 01:51:35.340
Например, располагать там

01:51:35.340 --> 01:51:37.340
свои локальные ферменты.

01:51:37.340 --> 01:51:39.340
И поэтому нельзя ввозить аргументы?

01:51:39.340 --> 01:51:41.340
Нет, не поэтому.

01:51:41.340 --> 01:51:43.340
Просто потому что так решили.

01:51:43.340 --> 01:51:45.340
Еще раз.

01:51:45.340 --> 01:51:47.340
Просто здесь так постулировать.

01:51:47.340 --> 01:51:49.340
И на самом деле

01:51:49.340 --> 01:51:51.340
то, что всего 4 аргумента,

01:51:51.340 --> 01:51:53.340
они 4 вот сюда

01:51:53.340 --> 01:51:55.340
в любом случае лезут.

01:51:55.340 --> 01:51:57.340
То есть и добры,

01:51:57.340 --> 01:51:59.340
тоже можно сбросить.

01:51:59.340 --> 01:52:01.340
И все будет хорошо и удобно.

01:52:01.340 --> 01:52:03.340
То есть это было

01:52:03.340 --> 01:52:05.340
специально для вас проведено.

01:52:11.340 --> 01:52:13.340
Потому что стек

01:52:13.340 --> 01:52:15.340
изменяется в 64-битном мире

01:52:15.340 --> 01:52:17.340
8-байтными порциями.

01:52:19.340 --> 01:52:21.340
Если вы пытаетесь

01:52:21.340 --> 01:52:23.340
передать в качестве аргумента

01:52:23.340 --> 01:52:25.340
функции,

01:52:25.340 --> 01:52:27.340
то этот инк на стеке

01:52:27.340 --> 01:52:29.340
будет считать в 8 байт.

01:52:29.340 --> 01:52:31.340
Частично будет намного лучше.

01:52:33.340 --> 01:52:35.340
Потому что стек идет шагами

01:52:35.340 --> 01:52:37.340
от видности.

01:52:37.340 --> 01:52:39.340
Если ваш аргумент меньше,

01:52:39.340 --> 01:52:41.340
у вас будет неиспользованное место.

01:52:45.340 --> 01:52:47.340
Вот такая ключа.

01:52:47.340 --> 01:52:49.340
Shadow Space.

01:52:49.340 --> 01:52:51.340
Притом, обращаю ваше внимание,

01:52:51.340 --> 01:52:53.340
что это место 32 байта

01:52:53.340 --> 01:52:55.340
оно фиксировано.

01:52:55.340 --> 01:52:57.340
Абсолютно все функции его получают.

01:52:57.340 --> 01:52:59.340
Даже если у функции

01:52:59.340 --> 01:53:01.340
один аргумент или

01:53:01.340 --> 01:53:03.340
ноль аргументов,

01:53:03.340 --> 01:53:05.340
все равно в Shadow Space

01:53:05.340 --> 01:53:07.340
в полной размерности 32 байта

01:53:07.340 --> 01:53:09.340
положен функция.

01:53:09.340 --> 01:53:11.340
Я помню,

01:53:11.340 --> 01:53:13.340
когда я

01:53:13.340 --> 01:53:15.340
только начал экспериментировать

01:53:15.340 --> 01:53:17.340
с 64-битными,

01:53:17.340 --> 01:53:19.340
я вызывал функцию

01:53:19.340 --> 01:53:21.340
лап-клатина ревендовую,

01:53:21.340 --> 01:53:23.340
которая принимает один аргумент.

01:53:23.340 --> 01:53:25.340
А если нет,

01:53:25.340 --> 01:53:27.340
так я не выделю 8 байт.

01:53:27.340 --> 01:53:29.340
Ни один аргумент.

01:53:29.340 --> 01:53:31.340
У меня все покрашено.

01:53:31.340 --> 01:53:33.340
Почему?

01:53:33.340 --> 01:53:35.340
Потому что что происходило

01:53:35.340 --> 01:53:37.340
внутри функции лап-клатины?

01:53:37.340 --> 01:53:39.340
Она просто записывала константочки

01:53:39.340 --> 01:53:41.340
в некоторые регистры

01:53:41.340 --> 01:53:43.340
и делала джамп

01:53:43.340 --> 01:53:45.340
на функцию лап-клатины

01:53:45.340 --> 01:53:47.340
yes,

01:53:47.340 --> 01:53:49.340
на которой требуем.

01:53:49.340 --> 01:53:51.340
И та функция

01:53:51.340 --> 01:53:53.340
уже на стек сохраняла

01:53:53.340 --> 01:53:55.340
4 аргумента

01:53:55.340 --> 01:53:57.340
и вылезала за мои 8 байтиков,

01:53:57.340 --> 01:53:59.340
которые я выделил.

01:53:59.340 --> 01:54:01.340
То есть, вот Shadow Space

01:54:01.340 --> 01:54:03.340
имеет фиксированный размер 32 байта

01:54:03.340 --> 01:54:05.340
и не связан

01:54:05.340 --> 01:54:07.340
с количеством аргументов.

01:54:07.340 --> 01:54:09.340
4 аргумента, 64,

01:54:09.340 --> 01:54:11.340
2 аргумента,

01:54:11.340 --> 01:54:13.340
в любом случае функция получает

01:54:13.340 --> 01:54:15.340
Shadow Space размером 32 байта.

01:54:15.340 --> 01:54:17.340
Понятно?

01:54:17.340 --> 01:54:19.340
Это ключа

01:54:19.340 --> 01:54:21.340
конденса.

01:54:21.340 --> 01:54:23.340
Кроме того, есть еще одна особенность,

01:54:23.340 --> 01:54:25.340
которая тоже относится ко всем

01:54:25.340 --> 01:54:27.340
конденсиям 64.

01:54:27.340 --> 01:54:29.340
Видно, что перед

01:54:29.340 --> 01:54:31.340
вызовом функции,

01:54:31.340 --> 01:54:33.340
то есть вот в этот момент,

01:54:33.340 --> 01:54:35.340
стек поинта

01:54:37.340 --> 01:54:39.340
должен быть кратен

01:54:39.340 --> 01:54:41.340
64.

01:54:41.340 --> 01:54:43.340
Вот тьфу, 16, 64.

01:54:47.340 --> 01:54:49.340
16 байт.

01:54:53.340 --> 01:54:57.340
Ну, вообще,

01:54:57.340 --> 01:54:59.340
если вы ведете себя цивилизованно,

01:54:59.340 --> 01:55:01.340
то

01:55:01.340 --> 01:55:03.340
какая кратность может быть у

01:55:03.340 --> 01:55:05.340
стек поинтера в 64 битах?

01:55:05.340 --> 01:55:07.340
Либо

01:55:07.340 --> 01:55:09.340
кратно 16,

01:55:09.340 --> 01:55:11.340
либо на 8 не кратно

01:55:11.340 --> 01:55:13.340
16.

01:55:13.340 --> 01:55:15.340
То есть, либо кратно, либо полукратно.

01:55:15.340 --> 01:55:17.340
Так вот,

01:55:17.340 --> 01:55:19.340
в момент того, когда мы делаете

01:55:19.340 --> 01:55:21.340
call, то есть

01:55:21.340 --> 01:55:23.340
перед

01:55:23.340 --> 01:55:25.340
вызовом функции,

01:55:25.340 --> 01:55:27.340
стек поинтер должен быть кратен

01:55:27.340 --> 01:55:29.340
16.

01:55:31.340 --> 01:55:33.340
Соответственно, когда

01:55:33.340 --> 01:55:35.340
войду в функцию,

01:55:35.340 --> 01:55:37.340
то ваш стек поинтер будет

01:55:37.340 --> 01:55:39.340
не кратен 16.

01:55:39.340 --> 01:55:41.340
Да.

01:55:41.340 --> 01:55:43.340
Поэтому, если вы решите

01:55:43.340 --> 01:55:45.340
мгновенно кого-то вызвать,

01:55:45.340 --> 01:55:47.340
то вам нужно

01:55:47.340 --> 01:55:49.340
стек поинтер опустить не на

01:55:49.340 --> 01:55:51.340
32 байта,

01:55:51.340 --> 01:55:53.340
а на

01:55:53.340 --> 01:55:55.340
40.

01:55:55.340 --> 01:55:57.340
Потому что вам нужно выделить

01:55:57.340 --> 01:55:59.340
32 байта

01:55:59.340 --> 01:56:01.340
и выливать стек поинтер.

01:56:03.340 --> 01:56:05.340
Вот, заключите себе,

01:56:05.340 --> 01:56:07.340
что

01:56:07.340 --> 01:56:09.340
в момент выполнения

01:56:09.340 --> 01:56:11.340
команды call,

01:56:11.340 --> 01:56:13.340
перед командой call, стек поинтер

01:56:13.340 --> 01:56:15.340
должен быть кратен 16.

01:56:17.340 --> 01:56:19.340
И, соответственно,

01:56:19.340 --> 01:56:21.340
когда вы только что оказались

01:56:21.340 --> 01:56:23.340
внутри функции, ваш

01:56:23.340 --> 01:56:25.340
стек поинтер ровно на 8

01:56:25.340 --> 01:56:27.340
не кратен 16.

01:56:35.340 --> 01:56:37.340
Что будет,

01:56:37.340 --> 01:56:39.340
если вы забьете на это

01:56:39.340 --> 01:56:41.340
требование?

01:56:41.340 --> 01:56:43.340
Либо все будет работать,

01:56:43.340 --> 01:56:45.340
либо кто-то покрашится.

01:56:45.340 --> 01:56:47.340
Почему кто-то может покрашиться,

01:56:47.340 --> 01:56:49.340
если у вас не кратен

01:56:49.340 --> 01:56:51.340
стек поинтер?

01:56:51.340 --> 01:56:53.340
Поэтому мы узнаем,

01:56:53.340 --> 01:56:55.340
когда дойдем до этих самых

01:56:55.340 --> 01:56:57.340
xml-регистров.

01:56:57.340 --> 01:56:59.340
Вот это требование к кратности 16,

01:56:59.340 --> 01:57:01.340
оно связано с xml-регистрами.

01:57:05.340 --> 01:57:07.340
Поэтому, если тот, кого вы вызываете,

01:57:07.340 --> 01:57:09.340
не использует xml-регистры,

01:57:09.340 --> 01:57:11.340
и кого он вызывает,

01:57:11.340 --> 01:57:13.340
не использует xml-регистры,

01:57:13.340 --> 01:57:15.340
то оно даже будет работать,

01:57:15.340 --> 01:57:17.340
если вы нарушите это требование к кратности.

01:57:17.340 --> 01:57:19.340
Но если кто-то там

01:57:19.340 --> 01:57:21.340
использует xml-регистры,

01:57:21.340 --> 01:57:23.340
то у вас есть хорошие шансы,

01:57:23.340 --> 01:57:25.340
что оно в том месте покрашится.

01:57:25.340 --> 01:57:27.340
Получается, перед каждым

01:57:27.340 --> 01:57:29.340
вызовом группа 164

01:57:29.340 --> 01:57:31.340
должен стоять sub-rsp 32?

01:57:31.340 --> 01:57:33.340
Нет.

01:57:33.340 --> 01:57:35.340
Нет.

01:57:35.340 --> 01:57:37.340
Это я вам сейчас рассказал

01:57:37.340 --> 01:57:39.340
как-то такую топологию стека.

01:57:39.340 --> 01:57:41.340
Но

01:57:41.340 --> 01:57:43.340
использование стека

01:57:43.340 --> 01:57:45.340
в 64-битном мире

01:57:45.340 --> 01:57:47.340
оно другое.

01:57:47.340 --> 01:57:49.340
Если в 64-битном мире

01:57:49.340 --> 01:57:51.340
вы привыкли

01:57:51.340 --> 01:57:53.340
вызывать функции как

01:57:53.340 --> 01:57:55.340
push-push-call,

01:57:55.340 --> 01:57:57.340
push-push-call, push-push-call,

01:57:57.340 --> 01:57:59.340
то в 64-битном мире

01:57:59.340 --> 01:58:01.340
выглядит не так.

01:58:01.340 --> 01:58:03.340
В 64-битном мире

01:58:03.340 --> 01:58:05.340
стек-пойнтер обычно

01:58:05.340 --> 01:58:07.340
один раз опускается

01:58:07.340 --> 01:58:09.340
в самом начале функции,

01:58:09.340 --> 01:58:11.340
резервируя место и под ваши

01:58:11.340 --> 01:58:13.340
локальные переменные,

01:58:13.340 --> 01:58:15.340
и под аргументы,

01:58:15.340 --> 01:58:17.340
которые могут потребоваться,

01:58:17.340 --> 01:58:19.340
а потом на стек аргументы

01:58:19.340 --> 01:58:21.340
складываются командой mov.

01:58:21.340 --> 01:58:23.340
То есть у вас перед каждым

01:58:23.340 --> 01:58:25.340
вызовом функции

01:58:25.340 --> 01:58:27.340
никакой shadow space

01:58:27.340 --> 01:58:29.340
не выделяется.

01:58:29.340 --> 01:58:31.340
Он выделяется один раз

01:58:31.340 --> 01:58:33.340
при входе в функцию,

01:58:33.340 --> 01:58:35.340
вы опускаете стек-пойнтер

01:58:35.340 --> 01:58:37.340
вот насколько он может

01:58:37.340 --> 01:58:39.340
максимум потребоваться.

01:58:39.340 --> 01:58:41.340
Это справедливо

01:58:41.340 --> 01:58:43.340
для почти всех функций,

01:58:43.340 --> 01:58:45.340
кроме тех,

01:58:45.340 --> 01:58:47.340
которые динамически

01:58:47.340 --> 01:58:49.340
выделяют место на стеке

01:58:49.340 --> 01:58:51.340
неизвестного размера

01:58:51.340 --> 01:58:55.340
.

01:58:55.340 --> 01:58:57.340
Обычные функции ведут себя

01:58:57.340 --> 01:58:59.340
еще раз.

01:58:59.340 --> 01:59:01.340
Стек-пойнтер опускается

01:59:01.340 --> 01:59:03.340
и только в конце стек-пойнтер

01:59:03.340 --> 01:59:05.340
возвращается обратно.

01:59:05.340 --> 01:59:07.340
Поэтому аргументы

01:59:07.340 --> 01:59:09.340
через mov.

01:59:09.340 --> 01:59:11.340
shadow space

01:59:11.340 --> 01:59:13.340
есть автоматически,

01:59:13.340 --> 01:59:15.340
потому что вы должны его учесть,

01:59:15.340 --> 01:59:17.340
когда опускаете стек-пойнтер.

01:59:19.340 --> 01:59:21.340
Это место, принадлежащее

01:59:21.340 --> 01:59:23.340
вызываемой функции,

01:59:23.340 --> 01:59:25.340
которая может делать с ним

01:59:25.340 --> 01:59:27.340
все, что хочет,

01:59:27.340 --> 01:59:29.340
и, соответственно,

01:59:29.340 --> 01:59:31.340
вы можете делать с этим местом

01:59:31.340 --> 01:59:33.340
все, что хотите.

01:59:33.340 --> 01:59:35.340
Вы можете сохранять переменные

01:59:35.340 --> 01:59:37.340
как хотите,

01:59:37.340 --> 01:59:39.340
используя эти 32 байка,

01:59:39.340 --> 01:59:41.340
они принадлежат вам.

01:59:41.340 --> 01:59:43.340
Понятно?

01:59:43.340 --> 01:59:45.340
Вот.

01:59:45.340 --> 01:59:47.340
Это была

01:59:47.340 --> 01:59:49.340
диндовая конвенция

01:59:49.340 --> 01:59:51.340
по стек-пойнту 64.

01:59:51.340 --> 01:59:53.340
.

01:59:53.340 --> 01:59:55.340
.

01:59:55.340 --> 01:59:57.340
.

01:59:57.340 --> 01:59:59.340
.

01:59:59.340 --> 02:00:01.340
.

02:00:01.340 --> 02:00:03.340
.

02:00:03.340 --> 02:00:05.340
.

02:00:05.340 --> 02:00:07.340
.

02:00:07.340 --> 02:00:09.340
.

02:00:09.340 --> 02:00:13.340
.

02:00:13.340 --> 02:00:15.340
.

02:00:15.340 --> 02:00:17.340
.

02:00:17.340 --> 02:00:19.340
.

02:00:19.340 --> 02:00:25.340
.

02:00:25.340 --> 02:00:27.340
.

02:00:27.340 --> 02:00:29.340
.

02:00:29.340 --> 02:00:31.340
.

02:00:31.340 --> 02:00:33.340
.

02:00:33.340 --> 02:00:35.340
.

02:00:35.340 --> 02:00:37.340
.

02:00:37.340 --> 02:00:39.340
.

02:00:39.340 --> 02:00:41.340
.

02:00:41.340 --> 02:00:43.340
.

02:00:43.340 --> 02:00:45.340
.

02:00:45.340 --> 02:00:47.340
.

02:00:47.340 --> 02:00:57.340
. .

02:00:57.340 --> 02:00:59.340
.

02:00:59.340 --> 02:01:01.340
.

02:01:01.340 --> 02:01:03.340
.

02:01:03.340 --> 02:01:05.340
.

02:01:05.340 --> 02:01:07.340
.

02:01:07.340 --> 02:01:09.340
.

02:01:09.340 --> 02:01:11.340
.

02:01:11.340 --> 02:01:13.340
.

02:01:13.340 --> 02:01:15.340
.

02:01:15.340 --> 02:01:25.340
. .

02:01:25.340 --> 02:01:27.340
.

02:01:27.340 --> 02:01:29.340
.

02:01:29.340 --> 02:01:31.340
.

02:01:31.340 --> 02:01:33.340
.

02:01:33.340 --> 02:01:35.340
.

02:01:35.340 --> 02:01:37.340
.

02:01:37.340 --> 02:01:39.340
.

02:01:39.340 --> 02:01:41.340
.

02:01:41.340 --> 02:01:43.340
.

02:01:43.340 --> 02:01:55.340
. .

02:01:55.340 --> 02:01:57.340
. .

02:01:57.340 --> 02:01:59.340
.

02:01:59.340 --> 02:02:01.340
.

02:02:01.340 --> 02:02:03.340
.

02:02:03.340 --> 02:02:05.340
.

02:02:05.340 --> 02:02:07.340
.

02:02:07.340 --> 02:02:09.340
.

02:02:09.340 --> 02:02:11.340
.

02:02:11.340 --> 02:02:31.340
.

02:02:31.340 --> 02:02:35.340
Вот это аргументы.

02:02:35.340 --> 02:02:40.340
То есть аргументы можно передавать через огромное количество регистров.

02:02:40.340 --> 02:02:41.340
Обратите внимание,

02:02:41.340 --> 02:02:42.340
на слово

02:02:42.340 --> 02:02:44.340
И.

02:02:44.340 --> 02:02:45.340
Это означает,

02:02:45.340 --> 02:02:46.340
что

02:02:46.340 --> 02:02:48.340
число с плавающей точкой

02:02:48.340 --> 02:02:49.340
независимо

02:02:49.340 --> 02:02:50.340
от

02:02:50.340 --> 02:02:51.340
сочисленных аргументов

02:02:51.340 --> 02:02:53.340
используют свои регистры.

02:02:53.340 --> 02:02:54.340
То есть,

02:02:54.340 --> 02:02:56.340
если у вас, например, первый аргумент

02:02:56.340 --> 02:02:57.340
сочисленный,

02:02:57.340 --> 02:02:58.340
а потом плавающая точка,

02:02:58.340 --> 02:03:00.340
а потом снова целое число,

02:03:00.340 --> 02:03:01.340
то

02:03:01.340 --> 02:03:03.340
первое сочисленное значение

02:03:03.340 --> 02:03:04.340
пойдет в RDI,

02:03:04.340 --> 02:03:05.340
плавающая точка

02:03:05.340 --> 02:03:06.340
в XM0,

02:03:06.340 --> 02:03:08.340
а второе сочисленное

02:03:08.340 --> 02:03:10.340
в RSE.

02:03:10.340 --> 02:03:15.340
То есть используются и те регистры,

02:03:15.340 --> 02:03:16.340
и те регистры

02:03:16.340 --> 02:03:18.340
вместе, одновременно.

02:03:18.340 --> 02:03:20.340
Не или как было

02:03:20.340 --> 02:03:22.340
по сколу 64.

02:03:22.340 --> 02:03:24.340
.

02:03:24.340 --> 02:03:26.340
.

02:03:26.340 --> 02:03:28.340
Да, можно дофигачивать

02:03:28.340 --> 02:03:30.340
и передать регистры.

02:03:30.340 --> 02:03:31.340
Но,

02:03:31.340 --> 02:03:33.340
как несложно догадаться,

02:03:33.340 --> 02:03:35.340
это резко повышает

02:03:35.340 --> 02:03:37.340
сложность

02:03:37.340 --> 02:03:39.340
по сколу функций.

02:03:39.340 --> 02:03:41.340
.

02:03:41.340 --> 02:03:43.340
Потому что в RAR

02:03:43.340 --> 02:03:44.340
не разобраться,

02:03:44.340 --> 02:03:46.340
что у вас происходит.

02:03:46.340 --> 02:03:48.340
Удачи!

02:03:48.340 --> 02:03:49.340
.

02:03:49.340 --> 02:03:50.340
И,

02:03:50.340 --> 02:03:51.340
поэтому,

02:03:51.340 --> 02:03:52.340
если ваша функция

02:03:52.340 --> 02:03:54.340
в RAR,

02:03:54.340 --> 02:03:56.340
количество аргументов

02:03:56.340 --> 02:03:58.340
вот в этих регистрах

02:03:58.340 --> 02:04:00.340
необходимо указать

02:04:00.340 --> 02:04:06.340
в RAX.

02:04:06.340 --> 02:04:07.340
То есть,

02:04:07.340 --> 02:04:08.340
если вы

02:04:08.340 --> 02:04:09.340
вызываете

02:04:09.340 --> 02:04:10.340
print,

02:04:10.340 --> 02:04:14.340
то количество аргументов,

02:04:14.340 --> 02:04:16.340
которые вы запихали вот сюда,

02:04:16.340 --> 02:04:19.340
необходимо указать в RAX.

02:04:19.340 --> 02:04:22.340
Если вы сюда запихали 0 аргументов,

02:04:22.340 --> 02:04:24.340
вы должны указать 0 в RAX.

02:04:24.340 --> 02:04:26.340
Если вы этого не сделаете

02:04:26.340 --> 02:04:28.340
и оставите в RAX мусор,

02:04:28.340 --> 02:04:30.340
то print у вас покрашится.

02:04:30.340 --> 02:04:36.340
.

02:04:36.340 --> 02:04:38.340
Количество аргументов

02:04:38.340 --> 02:04:40.340
в XMM регистрах.

02:04:40.340 --> 02:04:42.340
.

02:04:42.340 --> 02:04:43.340
Еще раз.

02:04:43.340 --> 02:04:45.340
Для VARARG функций

02:04:45.340 --> 02:04:47.340
сколько аргументов вы

02:04:47.340 --> 02:04:49.340
заполнили в XMM регистрах,

02:04:49.340 --> 02:04:51.340
необходимо указать

02:04:51.340 --> 02:04:53.340
в регистре RAX перед вызовом.

02:04:53.340 --> 02:04:55.340
.

02:04:55.340 --> 02:04:57.340
RAX – это количество используемых

02:04:57.340 --> 02:04:59.340
XMM для VARARG функций.

02:04:59.340 --> 02:05:01.340
.

02:05:01.340 --> 02:05:03.340
Получается,

02:05:03.340 --> 02:05:05.340
у нас через stack не передаются аргументы?

02:05:05.340 --> 02:05:07.340
Или там избыток какой-то?

02:05:07.340 --> 02:05:09.340
.

02:05:09.340 --> 02:05:10.340
Конечно же,

02:05:10.340 --> 02:05:12.340
остальные, которые не навестились в регистрах,

02:05:12.340 --> 02:05:14.340
отправляются на stack в обратном порядке,

02:05:14.340 --> 02:05:16.340
но это довольно интуитивная идея.

02:05:16.340 --> 02:05:22.340
.

02:05:22.340 --> 02:05:24.340
То есть другие аргументы на stack

02:05:24.340 --> 02:05:26.340
в обратном порядке по обычным правилам.

02:05:26.340 --> 02:05:28.340
Здесь ничего нового.

02:05:28.340 --> 02:05:30.340
Но вот в регистрах

02:05:30.340 --> 02:05:32.340
такие правила,

02:05:32.340 --> 02:05:34.340
и для VARARG вот такие правила.

02:05:34.340 --> 02:05:38.340
.

02:05:38.340 --> 02:05:40.340
Плавающая точка уходит в эти регистры,

02:05:40.340 --> 02:05:42.340
не плавающая точка

02:05:42.340 --> 02:05:44.340
идет в регистр общего значения.

02:05:44.340 --> 02:05:46.340
.

02:05:46.340 --> 02:05:48.340
Так, что нужно сохранять?

02:05:48.340 --> 02:05:50.340
Сохранять нужно меньше.

02:05:50.340 --> 02:05:52.340
.

02:05:52.340 --> 02:05:54.340
.

02:05:54.340 --> 02:05:56.340
.

02:05:56.340 --> 02:05:58.340
.

02:05:58.340 --> 02:06:00.340
.

02:06:00.340 --> 02:06:02.340
.

02:06:02.340 --> 02:06:04.340
.

02:06:04.340 --> 02:06:06.340
.

02:06:06.340 --> 02:06:08.340
.

02:06:08.340 --> 02:06:10.340
.

02:06:10.340 --> 02:06:12.340
.

02:06:12.340 --> 02:06:14.340
.

02:06:14.340 --> 02:06:16.340
.

02:06:16.340 --> 02:06:18.340
.

02:06:18.340 --> 02:06:20.340
.

02:06:20.340 --> 02:06:22.340
.

02:06:22.340 --> 02:06:24.340
.

02:06:24.340 --> 02:06:26.340
.

02:06:26.340 --> 02:06:28.340
.

02:06:28.340 --> 02:06:30.340
.

02:06:30.340 --> 02:06:32.340
.

02:06:32.340 --> 02:06:34.340
.

02:06:34.340 --> 02:06:36.340
.

02:06:36.340 --> 02:06:38.340
.

02:06:38.340 --> 02:06:40.340
.

02:06:40.340 --> 02:06:42.340
.

02:06:42.340 --> 02:06:44.340
.

02:06:44.340 --> 02:06:46.340
.

02:06:46.340 --> 02:06:48.340
.

02:06:48.340 --> 02:06:50.340
.

02:06:50.340 --> 02:06:52.340
.

02:06:52.340 --> 02:06:54.340
.

02:06:54.340 --> 02:06:56.340
.

02:06:56.340 --> 02:06:58.340
.

02:06:58.340 --> 02:07:00.340
.

02:07:00.340 --> 02:07:04.340
. .

02:07:04.340 --> 02:07:08.340
. .

02:07:08.340 --> 02:07:10.340
.

02:07:10.340 --> 02:07:12.340
.

02:07:12.340 --> 02:07:14.340
.

02:07:14.340 --> 02:07:16.340
.

02:07:16.340 --> 02:07:18.340
.

02:07:18.340 --> 02:07:20.340
.

02:07:20.340 --> 02:07:22.340
.

02:07:22.340 --> 02:07:24.340
.

02:07:24.340 --> 02:07:26.340
.

02:07:26.340 --> 02:07:28.340
.

02:07:28.340 --> 02:07:41.380
Так, да, аккумулятор и вроде как XMM 0 по 1.

02:07:42.420 --> 02:07:45.380
Тоже я об этом читал, но сам никогда не видел.

02:07:46.920 --> 02:07:49.020
Зачем может потребоваться 2 XMM?

02:07:49.020 --> 02:07:53.940
Я предполагаю, может быть для комплекса чисел.

02:07:53.940 --> 02:08:06.500
Когда ваше значение состоит из 2 чисел, может быть вот эта комплексная часть пройдет XMM 1, но нужно проверить.

02:08:07.480 --> 02:08:08.700
Какой размер XMM есть?

02:08:09.080 --> 02:08:15.340
Да фига, но обычно используется в передаче организма только в меньшую часть.

02:08:15.340 --> 02:08:21.460
То есть с точки зрения размеров, конечно, там хватит на 4 флота,

02:08:22.180 --> 02:08:23.900
но так обычно.

02:08:23.940 --> 02:08:33.180
Поэтому я предполагаю, зачем нужен XMM 1, чтобы для комплекса чисел.

02:08:33.620 --> 02:08:34.660
Но надо проверить.

02:08:37.420 --> 02:08:40.560
Стек также нужно выравнивать на 16.

02:08:41.940 --> 02:08:45.640
Но здесь есть уже своя фича.

02:08:46.420 --> 02:08:52.560
Фича называется здесь PREDU.

02:08:53.940 --> 02:08:55.940
Что за RedDoll?

02:08:57.940 --> 02:08:59.940
Это вот такая картинка.

02:09:16.420 --> 02:09:20.420
Вот здесь аргументы, которые у нас в пенте.

02:09:23.940 --> 02:09:30.940
Адрес возврата.

02:09:30.940 --> 02:09:33.940
Стекпоинты выравниваем.

02:09:33.940 --> 02:09:37.940
А RedDoll это вот эта штука.

02:09:37.940 --> 02:09:48.940
Даже не совсем так она выглядит.

02:09:48.940 --> 02:09:49.940
Адрес возврата.

02:09:49.940 --> 02:09:50.940
Адрес возврата.

02:09:50.940 --> 02:09:51.940
Адрес возврата.

02:09:51.940 --> 02:09:52.940
Стекпоинты выравниваем.

02:09:52.940 --> 02:09:54.640
Делаем вот так.

02:09:56.900 --> 02:09:58.240
Там газовые батареи.

02:09:58.360 --> 02:09:59.360
Режимы закрываю.

02:09:59.740 --> 02:10:01.700
И это все.

02:10:02.180 --> 02:10:03.180
Батарейка.

02:10:04.060 --> 02:10:04.540
Видите?

02:10:04.860 --> 02:10:06.020
Вот здесь они закрываются.

02:10:06.180 --> 02:10:06.940
Этоzie рет Bloggers.

02:10:07.940 --> 02:10:11.940
И это возможность поменять свой пакет.

02:10:13.940 --> 02:10:16.740
Скажу, что я ещё час поставил.

02:10:16.940 --> 02:10:18.440
Скажу, что изменилось.

02:10:18.940 --> 02:10:20.940
Ну, и сейчас вы с нами.

02:10:20.940 --> 02:10:21.840
Смотрите.

02:10:21.840 --> 02:10:22.260
Что?

02:10:22.260 --> 02:10:22.540
Смотрите.

02:10:22.540 --> 02:10:23.760
сохранить на стеке.

02:10:24.480 --> 02:10:25.700
Мы говорили о чем?

02:10:26.120 --> 02:10:26.980
Как это сделать?

02:10:27.720 --> 02:10:30.800
Вам нужно вначале опустить стекпоинтер

02:10:30.800 --> 02:10:32.860
и потом

02:10:32.860 --> 02:10:33.880
сохранять значение.

02:10:34.740 --> 02:10:36.500
То есть писать ниже

02:10:36.500 --> 02:10:38.560
стекпоинтера не надо.

02:10:39.140 --> 02:10:39.440
Почему?

02:10:40.480 --> 02:10:42.180
Потому что сохранность данных

02:10:42.180 --> 02:10:44.780
ниже стекпоинтера, честно говоря,

02:10:45.400 --> 02:10:47.140
не гарантируется системе.

02:10:47.980 --> 02:10:48.840
Что может пройти

02:10:48.840 --> 02:10:50.400
какое-нибудь там прерывание

02:10:50.400 --> 02:10:51.520
или еще что,

02:10:52.540 --> 02:10:55.260
и данные ниже стекпоинтера

02:10:55.260 --> 02:10:56.840
считаются, что они никому

02:10:56.840 --> 02:10:58.600
не принадлежат, мусор,

02:10:58.880 --> 02:10:59.920
их можно портить.

02:11:01.320 --> 02:11:01.820
Поэтому,

02:11:02.720 --> 02:11:04.560
если вы сохраните там данные,

02:11:05.020 --> 02:11:07.140
вас мгновенно никто не поругает.

02:11:08.300 --> 02:11:09.320
Но сохранность

02:11:09.320 --> 02:11:10.100
данных там

02:11:10.100 --> 02:11:11.660
не гарантируется.

02:11:13.640 --> 02:11:14.720
Так вот, Red Zone

02:11:14.720 --> 02:11:17.280
это специальная гарантия,

02:11:18.000 --> 02:11:18.780
что данные

02:11:18.780 --> 02:11:20.260
ниже стекпоинтера

02:11:20.260 --> 02:11:21.980
до 128

02:11:21.980 --> 02:11:23.980
байт гарантированно

02:11:23.980 --> 02:11:24.680
сохраняются.

02:11:26.720 --> 02:11:28.340
То есть никакое прерывание

02:11:28.340 --> 02:11:30.360
и подобное не будет

02:11:30.360 --> 02:11:32.120
портить вам данные

02:11:32.120 --> 02:11:34.900
на 128 байт

02:11:34.900 --> 02:11:35.980
ниже стекпоинтера.

02:11:35.980 --> 02:11:36.900
А у нас СВЦ актуально?

02:11:37.540 --> 02:11:39.880
Нет. Это не СВЦ,

02:11:40.060 --> 02:11:42.000
это операционка гарантирует.

02:11:42.720 --> 02:11:42.900
А.

02:11:43.440 --> 02:11:46.160
Ну, даже, я думаю, вот эта гарантия

02:11:46.160 --> 02:11:46.960
уже олимпиада.

02:11:47.540 --> 02:11:49.820
Я не верю, насколько эта антидашная конвенция

02:11:49.820 --> 02:11:50.640
гарантировала.

02:11:51.980 --> 02:11:53.620
Ну, здесь я уже так

02:11:53.620 --> 02:11:55.240
затрудняюсь сказать,

02:11:56.280 --> 02:11:57.140
чья это гарантия.

02:11:57.200 --> 02:11:58.380
То есть под Linux это так.

02:12:00.120 --> 02:12:01.720
Под другими системами, которые

02:12:01.720 --> 02:12:03.800
используют подобную конвенцию,

02:12:03.940 --> 02:12:04.760
так ли это?

02:12:06.380 --> 02:12:07.640
Не могу сказать.

02:12:09.400 --> 02:12:10.180
Ну, у нас так.

02:12:10.940 --> 02:12:12.320
У нас только одна винда Linux.

02:12:14.820 --> 02:12:15.900
Под MacOS

02:12:15.900 --> 02:12:17.080
то же самое, что под Linux.

02:12:19.140 --> 02:12:19.760
Ну, оно

02:12:19.760 --> 02:12:21.420
BSD, на самом деле.

02:12:21.980 --> 02:12:23.580
Тоже все время ядра, и там

02:12:23.580 --> 02:12:24.240
то же самое.

02:12:26.000 --> 02:12:27.620
Вот. Поэтому, если брать такие

02:12:27.620 --> 02:12:29.840
крупные операционки, широко известные,

02:12:30.480 --> 02:12:31.000
то вот

02:12:31.000 --> 02:12:32.760
это правда.

02:12:33.880 --> 02:12:36.020
Если брать какую-нибудь большую экзотику,

02:12:36.200 --> 02:12:37.720
я не верю, что там

02:12:37.720 --> 02:12:39.520
их редзон будет действовать. Но под Linux

02:12:39.520 --> 02:12:40.940
это так.

02:12:42.120 --> 02:12:43.100
А как под

02:12:43.100 --> 02:12:45.400
System 5 вызывать

02:12:45.400 --> 02:12:48.080
splitf, там, send, float, int, float?

02:12:48.360 --> 02:12:49.240
Я же то, что сказал.

02:12:50.180 --> 02:12:51.760
Первое, сочи себя, Гульен,

02:12:51.980 --> 02:12:53.740
идет в r, d, i.

02:12:54.900 --> 02:12:55.800
Второе, сочи себя,

02:12:55.800 --> 02:12:57.820
в r, s, i.

02:12:58.160 --> 02:12:59.540
Третье, сочи себя,

02:12:59.760 --> 02:13:00.980
в r, d, x.

02:13:01.760 --> 02:13:03.680
Первый, с плавающей точкой,

02:13:03.840 --> 02:13:05.140
идет в x, n, 0.

02:13:05.480 --> 02:13:08.320
Второе, с плавающей точкой, в x, n, 1.

02:13:08.760 --> 02:13:10.160
И так, пока у вас не кончится

02:13:10.160 --> 02:13:12.020
регистр. Когда регистры

02:13:12.020 --> 02:13:13.720
кончились, то дальше

02:13:13.720 --> 02:13:15.100
аргументы начинают

02:13:15.100 --> 02:13:17.720
складываться на степ, в том

02:13:17.720 --> 02:13:19.200
порядке, в котором

02:13:19.200 --> 02:13:21.780
они у вас были

02:13:21.980 --> 02:13:22.820
в аргументах.

02:13:22.820 --> 02:13:24.200
И этот принтер, он

02:13:24.200 --> 02:13:26.260
берет на себя ответственность,

02:13:26.380 --> 02:13:28.920
какой регистр, в пользу какой.

02:13:29.020 --> 02:13:30.620
Да. Почему и

02:13:30.620 --> 02:13:31.520
важно

02:13:31.520 --> 02:13:35.260
правильно указывать

02:13:35.260 --> 02:13:36.520
в строке формата

02:13:36.520 --> 02:13:38.640
вот процентик тип

02:13:38.640 --> 02:13:40.040
и тип аргумента.

02:13:41.100 --> 02:13:42.260
В традиционно убитом мире

02:13:42.260 --> 02:13:43.200
вы можете

02:13:43.200 --> 02:13:45.980
это соглашение

02:13:45.980 --> 02:13:48.460
могло нарушать. Например, вы можете

02:13:48.460 --> 02:13:50.480
сказать, я хочу напечатать

02:13:50.480 --> 02:13:51.720
процентик,

02:13:51.980 --> 02:13:55.060
ум, целое число без знаков,

02:13:55.060 --> 02:13:57.060
и отдать туда флот.

02:13:57.060 --> 02:14:00.060
И оно вам напечатает

02:14:00.060 --> 02:14:02.060
представление флота,

02:14:02.060 --> 02:14:04.060
как вот оно по битикам,

02:14:04.060 --> 02:14:06.060
так сказать, по этикам

02:14:06.060 --> 02:14:08.060
состоит.

02:14:08.060 --> 02:14:10.060
В существенном убитом мире,

02:14:10.060 --> 02:14:12.060
если вы такое сделаете,

02:14:12.060 --> 02:14:14.060
вы получите мусор.

02:14:14.060 --> 02:14:16.060
Потому что, когда

02:14:16.060 --> 02:14:18.060
вы сказали, что у вас

02:14:18.060 --> 02:14:20.060
аргумент сочисленный,

02:14:20.060 --> 02:14:21.820
он будет искаться в целочисленном,

02:14:21.820 --> 02:14:23.820
в разночисленном месте.

02:14:23.820 --> 02:14:25.820
А если аргумент с плавающей точкой,

02:14:25.820 --> 02:14:27.820
он будет искаться в месте

02:14:27.820 --> 02:14:29.820
плавающей точки.

02:14:29.820 --> 02:14:31.820
И под виндой

02:14:31.820 --> 02:14:33.820
все, что вы получите, вы получите просто

02:14:33.820 --> 02:14:35.820
мусор в этом месте, но у вас

02:14:35.820 --> 02:14:37.820
ничего не сломается.

02:14:37.820 --> 02:14:39.820
А под линуксом

02:14:39.820 --> 02:14:41.820
у вас не просто будет мусор,

02:14:41.820 --> 02:14:43.820
у вас еще все остальные аргументы

02:14:43.820 --> 02:14:45.820
могут поехать.

02:14:51.820 --> 02:14:53.820
И все остальные аргументы могут

02:14:53.820 --> 02:14:55.820
появиться с отключением этого.

02:14:55.820 --> 02:14:57.820
То, что...

02:14:57.820 --> 02:14:59.820
Ну, есть флаг, как это называется.

02:14:59.820 --> 02:15:01.820
Ну, вот.

02:15:01.820 --> 02:15:03.820
Игре, значит, такого вам

02:15:03.820 --> 02:15:05.820
не обещают.

02:15:05.820 --> 02:15:07.820
Да.

02:15:07.820 --> 02:15:09.820
Но вот

02:15:09.820 --> 02:15:11.820
юзерстрейс...

02:15:11.820 --> 02:15:13.820
Вообще, мы с вами в курсе про юзерстрейс.

02:15:13.820 --> 02:15:15.820
Потому что

02:15:15.820 --> 02:15:17.820
ядро — это отдельная история.

02:15:17.820 --> 02:15:19.820
И ядро — это, честно говоря,

02:15:19.820 --> 02:15:21.820
даже больше курса операционного, чем

02:15:21.820 --> 02:15:23.820
смартфон.

02:15:23.820 --> 02:15:25.820
То есть, я думаю,

02:15:25.820 --> 02:15:27.820
может, это не будет прикольно,

02:15:27.820 --> 02:15:29.820
но это специализировано

02:15:29.820 --> 02:15:31.820
не совсем то,

02:15:31.820 --> 02:15:33.820
чем мы занимаемся.

02:15:33.820 --> 02:15:35.820
— Можете еще раз кратко повторить,

02:15:35.820 --> 02:15:37.820
для чего вам нужно указывать

02:15:37.820 --> 02:15:39.820
количество флотов, аргументов,

02:15:39.820 --> 02:15:41.820
плеера и икс?

02:15:41.820 --> 02:15:43.820
— Требуется по конвенции.

02:15:43.820 --> 02:15:45.820
Конвенция требует, чтобы это было сделано.

02:15:45.820 --> 02:15:47.820
Если этого не сделаешь,

02:15:47.820 --> 02:15:49.820
у тебя принт реально покрапшет.

02:15:49.820 --> 02:15:51.820
— Еще. Для чего нужен

02:15:51.820 --> 02:15:53.820
R-flags?

02:15:53.820 --> 02:15:55.820
— R-flags — это регистр флагов,

02:15:55.820 --> 02:15:57.820
который теперь называется R,

02:15:57.820 --> 02:15:59.820
потому что он стал

02:15:59.820 --> 02:16:01.820
64-битным вместе со всеми остальными

02:16:01.820 --> 02:16:03.820
эписками.

02:16:03.820 --> 02:16:05.820
Да, но содержательные эпитеты у него

02:16:05.820 --> 02:16:07.820
находятся все равно в нашей части,

02:16:07.820 --> 02:16:09.820
как были, так и остались.

02:16:09.820 --> 02:16:11.820
То есть флаги переноса, нуля

02:16:11.820 --> 02:16:13.820
и подобное —

02:16:13.820 --> 02:16:15.820
все они остались, по-прежнему

02:16:15.820 --> 02:16:17.820
так же работают.

02:16:17.820 --> 02:16:19.820
Просто регистр, как и все остальные,

02:16:19.820 --> 02:16:21.820
теперь 64-битный.

02:16:21.820 --> 02:16:23.820
— Пойдем.

02:16:23.820 --> 02:16:25.820
— Просто про функции.

02:16:25.820 --> 02:16:27.820
Какая функция принимает

02:16:27.820 --> 02:16:29.820
флаговый инк и флот?

02:16:29.820 --> 02:16:31.820
И если нам нужно передать в неправильном порядке,

02:16:31.820 --> 02:16:33.820
то нам, в данном случае,

02:16:33.820 --> 02:16:35.820
нужно представление флота и флот.

02:16:35.820 --> 02:16:37.820
Ну, может быть, инк — специальный флот.

02:16:37.820 --> 02:16:39.820
Ну, вместе с в.

02:16:39.820 --> 02:16:41.820
Потому что, посмотрите, R-дай и

02:16:41.820 --> 02:16:43.820
в основном ноль. — Нет, нет, нет.

02:16:43.820 --> 02:16:45.820
Смотри, еще раз.

02:16:45.820 --> 02:16:47.820
Если передать их в неправильном порядке,

02:16:47.820 --> 02:16:49.820
то

02:16:49.820 --> 02:16:51.820
сис-пайк

02:16:51.820 --> 02:16:53.820
просто об этом

02:16:53.820 --> 02:16:55.820
не узнает.

02:16:55.820 --> 02:16:57.820
Он даже правильно будет

02:16:57.820 --> 02:16:59.820
интерпретировать.

02:16:59.820 --> 02:17:01.820
Нет, здесь не будет им представления делать.

02:17:01.820 --> 02:17:03.820
Еще раз.

02:17:03.820 --> 02:17:05.820
У тебя целочисленный

02:17:05.820 --> 02:17:07.820
аргумент отправляется

02:17:07.820 --> 02:17:09.820
в R-дай и

02:17:09.820 --> 02:17:11.820
плавающая точка в xml.

02:17:15.820 --> 02:17:17.820
То есть у тебя оно будет смотреть

02:17:17.820 --> 02:17:19.820
вот в это место или в это место

02:17:19.820 --> 02:17:21.820
в зависимости от

02:17:21.820 --> 02:17:23.820
типа данных.

02:17:23.820 --> 02:17:25.820
Да.

02:17:25.820 --> 02:17:27.820
— Во-первых,

02:17:29.820 --> 02:17:31.820
какая структура?

02:17:31.820 --> 02:17:33.820
Они передаются в регистр?

02:17:33.820 --> 02:17:35.820
— Еще раз.

02:17:35.820 --> 02:17:37.820
С структурами там

02:17:37.820 --> 02:17:39.820
темная история. Зависит от

02:17:39.820 --> 02:17:41.820
размера структуры.

02:17:41.820 --> 02:17:43.820
Если структуры маленькие,

02:17:43.820 --> 02:17:45.820
которые уменьшаются

02:17:45.820 --> 02:17:47.820
в регистре, они могут быть

02:17:47.820 --> 02:17:49.820
переданы в регистр.

02:17:49.820 --> 02:17:51.820
Если они в регистр не лезут,

02:17:51.820 --> 02:17:53.820
они будут переданы на стеки.

02:17:53.820 --> 02:17:55.820
Вот сколько там местных занимает.

02:17:55.820 --> 02:17:57.820
И там тоже

02:17:57.820 --> 02:17:59.820
разные хитрые штуки.

02:17:59.820 --> 02:18:01.820
Если у тебя, скажем, второй аргумент

02:18:01.820 --> 02:18:03.820
это вот большая структура,

02:18:03.820 --> 02:18:05.820
которая в регистре не лезет.

02:18:05.820 --> 02:18:07.820
Я, честно говоря, не помню, что там происходит,

02:18:07.820 --> 02:18:09.820
но что-то дикое.

02:18:11.820 --> 02:18:13.820
Может быть, указатель, да.

02:18:13.820 --> 02:18:15.820
То есть

02:18:15.820 --> 02:18:17.820
там что-то заморочено.

02:18:17.820 --> 02:18:19.820
Но структуры может

02:18:19.820 --> 02:18:21.820
сама целиком находиться, если это на стеке.

02:18:21.820 --> 02:18:23.820
Не через регистр идет,

02:18:23.820 --> 02:18:25.820
а просто, как говорится, функцию.

02:18:25.820 --> 02:18:27.820
Скажем, 32 бита.

02:18:27.820 --> 02:18:29.820
Оказывается, это структура.

02:18:29.820 --> 02:18:31.820
Эта структура просто лезет на стеке.

02:18:33.820 --> 02:18:35.820
— Еще в чем смысл зоны, если

02:18:35.820 --> 02:18:37.820
функция, если нужны какие-то

02:18:37.820 --> 02:18:39.820
переменные?

02:18:39.820 --> 02:18:41.820
— В смысле в том, что если тебе нужно сохранять

02:18:41.820 --> 02:18:43.820
меньше 128 байт

02:18:43.820 --> 02:18:45.820
данных,

02:18:45.820 --> 02:18:47.820
то ты можешь просто не трогать стекпоинт.

02:18:49.820 --> 02:18:51.820
Такая мелкая оптимизация, что

02:18:51.820 --> 02:18:53.820
стекпоинтер можете не опускать

02:18:53.820 --> 02:18:55.820
и не возвращать на место.

02:18:55.820 --> 02:18:57.820
— Все же, условно,

02:18:57.820 --> 02:18:59.820
один раз опускается стекпоинтер,

02:18:59.820 --> 02:19:01.820
и все параметры...

02:19:01.820 --> 02:19:03.820
— А так ты можешь ноль раз

02:19:03.820 --> 02:19:05.820
опускать стекпоинтер.

02:19:05.820 --> 02:19:07.820
Если размер

02:19:07.820 --> 02:19:09.820
всех твоих локальных

02:19:09.820 --> 02:19:11.820
переменных не превышает

02:19:11.820 --> 02:19:13.820
128 байт,

02:19:13.820 --> 02:19:15.820
то ты стекпоинтер можешь

02:19:15.820 --> 02:19:17.820
не опускать.

02:19:17.820 --> 02:19:19.820
— И насколько сильно это оптимизирует?

02:19:19.820 --> 02:19:21.820
— На одну команду.

02:19:21.820 --> 02:19:23.820
— На две команды.

02:19:25.820 --> 02:19:27.820
— Не допускаем записку на поднимающие.

02:19:27.820 --> 02:19:29.820
— Да.

02:19:29.820 --> 02:19:31.820
То есть вот такая просто

02:19:31.820 --> 02:19:33.820
особенность.

02:19:33.820 --> 02:19:35.820
Как сделать это?

02:19:35.820 --> 02:19:37.820
Ты можешь

02:19:37.820 --> 02:19:39.820
пользоваться этим, можешь не пользоваться.

02:19:41.820 --> 02:19:43.820
Тебя никто

02:19:43.820 --> 02:19:45.820
не заставляет использовать

02:19:45.820 --> 02:19:47.820
эту Redzone.

02:19:47.820 --> 02:19:49.820
Но если хочешь, ты можешь

02:19:49.820 --> 02:19:51.820
использовать эту фичу.

02:19:51.820 --> 02:19:53.820
Shadow Space — это более

02:19:53.820 --> 02:19:55.820
взрослая штука. Вы должны

02:19:55.820 --> 02:19:57.820
ее выделять, когда кого-то

02:19:57.820 --> 02:19:59.820
вызываете. Не выделите —

02:19:59.820 --> 02:20:01.820
он попортит вам стек.

02:20:01.820 --> 02:20:03.820
А Redzone,

02:20:03.820 --> 02:20:05.820
так как это ниже стекпоинтера,

02:20:05.820 --> 02:20:07.820
то это заморочки операционной

02:20:07.820 --> 02:20:09.820
системы, а не вас.

02:20:09.820 --> 02:20:11.820
А для вас это чистый фича.

02:20:11.820 --> 02:20:13.820
Не хотите — не пользуйтесь.

02:20:13.820 --> 02:20:15.820
— То есть

02:20:15.820 --> 02:20:17.820
в случае с Redzone,

02:20:17.820 --> 02:20:19.820
я вам не буду выделять.

02:20:19.820 --> 02:20:21.820
Сейчас.

02:20:21.820 --> 02:20:23.820
В случае с Redzone

02:20:23.820 --> 02:20:25.820
ты можешь

02:20:25.820 --> 02:20:27.820
писать и ниже стекпоинтера

02:20:27.820 --> 02:20:29.820
на 128 байт.

02:20:29.820 --> 02:20:31.820
А в случае

02:20:31.820 --> 02:20:33.820
с Shadow Space я

02:20:33.820 --> 02:20:35.820
как пользователь...

02:20:35.820 --> 02:20:37.820
— У тебя есть просто выше адреса

02:20:37.820 --> 02:20:39.820
возврата, у тебя есть 32 байтика, которые

02:20:39.820 --> 02:20:41.820
тоже вот тебе дают.

02:20:43.820 --> 02:20:45.820
То есть Redzone тебе дает данные ниже

02:20:45.820 --> 02:20:47.820
стекпоинтера, а Shadow Space

02:20:47.820 --> 02:20:49.820
дает тебе место

02:20:49.820 --> 02:20:51.820
выше адреса возврата.

02:20:55.820 --> 02:20:57.820
— А стек

02:20:57.820 --> 02:20:59.820
как портится в случае с Shadow Space?

02:20:59.820 --> 02:21:01.820
— Никак не портится.

02:21:01.820 --> 02:21:03.820
Даже он только что нарисовал

02:21:03.820 --> 02:21:05.820
Shadow Space.

02:21:05.820 --> 02:21:07.820
— Да, ладно.

02:21:07.820 --> 02:21:09.820
Вы рассказывали историю, как...

02:21:09.820 --> 02:21:11.820
— Я не

02:21:11.820 --> 02:21:13.820
довыделил Shadow Space.

02:21:13.820 --> 02:21:15.820
Я дал Shadow Space не 32 байтика,

02:21:15.820 --> 02:21:17.820
а 8.

02:21:17.820 --> 02:21:19.820
— Но это вы как пользователь, который

02:21:19.820 --> 02:21:21.820
пишет программу.

02:21:21.820 --> 02:21:23.820
— Как тот, который вызывает

02:21:23.820 --> 02:21:25.820
функцию.

02:21:25.820 --> 02:21:27.820
Я обратил

02:21:27.820 --> 02:21:29.820
внимание, что Shadow Space

02:21:29.820 --> 02:21:31.820
всегда, если нормально,

02:21:31.820 --> 02:21:33.820
оно не привязано к размеру аргументов.

02:21:35.820 --> 02:21:37.820
Исходно кажется,

02:21:37.820 --> 02:21:39.820
если вы понимаете, зачем это сделано,

02:21:39.820 --> 02:21:41.820
что оно должно соответствовать

02:21:41.820 --> 02:21:43.820
аргументам, чтобы они

02:21:43.820 --> 02:21:45.820
могли быть сброшены в степ.

02:21:45.820 --> 02:21:47.820
Но оно,

02:21:47.820 --> 02:21:49.820
как бы,

02:21:49.820 --> 02:21:51.820
хоть для этого было спроектировано,

02:21:51.820 --> 02:21:53.820
постулировано оно было не так.

02:21:53.820 --> 02:21:55.820
Постулировано, что любая функция

02:21:55.820 --> 02:21:57.820
получается 32 байтика.

02:21:57.820 --> 02:21:59.820
Ну и здесь

02:21:59.820 --> 02:22:01.820
в некотором смысле аналогично

02:22:01.820 --> 02:22:03.820
постулировано, что

02:22:03.820 --> 02:22:05.820
любая функция

02:22:05.820 --> 02:22:07.820
получает вот этот Red Zone.

02:22:07.820 --> 02:22:09.820
Но обратите внимание,

02:22:09.820 --> 02:22:11.820
что Red Zone

02:22:11.820 --> 02:22:13.820
полезна только

02:22:13.820 --> 02:22:15.820
листовым функциям.

02:22:15.820 --> 02:22:17.820
Если вы

02:22:17.820 --> 02:22:19.820
кого-то вызываете,

02:22:19.820 --> 02:22:21.820
то никакой Red Zone

02:22:21.820 --> 02:22:23.820
у вас нет.

02:22:23.820 --> 02:22:25.820
— У нас есть Red Zone,

02:22:25.820 --> 02:22:27.820
я перед вызовом функции

02:22:27.820 --> 02:22:29.820
ее поиспользую,

02:22:29.820 --> 02:22:31.820
потом с длинной степ-поинтера вызову функцию.

02:22:31.820 --> 02:22:33.820
— Да, но зачем тебе так делать,

02:22:33.820 --> 02:22:35.820
когда ты можешь просто сразу

02:22:35.820 --> 02:22:37.820
с длинной степ-поинтера?

02:22:37.820 --> 02:22:39.820
— Ну да, мы просто к тому,

02:22:39.820 --> 02:22:41.820
что если ты все равно собрал

02:22:41.820 --> 02:22:43.820
с длинной степ-поинтер,

02:22:43.820 --> 02:22:45.820
то ты можешь убрать.

02:22:47.820 --> 02:22:49.820
Ну, насколько ты хочешь

02:22:49.820 --> 02:22:51.820
настолько оптимизировать —

02:22:51.820 --> 02:22:53.820
вопрос.

02:22:53.820 --> 02:22:55.820
Обычно

02:22:55.820 --> 02:22:57.820
не очень с этим

02:22:57.820 --> 02:22:59.820
заморачиваются.

02:22:59.820 --> 02:23:01.820
Бывает, конечно, что компиляторы

02:23:01.820 --> 02:23:03.820
специальным образом обрабатывают

02:23:03.820 --> 02:23:05.820
парочку начальных ифов.

02:23:05.820 --> 02:23:07.820
Например, если ваша функция

02:23:07.820 --> 02:23:09.820
начинается с иф какой-то аргумент

02:23:09.820 --> 02:23:11.820
меньше нуля, тогда летел

02:23:11.820 --> 02:23:13.820
какой-нибудь код возврата.

02:23:13.820 --> 02:23:15.820
Вот такие ифы бывают,

02:23:15.820 --> 02:23:17.820
что компиляторы ставят

02:23:17.820 --> 02:23:19.820
очень рано,

02:23:19.820 --> 02:23:21.820
раньше, чем стек-фрейм

02:23:21.820 --> 02:23:23.820
вообще создается.

02:23:23.820 --> 02:23:25.820
Но такое бывает не очень часто.

02:23:25.820 --> 02:23:27.820
Как правило, функция начинается

02:23:27.820 --> 02:23:29.820
с пролога, который

02:23:29.820 --> 02:23:31.820
сохраняет регистры,

02:23:31.820 --> 02:23:33.820
двигает стек-поинтер,

02:23:33.820 --> 02:23:35.820
потом целая функция,

02:23:35.820 --> 02:23:37.820
и в конце — эпилог,

02:23:37.820 --> 02:23:39.820
который возвращается обратно.

02:23:39.820 --> 02:23:41.820
— Ого!

02:23:41.820 --> 02:23:45.820
Ну и на этом

02:23:45.820 --> 02:23:47.820
про 64-битные

02:23:47.820 --> 02:23:49.820
особенности, наверное,

02:23:49.820 --> 02:23:51.820
все.

02:23:51.820 --> 02:23:53.820
Еще есть замечание.

02:23:53.820 --> 02:23:55.820
Вспоминаем, что под виндой

02:23:55.820 --> 02:23:57.820
глобальные имена, они требовали

02:23:57.820 --> 02:23:59.820
добавления начальных подчеркиваний.

02:23:59.820 --> 02:24:01.820
Я вам говорил, это можно решить

02:24:01.820 --> 02:24:03.820
просто ключиком.

02:24:03.820 --> 02:24:05.820
Для нас —

02:24:05.820 --> 02:24:07.820
подчеркивание в начале.

02:24:07.820 --> 02:24:09.820
Под 64-битыми

02:24:09.820 --> 02:24:11.820
никаких подчеркиваний,

02:24:11.820 --> 02:24:13.820
потому что имена называются

02:24:13.820 --> 02:24:15.820
вот как они есть, так и называются.

02:24:15.820 --> 02:24:17.820
То есть это ключик

02:24:17.820 --> 02:24:19.820
для добавления подчеркивания

02:24:19.820 --> 02:24:21.820
в 64-битном мире под виндой

02:24:21.820 --> 02:24:23.820
не нужен. Ваше название

02:24:23.820 --> 02:24:25.820
один к одному, да.

02:24:25.820 --> 02:24:27.820
— А 2D-тесты будут на винде?

02:24:27.820 --> 02:24:29.820
— Там будет сказано.

02:24:29.820 --> 02:24:31.820
Ну, фактически да. Там будет сказано,

02:24:31.820 --> 02:24:33.820
какую коньянку использовать.

02:24:33.820 --> 02:24:35.820
И, честно говоря, там

02:24:35.820 --> 02:24:37.820
коньянки будет мало,

02:24:37.820 --> 02:24:39.820
поэтому даже если вы пишете

02:24:39.820 --> 02:24:41.820
некую другую... — А все можно

02:24:41.820 --> 02:24:43.820
вызывать функцию там.

02:24:43.820 --> 02:24:45.820
— Смотри, обычный

02:24:45.820 --> 02:24:47.820
обычный

02:24:47.820 --> 02:24:49.820
указатель конвенции —

02:24:49.820 --> 02:24:51.820
это вот ситекл,

02:24:51.820 --> 02:24:53.820
и так далее, да. Вот они,

02:24:53.820 --> 02:24:55.820
как я уже сказал, влияют

02:24:55.820 --> 02:24:57.820
только на 32 бита.

02:24:57.820 --> 02:24:59.820
— А-а. — В 64-битном мире

02:24:59.820 --> 02:25:01.820
на писательных мультиках

02:25:01.820 --> 02:25:03.820
оно

02:25:03.820 --> 02:25:05.820
скомпилируется, но компилятор

02:25:05.820 --> 02:25:07.820
их проинновирует.

02:25:07.820 --> 02:25:09.820
— А-а.

02:25:09.820 --> 02:25:11.820
— Нет, в смысле,

02:25:11.820 --> 02:25:13.820
компилятор их все так использует?

02:25:13.820 --> 02:25:15.820
— Нет. Это

02:25:15.820 --> 02:25:17.820
зависит от того, какой у вас

02:25:17.820 --> 02:25:19.820
таргет,

02:25:19.820 --> 02:25:21.820
под какую операционку

02:25:21.820 --> 02:25:23.820
вы компилируетесь.

02:25:23.820 --> 02:25:25.820
У компилятора есть таргет.

02:25:25.820 --> 02:25:27.820
Если ничего не указывается,

02:25:27.820 --> 02:25:29.820
то таргет — это ваша текущая

02:25:29.820 --> 02:25:31.820
операционка.

02:25:31.820 --> 02:25:33.820
Ну, а если компилятор

02:25:33.820 --> 02:25:35.820
имеет кросс-компилированный, например,

02:25:35.820 --> 02:25:37.820
слабый, то ты можешь

02:25:37.820 --> 02:25:39.820
указать ему специальные ключи,

02:25:39.820 --> 02:25:41.820
и тогда

02:25:41.820 --> 02:25:43.820
он будет строить код

02:25:43.820 --> 02:25:45.820
по правилам вот той системы,

02:25:45.820 --> 02:25:47.820
под которую ты сказал,

02:25:47.820 --> 02:25:49.820
какой у тебя таргет.

02:25:51.820 --> 02:25:53.820
И, если говорить

02:25:53.820 --> 02:25:55.820
про вот x86

02:25:55.820 --> 02:25:57.820
и фланг, я знаю, что

02:25:57.820 --> 02:25:59.820
у него есть магический

02:25:59.820 --> 02:26:01.820
атрибут,

02:26:01.820 --> 02:26:03.820
который вы можете поставить

02:26:03.820 --> 02:26:05.820
на функцию через

02:26:05.820 --> 02:26:07.820
два подчеркивания атрибута,

02:26:07.820 --> 02:26:09.820
два подчеркивания

02:26:09.820 --> 02:26:11.820
и вы можете

02:26:11.820 --> 02:26:13.820
вот этим атрибутом

02:26:13.820 --> 02:26:15.820
переключить

02:26:15.820 --> 02:26:17.820
конвенцию вызова

02:26:17.820 --> 02:26:19.820
конкретной функции

02:26:19.820 --> 02:26:21.820
вот на другую.

02:26:27.820 --> 02:26:29.820
Если вы можете сказать

02:26:29.820 --> 02:26:31.820
компилятору, я хочу, чтобы

02:26:31.820 --> 02:26:33.820
ты вот эту функцию сгенерировал

02:26:33.820 --> 02:26:35.820
в такой конвенции вызова.

02:26:37.820 --> 02:26:39.820
И он даже правильно сделает

02:26:39.820 --> 02:26:41.820
вызов этой функции

02:26:41.820 --> 02:26:43.820
из другого места. Другое дело,

02:26:43.820 --> 02:26:45.820
что это жизнеспособно

02:26:45.820 --> 02:26:47.820
только вот внутри вас.

02:26:47.820 --> 02:26:49.820
Потому что

02:26:49.820 --> 02:26:51.820
все внешние функции,

02:26:51.820 --> 02:26:53.820
они, конечно же,

02:26:53.820 --> 02:26:55.820
имеют дефолтную конвенцию.

02:27:07.820 --> 02:27:09.820
А почему длинная система?

02:27:09.820 --> 02:27:11.820
Потому что

02:27:11.820 --> 02:27:13.820
обычно нормальный код

02:27:13.820 --> 02:27:15.820
напрямую не вызывает.

02:27:15.820 --> 02:27:17.820
Нормальный код вызывает

02:27:17.820 --> 02:27:19.820
системные библиотеки,

02:27:19.820 --> 02:27:21.820
которые уже вызывают СИСКОЛы.

02:27:21.820 --> 02:27:23.820
Прямые СИСКОЛы это,

02:27:23.820 --> 02:27:25.820
честно говоря, большая редкость

02:27:25.820 --> 02:27:27.820
нормальных кодов.

02:27:27.820 --> 02:27:29.820
То есть не всякие системные защиты

02:27:29.820 --> 02:27:31.820
и бла-бла-бла.

02:27:31.820 --> 02:27:33.820
Поэтому

02:27:33.820 --> 02:27:35.820
открыть ту же самую

02:27:35.820 --> 02:27:37.820
DLL-ку, подвинуться,

02:27:37.820 --> 02:27:39.820
загрузить код и исполнять,

02:27:39.820 --> 02:27:41.820
и оно

02:27:41.820 --> 02:27:43.820
полностью работает.

02:27:43.820 --> 02:27:45.820
Точнее, что я убит,

02:27:45.820 --> 02:27:47.820
у меня там есть некоторые сложности,

02:27:47.820 --> 02:27:49.820
но они связаны

02:27:49.820 --> 02:27:51.820
чуть-чуть другим.

02:27:51.820 --> 02:27:53.820
Они связаны

02:27:53.820 --> 02:27:55.820
с TLS.

