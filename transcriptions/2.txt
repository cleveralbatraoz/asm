намного. Но есть особенность. Память состоит из страничек, о чём вы, наверное, помните, но о них, конечно, поговорим более подробно, но позже.
И вот, в связи с особенностями каждой такой конфликционной системы, они стараются выделять физическую память только по мере необходимости.
То, что у вас выделено под стек, на самом деле оно, в прямом смысле этого слова, не выделено.
Оно только зарезервировано. В смысле, диапазон адресов зарезервирован под стек.
Так.
А физической памяти туда не сопоставлено.
И в камере линкарных работают.
В зрении памяти происходит следующее.
Когда вы обращаетесь на одну страничку ближе, чем последняя выделенная, то у вас происходит фетч-фолл.
Управление получает система.
Система видит, что это фетч-фолл на стеке, где...
Место быть должно, но оно еще не выделено.
Выделяет и опускает вот эту вот гард-страничку на одну нишу.
В итоге выделение происходит по одной страничке.
Поэтому, если вы опустите стек-поинтер там, например, на 10 килобайт,
то это означает, что у вас есть реальные шансы пропустить эту гард-страничку.
И если вы обратитесь по вот этому новому значению,
ESP, которое на 10 килобайт ниже,
вы можете просто перешагнуть страничку, по которой операционка определяет, что стек нужно расширить.
Соответственно, при удалении памяти больше странички,
на стеке следует пройтись по каждой страничке, то есть с шагом 4 килобайта,
и просто ее потрогать как-нибудь.
Прочитать оттуда байтик, закрепить,
записать туда байтик, неважно.
Ну вот, совершив какое-то действие с шагом 4 килобайта,
что, да, начиная, конечно, сверху, сверху по прорисовке,
то у вас не могла произойти ситуация, что стек вот такой вот не выделен.
Вот такая ситуация.
В принципе, в первой лаборатории вы на этом и снизу шли,
потому что нифига вам больше 4 килобайта данных.
И вообще не надо.
Но в следующих лабораторных это может быть критично.
Понятно?
Сейчас, еще раз. А чем грозит, если не пощупать странички?
Если не пощупать, то, еще раз, выделение происходит,
когда происходит падение на карт странички, вот на которой сразу за концом,
если ты обходишь ее и обращаешься в следующую страничку,
то оно не обрабатывается специальным образом, и программа просто падает.
Нет, а пока со стороны программы или со стороны рисунка?
Ну, вообще со стороны программы, потому что операционка постулирует такое поведение,
поэтому это как бы метод документации.
Так что у нас было на архитектуре, кто помнит еще,
вот это задокументированное поведение, поэтому, если вы так не делаете,
то виноваты вы.
Это про Винду, да, было?
Ну, про Винду это точно, про другие операционки я не уверен.
Правильно сказать, специальные операционки.
То есть они тоже так же лениво выделяют память, это точно.
Но вот такие особенности этого ленивого выделения памяти,
я не могу вам сказать настолько подробно.
Ну, про эти странички еще раз, у нас это будет, но там, в конце курса.
Потому что это такая чистая теория, никакие факты на это не предполагаются.
Поэтому пока, пока имеет смысл представлять что-то более полезное.
И на самом деле, можно пойти в две стороны.
Можно либо пойти в 64 бита, либо пойти в плавающую точку.
Вот, что вам больше нравится.
Плавающая точка.
Все, я говорю, плавающая точка, кто хочет.
Раз, два, три, четыре, пять.
Четыре бита.
Раз, два, три, четыре, пять.
Серьезно?
А, шесть.
Ну, вы же поднимайте руки, я могу считать.
Раз, два, три, четыре, пять.
Пять.
Половина.
Ты куда?
Половина.
Ну, вот половина победила.
Значит, мы идем в 64 бита.
В принципе, через два будет шутка.
В принципе, через два будет шутка идти более исторически правильно.
А через 64 бита идти, наверное, более практически полезно.
Потому что 64 бита – это текущее состояние.
И тогда можно рассчитывать, например, что в следующей лаборатории вы можете делать 32 или 64 бита.
По вашим условиям.
И первая лабораторная – это 32 бита.
Да.
Первая лабораторная – это 132 бита.
И конвенция вызова – 7.
Итак, 64 бита – что это такое?
Это очередное 100-тысячное расширение архитектуры ИЦ-86.
Во-первых, мы еще раз вспоминаем, что ИЦ-86 от рождения была какой архитектурой?
16 битой.
16 битой, да.
Потом в супердалекий атлас времена процессора И-80386 добавилось 32-битное расширение в режим работы,
а режим это тоже, как говорится, почек,
который позволил использовать 32-битные регистры, 32-битную арифметику и, самое главное, 32-битную адресацию.
Вы очень счастливы, что не застали 16-битный мир.
Адресация в 16-битном мире была полным адом.
Немножко, что там происходило, мы рассмотрим тоже попозже, но, чтобы не наказать вашу плохую психику, мы это поверхностно рассмотрим.
Это было реально больно.
Так вот, 32-битный мир позволил адресацию сильно упростить.
И вот то, что происходит сегодня, 64 битов, не так уж принципиально изменилось.
То есть 16-32 битов был очень существенный переход.
32-64 такой существенно менее крупный, заметный и так далее.
Но отчасти почему?
Отчасти потому, что уже было намного больше состав.
И поэтому соображения об обратной совместимости, о упрощении, портировании и так далее, также были намного более сильны.
Если при переходе 16-32 народ прям ломал всё подряд ради светлого будущего,
то вот 32-64 уже ломали, честно говоря, меньше, чем нужно было бы поломать.
И поэтому наше будущее местами страдает на самом деле.
И поэтому наше будущее местами страдает на самом деле.
Это от того, что, не знаю, конечно, не доломали, но можно было бы лучше.
Итак, 64-битный режим.
Это специальный режим работы процессора.
И особенность его, что всякие расширения, которые добавили в 64-битный режим,
их сумели заковырять через специальную форму кодирования,
через специальные префиксы,
которые вы можете поставить перед командами, и в 16-битный режим.
То есть, если ваш процессор умеет 32 бита, то 32-битные регистры и так далее
доступны вам даже из 16-битного режима.
Более того, честно говоря, внутри команды вида ADD, EAX, ECX и ADD, AX, CX
это одна и та же команда, один и тот же код, и отличаются они только тем,
что в каком режиме вы интерпретируете этот код.
Если процессор работает...
В 32-битном режиме, то он интерпретирует как EAX.
Если в 16-битном режиме, то он интерпретирует как AX.
И у вас есть специальный байтик, префикс изменения битности данных,
который позволяет переключить на противоположную интерпретацию.
Ну да, противоположная интерпретация.
Поэтому...
Когда вы пишете команду ADD, AX, CX в 32-битном режиме,
она навалит длиннее, чем команда ADD, EAX, ECX.
Но содержит тот же самый код, просто дополнительный префикс,
что мы переключаемся в 16-битный режим.
То есть 32-битное расширение, оно было добавлено вот так вот фактически везде.
Через дополнительный префикс вы оказываетесь вот в противоположной битности.
В 64-битном режиме...
То есть 32-битное расширение, оно не такое.
Вот так вот просто взять и добавить префикс, к сожалению, там уже набор...
Это префикс вашей следующей команды в 16-битном режиме или префикс вашей следующей команды в 16-битном режиме?
Нет, это именно на одну команду есть.
То есть это как будто расширение кода команды.
Это не переключение режима процесса.
Это переключение интерпретации вот одной команды.
Это не переключение этой команды.
Да.
То есть в другом режиме это тоже надо использовать?
То есть еще раз, если ты хочешь команду ADD AXCX,
то единственный способ ее закодировать, это использовать ADD.
То есть это одна и та же команда с точки зрения кода.
А интерпретация этого кода зависит а от режима работы процессора,
б от наличия префикса переключения битности данных.
То есть в 16-битном режиме вы можете переключить битность данных?
Да.
То есть если вы захотите проверить цель...
8-битные регистры имеют свой собственный код,
и они этим префиксом изменения битности не управляют.
То есть вы можете добавить этот префикс, но он ничего не сделает с этой командой.
Этот префикс переключает вам 16 или 32 бит.
Если команда не использует 16 или 32 бит,
то тогда этот префикс делает ничего.
Большинство вот этих вот физических префиксов,
они безобидны в плане того, что если вы ставите их в команду,
которая неосмысленно взаимодействует с этим префиксом,
то из-за этого ничего не происходит.
Не все префиксы безобидны, но большинство вот так сидит.
Окей. Будет ли вот команда x и x добавить префикс 67, 66 и дальше выход команды?
Еще раз.
То, что вы говорите, это префикс?
66.
А для адресов из плюсов 67?
Да.
Для команды вот этого надо.
С регистрации давай 66.
Ну, 67, 66.
То есть даже два байта.
А оно проразное?
Другого не включают?
Ну да, здесь как бы хотел опустить.
На самом деле, с адресацией даже самое интересное,
если команда обращается к памяти,
у вас есть такой 16-битный режим адресации
и 30-битный режим адресации.
И опять-таки используется дефолт соответствующей битности,
и вы можете при помощи другого префикса переключить,
какого вида у вас адресация в команде.
Адресация через вот 16-битный способ или адресация через 30-битный.
Префикс кодировки.
Префикс изменения битности адреса.
Кодировки.
В смысле?
Еще раз, у нас здесь команда, она как-то закодирована.
Да.
Префикс, он как бы считается частью кода команды.
Да, да, вот я правильно.
А если у нас есть ADD формы,
когда у нас одно слагаемое,
и там появление определенного регистратора,
однобайтное ADD?
Ты что, про IELTS, ICH?
Нет, нет, имеется в виду однобайтная длина команды 1 байт.
Ну и что?
Имеет один оперант, ADD.
И она этот оперант прибавляет и не помнит какой-то регистр.
По-моему, в IELTS всегда.
Ну это типа как оптимизация, что мы в основном какой-то регистр часто что-то прибавляем,
и мы хотим закодировать это в один байт.
Нет, смотри.
Нет, нет, погоди.
Однобайтного прибавления нет,
потому что просто чтобы закодировать константу,
тебе нужно хотя бы один байт.
Нет, нет, там...
Есть команда ингредиентов.
Нет, нет, есть именно ADD,
там закодированный регистр куда-то добавляет,
а мы указываем регистр, который добавляется к этому регистру.
То есть, ну, условно ADD, IELTS, IELTS, он будет делать IELTS плюс равно IELTS.
Вот, а как ты вот 16 и 32 бита?
Хорошо.
Вот у тебя эта команда, она вот какая?
Ну да.
Она работает с исходным, 16 битным регистром.
Если она работает с 16 битным регистром как с данными,
то в 32 битном мире она будет интерпретироваться как команда,
работающая с аналогичным 32 битным регистром.
Если ты ничего не делаешь, то этот код означает вот это.
Если ты ставишь перед этим кодом префикс 0x66,
то интерпретация, да, кто это, изменяется на противоположную.
То есть, в 16 битном мире оно интерпретирует это как работу с 32 битным регистром,
а с 32 битным как с 16 битным.
То есть, еще раз, это интерпретация именно вот смысла команды.
Сколько там байтиков команда образует, это неважно.
Команда логически работает вот с этим регистром и процессором интерпретирует с таким образом.
И все эти дефолтные регистры, они тоже ведут себя аналогично.
То есть, переключается вот такой смысл битности команды.
А можно ли мы в рантайме менять битность?
Что, это в рантайме происходит?
Не-не, не битность.
Я понимаю, что там ссорятся.
Я имею в виду, можем ли мы в рантайме, особенно если мы исполняем все это в битном режиме,
если просто, типа, начать?
А, ну да, все ровно.
Переключить режим можно, но переключение режима, как режим работает, это при виде ровных действий.
То есть, на это нужна права ядра системы.
И если вы переключите режим, то система будет очень удивлена.
Поэтому, если только не вы сами себе, а операционная система,
даже если вы добудете себе эти права,
вы не хотите это сделать.
Потому что это покрашит операционную систему.
Ну, если виртуальный 16-битный режим.
Да?
Ну, если режим работы процессора похожий, пока мы их можем благополучно игнорировать,
я вам просто пока рассказываю ту часть, которая необходима для понимания происходящего.
То есть, первый важный факт, что 3D-битное расширение, оно было такое вот покрывающее все.
И возможность использования 32-бит связана с тем, ваш процессор 32-битный или нет.
Из другого режима, ну, только небольшие усилия, и вы получаете все, что там имеет ваш процессор.
В отличие от этого, 64-битный режим, это было совсем по-другому сделано.
Оно было сделано следующим образом.
Что вот эти всякие новые штучки, которые я вам расскажу сейчас,
они все работают только в 64-битном режиме.
То есть, то, что процессор умеет 64-бит,
все это видно только из 64-битного режима.
Из 32-битного и 16-ти вы никак не достучитесь до этих новых вещей.
Поэтому вот 64-битные штучки, они привязаны к 64-битному режиму.
Понятно?
Вот. А 32-битные и 16-битные работают в режиме такой жесткой обратной совместимости,
как они работали раньше, вот один в один и работают.
Также небольшая историческая исправка по происходящему.
Вообще, 64-битное расширение называется...
Он D64.
Потому что это AMD-шный расширение.
Большинство расширений, которые мы рассматривали, они Intel-ские.
Ну, потому что Intel создает такие структуры и так далее.
Но вот в 64-битном мире ситуация изменилась.
А именно, были времена N64.
И Intel хотели...
Было понимание, что надо переходить на 64-битную архитектуру.
Почему, кстати говоря?
Да. Проблемы с адресами.
И были всякие докладки, которые позволяли операционной системе использовать больше, чем 4 гигабайта памяти.
Но вот без страданий...
Прикладному софту доступно максимум 4 гигабайта.
Притом, по факту, вам даже, скорее всего, доступны не 4 гигабайта, а 2.
В связи с тем, как обычно устроены операционные системы...
Операционные системы любят резервировать половину адресного пространства под себя.
Поэтому из 4 гигабайт возможных адресов...
Система резервирует под себя половину. Обычно это верхняя половина.
То есть у вас доступно вашему ходу 2 гигабайта адресов.
И всякие способы, как нарызать эти 2 гигабайта, они, конечно, были и существуют.
Но это откровенно больно.
Поэтому, чтобы не страдать...
И чтобы можно было пользоваться все возрастающими объемами оперативки...
Всем была понятна необходимость перехода на 64-битную арифметику.
И изменение размера указателя...
Это достаточно фундаментальное изменение, чтобы сказать, что это новый режим работы.
Потому что, ну, все сломается.
Здесь все сломается, поэтому...
Это несовместимо.
Почему верхняя?
Ну, так выбрали.
И, типа, нижние адреса...
Там точно, вот, пацаны, около нуля что-то резервируют.
Нет, около нуля резервируются ради облегчения поиска ошибок.
Исключительно ради того, чтобы 0-пойнтеры не обращались четко узнать куда, а обладали впадением.
Там тоже летом гигабайты не было?
Нет, не лучше.
Там порядка 64-ки добавились.
Ну, опять-таки, от системы зависит.
И вот это вообще не принципиально.
На самом деле, если вы явно попросите операционку, то вы можете выделить память в нуле.
То есть, она по диполу так не делает.
Но, к примеру, раньше можно было сказать, вот, на низкоуровневыми командами операционки...
Давай, вот, отобразим.
Кусок вот этих вот адресов куда-нибудь.
И можно было сделать 0-пойнтер, через который все работает.
Но, еще раз.
Это было очень такое неожиданное поведение.
И работало в одной недочери в плане того, что компиляторы, еще раз не забывайте, проявляют всякий нездоровый цвет.
А именно, компиляторы знают, что по 0-пойнтеру ничего быть не может.
Поэтому, в тех местах, где компиляторы не используют интеллект в этом месте,
после такого выделения памяти, у вас действительно, сквозь 0-пойнтер работает.
Но, в тех местах, где компиляторы проявляют интеллект, у вас сломается.
То есть, этот адрес, он будет посчитан как невалидный.
Более того, 0-пойнтеры, они нередко используются как значение для вот такого...
несуществующего результата или аргумента.
Поэтому, даже если вы выделите там память, это значение просто будет сигнализировать и проверяться как несуществующее значение.
Поэтому, чтобы не заморачиваться с подобным, и чтобы облегчить оплавку, операционки в районе 0 не выделяют память.
Но это не какая-то техническая особенность.
Это вот...
когда я полностью сорву...
0 и больше.
Да.
На XF6 умолчание в 0-м текст на лице.
В 0-м?
На XF6 умолчание в 0-м районе становится текстом.
С 0-го и выше.
Еще раз. Какой? 086, что ли?
XF6. Это операционная система учебная под респект.
А, ну, может быть.
Учебная операционная система может делать что угодно.
Но вот реальные операционки в 0 стараются не мать.
Потому что они не могут мать.
Но они стараются так не делать, чтобы не удивлять слов.
Потому что вот про ньюпоинтеры.
А, есть соглашение.
И Б, это помощь в оплавке.
То есть, если вы там забежали, лучше упасть, чем тихо писать непонятно какие-то бреда.
Это все отсутствие прикосновений?
Нет, это только другое собственно.
Но это еще раз.
Это оплавка.
Вот.
Так, что мы куда-то ушли?
Что у вас осталось?
Хотя, 4664.
Битный режим.
Зачем ему это?
А, нет, парадочное пространство.
То есть, еще раз.
Несмотря на то, что у вас адресного пространства 4 гигабайта,
фактически в программе доступно порядка двух.
Ну, при помощи некоторого количества страданий и извращений,
вы можете выбить в операционке 3 гигабайта.
Но вот больше вряд ли.
Нет, это опять-таки нужно включить режим гидрат,
для того, чтобы операционка просто по-другому разделила адресное пространство между ведром и визуалом.
Поэтому, ну, стала понятна необходимость того,
чтобы перейти на 64-битную адресацию.
И Intel решили сделать следующее.
Они решили, что, ну, хватит уже пинать x86,
надо сделать новую, крутую, прогрессивную,
а самое главное, такую архитектуру,
на которую лицензии будет только у нас, ни у кого больше.
Чтобы всякие AMD и прочие не портили,
не портили им бизнес.
И сделали штуку под названием Itanium.
Itanium, которая в сокращении называется IA64,
если вы увидите.
Вот такое название. Это Itanium.
Но Itanium оказался Итаником.
Народ его так окрестил.
А именно, там были разного рода проблемы.
И технические, и всякие логические, и маркетинговые.
Ну, в общем, оно не взлетело.
Да, еще раз, это была другая совершенно архитектура,
несовместимая с x86.
Там были некоторые возможности по аппаратной помощи в эмуляции x86,
но они работали настолько плохо,
что чисто программная эмуляция, которую допилили там через некоторое время,
работала быстрее, чем через эти аппаратные команды поддержки.
То есть настолько там было все плохо.
Вот. И всякую там youtube и подобное портировали на Itanium очень быстро.
Но вот портировать этот прикладной стоп,
это удовольствие дорогое, медленное.
И в режиме эмуляции оно работало, как я уже сказал, весьма пошире.
А стоило, о буй, господи.
И там всякие дедлайны они тоже многократно нарушали.
Поэтому все это, ну, не взлетело.
А почему эмуляция быстрее была?
Ну, там криво было сделано.
Оно работало как медленно.
Ну, железки.
Там были и всякие принципиальные проблемы.
Например, размер страничек там был любой.
Там были странички 8-килобайтные,
тогда их, по-моему, существует 6-4-килобайтные.
И через большие странички и меньшие,
они вылились по щекам, по щекам.
То есть там было много всяких технических и маркетинговых,
и всяких других проблем.
В итоге оно не взлетело.
Когда народ, конечно, не было, что испугался.
Вот, сейчас тут и все выпустят, захватят.
Новая такая фута-архитектура.
И где-то через год, ну так, не очень далеко от ИА-64,
АМДшники выпустили свою попытку 64-бит,
которая называлась АМД-64,
и заключалась в том, что давайте закостылим
новый режим к x86,
где вы можете держать процессор в старом 64-битном режиме,
и оно будет работать прямо как раньше, один в один,
с полной скоростью,
никаких проблем,
а можете перейти в 64-битный режим,
там у вас будут новые вкусняшки,
и даже из 64-битного режима есть режим совместимости,
для, вот, юзерспейса прикладного софта,
который также работает прямо вот практически один в один,
как и раньше.
То есть, чтобы перейти вот на АМД-64,
не нужно ничего прикомпилировать,
вы можете использовать вообще этот процессор в x86-битном режиме,
он будет работать с полной скоростью,
захотите 64-бита, вам нужна 64-битная операционка,
64-битные дрова,
а юзерспейс вы можете продолжить использовать
рассеянный 2-битный вместе с 64-битным,
ну, то есть максимально удобный переход,
не больный ни с какой точки зрения.
И вот всё это, оно одновременно совпало
с выходом очень удачной архитектуры АМД-шной,
это был процессор Athlon 64,
который был технически просто очень удачный.
Он и сам по себе хорошо работал,
и там случились довольно существенные изменения архитектурные,
что контроллер памяти встроили в ядро,
раньше он находился в отдельной мехосхеме Северный мост,
то есть там ещё доступ к памяти сильно ускорился,
поэтому вот эти вот процессоры АМД-64,
они в клочья рвали всё интеловское,
и по цене в том числе.
Поэтому народ, конечно же,
вообще не хотел покупать эти ПИА,
и массово покупал у рабочих.
То есть там был период времени,
когда все топовые процессы, они были АМД-шными,
ну, что, собственно говоря, наблюдается, честно говоря, и сегодня.
И у него снова такая полоса страданий и фигней.
Вот. Поэтому, если вы увидите название АМД-64,
то вот это вот просто название 64-х битвы архитектуры ПИА-86.
И потом, когда стало понятно, что Даня вернулся,
АМД-64 действительно успешно,
им, по-моему, пришлось поддержать АМД-64-решение.
Конечно, они не могли его назвать АМД-64,
это, по-моему, в какой-то документации обозначается.
Но, в смысле, вот это не меняется.
Хотя потом такое более нейтральное название,
как Х-86-64 и даже еще, короче, Х-64.
Вот это вот все полные синонимы.
Вот это — это совсем другое,
а вот это — это полные синонимы.
— А у них права были у АМД?
— Знаешь, что делать? С правами там интересная вещь.
Современная Х-86-архитектура, она покрыта патентами,
и она покрыта патентами весьма плотно
и со стороны Intel, и со стороны АМД.
Если любая из этих компашек объявит,
что мы не разрешаем пользоваться нашими патентами,
то другой не сможет сделать современный процессор на Х-86.
То есть у них там сейчас полная взаимозависимость,
и мирная договоренность о том,
что другая компашка может пользоваться без проблем
патентами другой компашки.
— Так у них же изначально вот...
— Нет, еще раз.
Исходно Intel выдала разрешение на использование Х-86,
ну, базовое для Х-86,
всякие расширения и прочее.
Там, конечно же, Intel пытались отсудить по максимуму,
если бы они тут не лезли,
и решали бы убить.
Но вот в современном мире
там у них полная взаимная зависимость.
То есть если АМДшный патент убрать,
то он не сможет сделать Х-86 процессор, и наоборот.
А вот техническое решение только подчеркивает.
То есть это вообще чисто АМДшный решение.
Почему, ну, по крайней мере, раньше,
когда еще и А-64, и А-97 все забыли,
там всякие графа еще включаются,
народ, наверное, редко выбирал
всякие парики из папочки А-64,
потому что у меня не АМД процессор,
а АМД-64 и А-64.
Правильный выбор — АМД-64.
И, важно, у вас там Intel процессоры не Intel,
потому что это название 64-метрового режима.
Но сейчас уже так редко встречается,
сейчас уже на ноль встречается либо Х-64,
такая самая короткая форма,
либо Х-86.
Почему 64, если реально адресуется 48?
Потому что указателем у вас используются
шестничные узлы числа.
Там есть, конечно, особенности,
сколько из них используется,
и некоторые специальные правила,
но, честно говоря, адреса шестничные нет.
Поэтому 64 — это нормальное название.
И вот эти вот особенности, они не принципиальные.
Это такие технические ограничения,
но ничто не мешает выпустить процессор,
который имеет полную поддержку
всех 64-бит адресов
и ничего не сломает их со всех.
Понятно?
То есть это нормально, совершенно правильно,
вызывать это 64-бит адрес.
— Ну, это, кстати, не проблема,
кстати, соц, который будет работать только на одном конце,
и он просто сломается из-за того,
что там, наверное, некоторые предположения.
— Ничего, конечно.
— Потому что некоторый соц
все же может сломаться от того,
что адреса 48 поднимется до 64.
— Ну, знаешь...
— Специфический соц, он может.
— Это как всякие системы защиты сломались,
ковидоинтелсы выпустили
процессор с асимметричным ядром.
— Ну, конечно, наверняка кто-то где-то сломается.
Это такая известная история,
что вот там новая версия текстового редактора,
мы там пофиксили багу,
которая, когда вы зажимаете пробел,
нагревает процессор на 100 градусов,
а в ответ пишет пользователь
«Ой, верните обратно, у меня там не работает control,
поэтому я и сделал скрипт,
что если температура процессора поднимается до 90 градусов,
а вы интерпретируете, как будто я нажал control,
поэтому, верните все обратно,
я хочу старое поведение».
То есть наверняка кто-то
так же себя может вести,
но это его личные проблемы.
В целом, такое наблюдаться неровно.
Итак, вот еще раз,
все это — полные синонимы,
поэтому если вы где-то видите AMD 64,
это просто шестидесятый репитмин
в режиме x86,
ни больше, ни меньше,
длинный вот такой у вас процессор,
ни толстый — никакой разницы.
Что у нас произошло
в этом самом шестидесятый репитмин x86?
Ну, первое,
вы уже догадываетесь,
регистры расширили.
Регистры расширили,
и теперь то, что было eax,
стало rax.
То есть картинка вот такая.
Все это вместе.
rax — это eax,
аax — h,
а l — 0,
и x86 — 0,
и x86 — 0,
и y — 0,
и x86 — 0,
и y — 0,
и Ñ — 0.
Т.е. все эти гибкие сложности
набрасываются в рамках
резерва,
насколько я upon the whole
ierz interval
5000p.
что у них вот такого разрезания не было.
И им давали возможность обращения к младшим восьмидетикам.
То есть у этих регистров у них была вот такая форма,
которая означает младшие восьмидетики.
Вот аналога H нет.
Почему?
Ну, потому что не нужно.
На самом деле для SP это нафиг не нужно,
но ввиду симметрии кодирования оно там тоже появилось.
То есть у вас есть доступ теперь ко всем регистрам
к младшим восьми, шестнадцати, тридцати двум и шестидесяти четырем.
Потом, в одно из самых вкусных, добавили новых регистров общего назначения.
Регистры эти называются R8 по R15.
Вот какие названия сцеплены.
Это шестидесяти четырехбитные формы.
Это шестидесяти четырехбитные формы.
Это шестидесяти четырехбитные формы.
У них также есть тридцать два, шестнадцать и восемь,
которые называются R8D, R8V, R8B.
Но опять, регистры не важны.
Это восемь регистров общего назначения.
Такие как...
ЕАХ, ЕЦХ и так далее.
Вот-вот.
Точно так же.
Но у них коротенькие формы образуются по другой системе.
По более выгодной.
Как поделаться инструкцией с ЕЦХ?
Ну, на самом деле,
кодирование там, по большей части, тридцать двухбитное.
То есть большинство команд в шестидесяти четырехбитном режиме
в дефолте тридцать двухбитное.
Для того, чтобы закодировать что-то новенькое,
то есть вот R-регистр шириной,
или вот эти новые регистры,
там нужно добавить специальный префикс.
Там нужно добавить специальный префикс.
Префикс называется REX.
И имеет коды от 0x40 до 0x41.
Если только курсы кодирования,
то это были такие специальные короткие формы
для команд INC, DEC и DIST.
Сейчас эти короткие формы забрали,
то есть команды INC, DEC остались,
но у них остались только полные формы.
А короткие формы забрали под префикс,
который позволяет вам закодировать вот эти новые регистры.
Вообще система кодирования, она минимально изменилась.
Но для того, чтобы обращаться к новым регистрам,
поле, которое кодировало индексы регистра,
оно уже было трехбитовое.
Регистра стало 16,
и вам нужно теперь использовать 4 бита для индекса регистра.
Вот этот дополнительный бит,
он и берется из префикса REX.
То есть вот эти вот единички,
это битовые расширения полей,
которые используются в обычном коде команды,
позволяющие вам закодировать.
Эти расширенные регистры.
И в связи с этим есть еще одна особенность,
а именно одной команде нельзя мешать аж регистры
и что угодно новое.
Почему?
Потому что вот эти вот,
формы, которые SPL, WPL, откуда они взялись?
Это те коды, которые раньше кодировали аж регистры.
А в новой системе кодирования,
они кодируют теперь не аж регистры,
а младшие 8 бит других регистров.
Из этого следует, что просто технически,
если вы используете новую индексацию регистров,
то есть у вас есть префикс,
то аж регистры вы не способны теперь закодировать.
То есть аж регистры, они не были убраны,
но вы не всегда можете на них достучаться
в зависимости от того, что вы используете.
То есть какая-нибудь команда
может сказать, что мов а аж запятая ц л осталась.
Нет проблем.
Но сказать, например,
мов а аж запятая р 8 б невозможно.
Потому что, если вы используете обширное кодирование
для того, чтобы обратиться к р 8 б,
то кода для а аж просто нет.
А аж, то что раньше кодировало а аж,
теперь это будет WPL.
Вот пометьте себе, что в одной команде
нельзя использовать одновременно аж регистры
и любой новый регистр.
И R, потом SPL, WPL или там RAX.
Любой регистр, которого не было в 3D-умережении,
нельзя использовать вместе с аж регистрами,
в одной команде.
Потому что для обращения к этому новому регистру
нужен префикс.
А префикс переключает значение этих цифр.
Нет, не его новый регистр,
а в эти самые WPL, SPL, SIL, DIL.
Вот.
Оно сюда приходит.
Ну, не сказать, что это нормально.
Просто нет.
Правильно.
А что бы мы скодировали?
Ну, хоть вот в моменте исполнения...
Нет, ты не сумеешь выразить такую мысль,
это низкий интервью.
Причем можно спросить,
а вот у нас мы можем условно считать 15 б,
а записать только 8 б?
Да, конечно.
А у нас старшая часть будет аннулироваться?
Вот, сейчас я про это скажу.
Ну...
Хорошо, сейчас скажу.
Да, здесь есть особенность,
она заключается в следующем,
что когда вы пишете в 32 младших бита
и ровно в 32 младших бита любого регистра,
например, mov.eax, там, ecx,
то в этом случае старшие 32 бита обнуляются.
Вот, обязательно пометьте.
Еще раз, правильно.
Если команда пишет 32-битную часть регистра
любого, старого, нового, неважно,
то старшие 32 бита обнуляются.
То есть на самом деле команда пишет 10 дисков,
после пишет 0 в старшую часть.
Если вы пишете не 32-битную часть,
например, вот пишите 16 бит, 8, 8,
то ничего подобного не происходит.
То есть как раньше запись mov.eax
не трогала старшие 16 бит,
так и эти она тоже не трогает.
Поэтому только запись 32-битной порции
имеет вот такую особенность.
Можно ли я считать, что
когда мы пишем в 8 или в 16,
и у нас, по сути, не трогается остальная часть,
то это, по сути, мы читаем свой же регистр
и просто маску накидываем и делаем или с этой частью.
То есть на самом деле у нас происходит чтение,
может, из этого регистра читали данные
перед тем, как мы его пишем?
Ну, скорее не столько чтение,
а есть ли зависимость
по исходному значению этого регистра.
Вот так вот я рассказываю.
Да, есть.
Вернее, там есть разные режимы в разных процессорах,
но, как правило,
наверное, проще считать, что есть.
Потому что в разных процессорах
там были разные фичи
про вот 8-битные части и так далее,
но в современных эти фичи,
я так понимаю,
они все меньше актуальны.
Есть специальные такие режимы,
а есть маленькие кусочки.
И оно будет зависимое.
Но у нас, видите, там есть флаг,
например, у Armani есть флаг из Merging,
который динамический,
и если он смерджется,
то он не замерзает.
А если не смерджется,
то он замерзает, по-скольку.
И этот флаг зависит.
Нет, здесь никаких флагов по этому поводу нет,
но вот это вот зависимость
в плане того, чтобы,
если вы делаете, например,
скажите,
mov ax constant,
то вот эта команда
означает, что ее результат
зависит от предыдущего значения rax.
Ну да, да, да.
Я вот про что.
А если вы делаете mov eax constant,
то эта команда пишет весь регистр,
и поэтому зависимости от того,
что с этим регистром делали раньше, нет.
На правильность это не влияет,
но это влияет на эффективность работы,
когда вы смотрите, какая команда какой зависит,
что там суперскаляра может одновременно исполнить.
В этом плане, конечно, рекомендуется
писать весь регистр.
Это означает, что рекомендуется
писать хотя бы 32 бита.
И еще последствия.
Тоже важное.
Я вам сказал, что такая дефолтная битность
в 64-битном режиме
все равно 32 бита.
Поэтому выгоднее использовать команду
а не команду
Почему?
Потому что результат одинаковый,
а эта команда на 1 байт короче.
Там нет реакс-префикса.
С другой стороны,
если вы ксорите, например, R8,
то вот ксорите вы R8 или R8D,
никакой разницы.
Эти команды занимают одинаковый размер,
работают с одинаковой скоростью,
вообще-то разница.
Потому что для кодирования R8
вам реакс все равно нужен.
А вот для таких старых регистров,
выгоднее использовать Е-формы,
потому что оно тогда будет кодироваться на 1 байт короче,
если вам нужно занурение старшей части.
Да.
Да.
Потому что просто загрузка 32 бита
уже обнуряет старшую часть.
Да.
Тоже самое.
Но я ихс на 1 байт короче кодирую,
потому что оно не требует реакс-префикса.
Так что если вы смотрите на код компилятора,
вот ответ на вопрос,
почему компиляторы выглядят такими
тридцатиноубитными командочки,
даже если у вас в этом регистре
лежит шестнечетыреубитное число.
Потому что действия эквивалентные,
а кодируются короче.
И в этом месте даже есть
такой один забавный хак.
Я бы даже так сказал.
Кто знает про код 0x90?
Что это за код такой?
Это ноб.
Ну это ноб,
это как бы официальный ноб.
А если технически,
то какому действию это соответствует?
Нет.
Нет.
И это действительно был ноб
в шестнадцати и тридцатиноубитном режиме.
Но теперь обратите внимание.
Вот это новое правило
зануления старшей части
означает, что эта команда не ноб.
Потому что она должна
занулять старшую половину Rx.
Но, так как официально в документации
сказано, что это ноб,
то оно не зануляет ничего.
Это действительно ноб.
То есть в программе об код
поставили там официальный if.
Несмотря на то, что вот оно как бы
соответствует коду этой команды,
но на самом деле это честный ноб.
То есть если мы сами эту команду напишем,
то тоже ничего не произойдет?
Это уже зависит от.
Потому что у команды XTHG
есть несколько вариантов кода.
И если оно сконфилируется
в код 0x90,
то это будет ноб.
А если оно сконфилирует себя
в полную форму XTHG,
то оно будет обнулять.
И я так понимаю,
что современные компиляторы,
если вы их просите вот так вот сконфилировать,
они вам будут сконфилировать в полную форму,
как раз специально,
чтобы вы получили вот тот эффект,
который просили.
Потому что, наверное, вы просили обнулить
старшую часть реки.
То есть вот этот вот код,
он имеет специальную обработку.
Несмотря на то, что он как будто
соответствует команде XTHG,
в фактически любительном мире
это уже не так.
Это такой честный специальный случай.
А ноб?
Нет операции и ничего не делает.
Обращаю ваше внимание,
что на x86 ноб имеют код не 0.
Довольно популярно в разных архитектурах
для ноба выбирать код 0.
Так вот, 0 на x86
это не только ноб,
это двухбайтовая команда,
которая обращается в память.
Поэтому, если вы наткнетесь на исполнение
кучи нулей как кода,
вы с высокой вероятностью
очень быстро покрашитесь.
Потому что будете обращаться
в чёрт его знает куда в память.
Поэтому переход на генерацию
вставляете юдэдвэр.
Ну дэдвэр бывает, что кобелятор вставляют.
Но на самом деле, качтые заполнения
гораздо чаще используются
вот этот код.
Этот код соответствует команде
int3.
Вы вылезете в апперчик.
Но после у меня int3 под другое используется
а юдэдвэр именно под некорректную позицию.
Нет, мы тут тратим места.
Посреди кода, когда у вас там функции выравниваются на что-то,
вот они обычно заполняются вот так.
У D2, я знаю, компиляторы в духе сланга и ПЦЦ
любят ставить, если ваша функция описана как no return,
то вместо команды read ставится UD2.
Вот так они любят ставить.
А всякие заполнения обычно происходят вот через UD3.
Почему не нопами?
Потому что если D2 здесь оказался, то что-то незапланированное произошло.
Нет, я видел, как заполняют нопами.
Я видел и N3, и видел нопы.
Ну, когда я встал, это заполнение в том месте,
которое рассчитано на то, что его будут исполнять.
А N3 это заполнение, которое рассчитано, что его не будут исполнять.
Например, вот эти дырки между функциями.
Вот там рассчитано на то, что туда при нормальном исполнении ты не попадешь.
Если говорить про выравнивание внутри функции,
то, конечно, это нопа.
Ну, кстати говоря, это не единственная форма нопа.
Нопа есть, ну, как уже некоторое время назад добавили,
еще всякие такие многобайтовые формы.
Вы можете считать мультибайт.
Ну, командочки, которые делают ноп, ну, кодируются большим числом байтиков
для того, чтобы не спамить много команд, а использовать более жирные команды.
Ну, такое тоже встречается.
Почему именно N3, а не запланированная команда невалидная,
которая делает действия, которые приводят к крашу?
Ну, N3 тоже приводит к крашу, если у тебя отрядчик не подключен.
То есть, если отрядчик подключен, оно цивилизованно вываливается в отрядчик.
Так что, с точки зрения того, чтобы покрашиться, N3 без отрядчика себя также крашит.
Поэтому не забывайте убирать N3 из кода, если вы его используете.
Без отрядчика N3 крашит.
Ну, можно еще и сектор ханда поставить.
Система зависит.
Так, это были регистры.
Следующий важный вопрос, который нужно посмотреть, это адресация.
Сейчас я вам нарисую третью великую табличку.
Про то, как можно адресоваться через различные видные регистры.
Она выглядит так.
На первой позиции может быть любой регистр общего назначения.
Например, плюс на втором что угодно, кроме РСП, умножить на, как и раньше, плюс...
Давайте набор всех.
Вот так.
Да, construction pointer теперь называется A.
И даже можно участвовать в адресации.
Это касается и относительной адресации.
Ну вот, давайте посмотрим на эту картинку.
У нее есть исключения, но вот это вот то, что случается почти всегда.
Во-первых, то, что было в 32 битах, оно практически остается.
Вы можете использовать новый регистр общего назначения
без всяких уменьшений.
Так же, как и раньше.
Все то же самое.
Второй аргумент можно умножить на 2, 4, 8.
Можно не умножать.
Какие особенности?
Особенность номер один.
Обратите внимание на смещение.
32 битное смещение.
На самом деле, эта печальная история вообще справедлива для всех команд.
За исключением двух.
За исключением двух команд нигде абсолютно нет 64-битных константов.
То есть все константы, которые вы можете указать в командах,
за исключением двух команд, 32-битные максимум.
То есть, например, сказать ADD регистр, запятая 64-битная константа невозможно.
Константы не расширены до 64-битных.
И в адресах также вот эта вот константа, она 32-битная максимум.
При том, сознательно или беззнательно.
Какой ответ был раньше?
Неважный.
Неважный.
А теперь ответ?
Важный.
И сознательный.
Потому что видимость константы меньше видимости адреса.
Поэтому как константы расширяются, важно.
И константы расширяются как число со знаками.
Вы можете адресовываться на плюс-минус 2 гигабайта относительно адреса заданного регистром.
Кроме того, вместо первой части, где у вас регистры, может выступать регистр RIP.
RIP это ваше текущее положение.
Даже более точно, это адрес начала следующей команды за вашей командой.
И поэтому в 64-битном мире адресация, как всяким константам и подобным вещам, она обычно RIP-относительная.
Потому что ваши константы, они скорее всего находятся недалеко от вас.
Поэтому вы можете...
Вы можете через небольшое смещение относительно вашей позиции до них добраться.
Обращение по абсолютному адресу в 64-битном мире очень затруднено.
Еще раз.
64-битные команды почти нигде не используются.
Есть только два исключения.
Вот запишите себе эти исключения.
Во-первых, 64-битные константы можно использовать в команде mov.
reg64.const64.
То есть, чтобы записать в 64-битный регистр 64-битную константу.
И второе исключение это mov.
...
В обратную сторону тоже можно.
Где аккумулятор это...
То есть, вы можете прочитать или записать аккумулятор по адресу 64-битной константы.
...
И это единственные команды,
которые оперируют 64-битными числами.
В смысле, значениями, заданными в коде команды.
Все остальные константы, которые вы используете,
они все максимум 32-битные.
Вот такая печальная история.
Почему это важно?
Потому что
нередко то, что вы использовали,
было константами.
Например,
когда вы писали
push
push
push
метка.
Что такое метка?
Это константа.
Это константа.
Просто эту константу
вычисляет компилятор
во время компиляции,
где эта метка
расположится в памяти.
Соответственно, теперь
такая команда невозможна.
Потому что
ваша метка расположится в памяти
где-то по 64-битному адресу.
А запушить
вот здесь
вы можете указать только
32-битное значение.
Понятно?
Поэтому вот так вот запушить
адрес метки
невозможно.
Все, что вы можете сделать,
это movregister, запятая метка,
потом pushregister,
и то там есть особенности.
Как правило,
movregister
таб.
Атак, London?
Да.
Так!
Пин MTG резка!
Потом кичу!
Так потенциально можно!
Но так, честно говоря,
не очень хорошо
в связи
с некоторыми доступными
как оно компилируется
или линкуется
ize the location.
Вы хотите писать
вот так.
И, да, я не помню, какой дефолт у нас, ясно, у нас не совсем правильный дефолт.
Вначале нужно сказать еще где.
Нужно ли это говорить на основе, не помню.
Надо посмотреть, про что это.
Про то, что когда вы в дефолтере в режиме указываете метку,
то метка компилируется не как адрес этой метки,
а как rip плюс смещение относительно адреса следующей команды.
И вот это то, что вы хотите.
Вы хотите вот такую форму вот здесь.
То есть, ясно, нужно было точно говорить дефолт, реал.
А вот у нас, ну, какой дефолт, реал, не реал, я не помню.
И вот это, чтобы пихать на 64-х метрах.
Чтобы ее как-то использовать, да.
Вернее, это вот, смотри, вот это ваша метка,
которая располагается где-то недалеко от вас.
Да, конечно.
Вот, справа табличка.
Но это предсказуемое смещение относительно rip
обычно то, что вы хотите.
Потому что эта метка располагается, скорее всего,
ну, не дальше, чем 2 гигабайта от вашего кода.
Если вы пишете данную метку.
Что исполняемую, конечно, библиотеку.
Он явно имеет размеры меньше, чем 2 гигабайта.
Поэтому относительно кода, если вы шагнете,
пусть будет 2 гигабайта, будет 0.
Какой вопрос?
Можно ли просто обстоять размеры, если это 4 гигабайта?
Нет.
Там присутствует некая форма.
В некоторых командах есть возможность
использования более коротких констант.
Например, адресат.
Там есть форма с 8-битыми константами.
Если ваша константа умещается в 8 бит,
будет использована короткая форма, константа.
Но, например, там какой-нибудь mov, константа,
там будет полная форма без сокращения.
Ну и на самом деле это не так уж критично.
Конечно, имеет смысл экономить размер кода,
но там, где оно бесплатно остается.
Но если бы каждая вторая команда мог по автосету относительно RDI
на число меньше, чем 1 байт?
Нет.
Но у меня пример буквально такой есть.
Какой-то странный пример.
Почему вы хотели транспайлер?
Не знаю.
Внутренности должны как-то активизироваться.
А нужно ли?
Ну, вообще, если так массово, то да, может.
Ускорить-то, конечно, но только нужно ли ускорять?
Ну, это уже не взрослый вопрос.
Итак, понятно?
А, и еще такой вопрос.
Можно ли указать регистр не 64-битные, а 13-битные в адресе?
Еще раз.
У вас есть адресация 32-битная, 16-битная и 64-битная.
Вы можете использовать в 64-битном режиме
32-битную адресацию?
Зачем?
А мешать их внутренности?
Нет.
Ну, вот, смотри, здесь нет возможности указать регистры разной длительности.
Просто у меня, видимо, бета-ассемблер,
считающий, что uax, смешанный с rdi, это rax плюс rdi.
Ну, да, это он так проявил интеллект,
что, типа, видимо, хотел все равно,
а аккумулятор, то есть, назвал его неправильно,
поэтому мы его, как бы, автоматически проапгрейдим.
Сейчас.
Интересное замечание.
Что еще можно сказать?
Так.
Ну, теперь...
Да, есть еще интересные вещи.
А именно, вот переход в 64-бита,
также AMD-шники...
Поэтому можно...
Пусть чуть ли не слегка почистить обходы.
А именно все вот эти новые расширения команд,
они, конечно, очень страдают.
Почему?
Потому что их надо кодировать.
А коротких кодов давно уже не осталось.
Так мы же говорили про это, когда...
Сейчас скажу.
Когда добавляли prefix-refix, нет?
Нет.
Префикс — это про добавление вообще, как бы, поведения к обычным командам.
А я говорю про добавление команд.
То есть то, что вот мы дальше рассмотрим,
всякие там сиф-команды,
всякие AVX-512 и прочие,
вот эти все модные штучки,
они требуют новых кодов.
Для новых именно команд.
Не просто для новой формы старых команд,
а для новой команды.
И вот эти вот новые формы команд,
то есть новые команды,
откуда взять им новые коды?
Потому что коды давно кончились.
Поэтому приходится использовать кучу всяких префиксов.
Префикс такой, префикс такой,
и теперь у нас есть немножко кодового пространства,
которое еще не занято.
Поэтому новые команды, они нередко очень длинные
по своему тому.
Другой стороны,
в базовом наборе таких коротких команд
существует довольно немало команд,
которые никому нафиг давно не нужны.
И AVD-шники по поводу того,
что у нас новый режим работает,
соответственно, у нас нет совместимости ни с каким софтом,
решили, что это прекрасное время
почистить и некоторые команды выкинуть.
То есть эти команды,
они по-прежнему существуют и работают,
как и раньше работали в текстовом битовом режиме,
но из шифинического битового режима их выкинули,
их коды почистили.
Теперь эти коды этим командам не соответствуют.
И эти коды можно использовать под что-нибудь,
ну, такой резерв на будущее.
Что это за команды?
Во-первых, это группа команд,
так называемые двоичные команды,
двоично-десятичные реплики.
Это такие команды, как
va-a-a,
есть такая команда,
да.
Раньше, когда открывались документации,
это была первая команда,
которую вы видите.
a-a-m,
das
и подобные.
Там их, по-моему, было.
Про что это?
Как я вам сказал,
про так называемую двоично-десятичную ритмичку.
Кто-нибудь в курсе чего-нибудь?
Ну, для часов.
Что?
Для часов, там уже, типа, 10 цифр используются.
При этом хочется быстро поучаствовать.
Ну, смотрите.
Это система, где каждый байт
используется для кодирования
одной десятичной.
двух десятичных цифр.
Да.
Binary coded decim.
То есть это десятичное число,
которое закодировано в двоичной системе.
То есть у вас каждый байтинг
имеет значение от 0 до 99.
И в исходном наборе x86
были команды, которые
помогали среди людей,
с ритмитикой такой формы.
В зависимости от того,
что вы за командой делаете,
там происходила
либо коррекция до,
либо коррекция после операции.
То есть там в зависимости от того,
как вы делаете сложение
или умножение,
вам нужно было
поставить вот эту команду
до или после этой ритмической команды
с такими числами,
чтобы получился результат
снова в такой же форме.
Ну, костыли, ужас.
Да, да.
Вот эти костыли,
они доблестно сохранялись
в системе команд.
Конечно, они были реализованы
не в железе, а в микрокоде,
но тем не менее
они доблестно работали.
И вот сейчас эти команды
таки наконец выкинули,
чтобы освободить их коды
под что-то ложненькое.
Вот.
Ничего не хочется использовать
огромные коды
с 10 префиксами,
как для других вещей.
Потом выкинули команды.
Так это вообще бесполезные команды,
их в компилятор никогда не сгенерят.
Да.
Это не значит,
что их никто не использует.
Да, очень много такого.
Системы защиты!
Пусть спокоен.
Наверняка это кто-то использует.
Да.
Да, они просто обожают
всякие извращенные команды,
чтобы усложнить вам реверс
того, что у них происходит.
Поэтому не волнуйтесь,
даже самые извращенные команды
наверняка кому-то нужны.
А как же вот это сообщество людей,
которые пишут нечитабельный код?
Нет, это не нечитабельный код,
это специально
запрещенный код.
А как же это сообщество людей,
которые пишут нечитабельный код?
Специально
запутывание.
Нечитабельный код потом компилируется
во что-то нормальное,
но такое он не будет компилироваться.
Да, это немножко про другое.
Так вот, bound и int.
Что это такое?
Это команды, которые могут
сгенерировать вам
исключения, аппаратные исключения,
а не плюсовые.
В зависимости от чего.
Например, bound предназначалось
для проверки
границ индексов, массивов,
что типа вы там записываете
границу куда-то,
потом индекс куда-то,
делаете команду bound,
и если индекс не попадает в этот диапазон,
то эта команда генерирует
исключения.
Но
в современном мире
генерируются исключения,
это последнее, что вы хотите.
Потому что это дико медленно,
и там все вот эти границы
более 16-пильные.
Абсолютно бесполезная команда
по современным меркам
в ту же сторону.
Вот, может быть, расширение
на хоряло
получилось
интересным.
Но в 32-пильном мире
просто уже никто не использует эту команду.
В 16-пильном когда-то ее использовали,
а чтобы это использовать
в 32-пильном мире, неразумно.
Ну, еще раз,
чтобы ее кто-то использовал,
я не разу не видел.
Может быть, ее действительно
честно расширили,
но в 1286-м
никого она не использовала.
Вот.
Потом
довольно полезная
команда
S-A-L-C,
у которого
есть
команды,
которые долгое время
вообще не признавали ее существованием.
То есть она была долго
недокументированной командой,
которой в документации
не значилось, но
про нее, наверное, было известно.
Вообще, команда довольно прикольная,
которая ставит А-Л
всей витики
в то состояние, которое имеет
флаг C-F.
То есть она ставит А-Л
то, ну, довольно прикольно,
потому что всякие команды,
которые ставят
регистр состояния
в зависимости от флагов,
они обычно ставят 0 или 1.
А эта штука ставит 0
или FF,
поэтому ей пользовались.
Ну, вот ее, например.
S-A-L-L?
Ну, это для C-F.
А для C-F есть?
Ну, в принципе, да.
Ну, в принципе, да.
Она, не знаю,
сладенькая, что-то такое.
Была какая-то особенность,
почему ее много людей использовали.
А вот следующая будет
у нас в чайнике.
Пуша-пупа выкинуть.
Пуша-пупа выкинуть.
То есть теперь
нет команды сохранить
все регистры
общего назначения
в стэк одной команды.
Вместо того, чтобы
расширять старые
пуша-пупа на 16 регистров,
они решили,
что проще выберите
и теперь
нет такой проблемы.
Ребята,
когда нужно?
Ну, редко, когда нужно,
но студенты ее обычно любят.
Почему?
Потому что сохранить все регистры
на всякий случай.
Вы обращайте внимание,
что выкинуть.
Потом вы выкинули
там некоторое количество команд,
которые работают
с сегментными регистрами,
но до сегментных регистров
их еще не нашли,
поэтому я это поскидываю.
Выкинули
некоторые формы команды
jump и pull.
Абсолютно дальние
переходы,
но вы пока все равно не знаете,
что это дальние переходы,
причем и более.
Передописные.
Фар. Дальние.
Там есть понятие
называемых близких переходов
и дальних переходов.
Все переходы,
которые вы пользовались,
они все ближние.
Про дальние переходы
тоже сильно потом.
Поэтому некоторые формы
pull, jump,
pull.
Но это на самом деле
хоть и печально.
Вот это я почувствовал,
что вообще хотелось.
И из забавного
выкинули команды
C-Center, C-Z.
Про что это?
Мы, в принципе, упоминали,
когда говорили про команды
кинг, что через кинг
это такой старый
способ вызова
ядра.
Тяжелый,
до сих пор еще как-то
поддерживается, но не рекомендуется,
потому что это
не для него.
Предназначенный для таких
вещей, как прерывание
от железа, а не чтобы
по 100-500 раз
взорвать ядро из лидер-спейса.
Поэтому, для того, чтобы
ускорить вот этот вот
переход в ядро
и возврат обратно,
сделали специальные команды.
Во-первых, сделали
их интеловцы и назвали их
C-Center, C-Exit.
Что это за команды?
Это команды без аргументов,
которые делают
джамп
между уровнями перелегий
из третьего кольца
юзер-спейса в нулевое кольцо
Kernel Space
это C-Enter, и C-Exit
это джамп обратно.
В какое место они джампуют?
Туда,
куда настроено специальными
MSR-регистрами.
Мы говорили, что есть
специальные машино-специфичные регистры,
которые просто тучат.
И вот
два этих регистра
определяют, куда переход
по C-Center,
куда переход по C-Exit.
То есть это командный вид
джамп в ядро,
джамп обратно.
AMD-шники
сделали свой аналог
для
быстрого вызова ядра.
Давайте я здесь напишу.
Сейчас я вам это покажу.
Здесь
интересная история.
AMD-шные, смотрите,
командуют. Это...
C-Cell.
Это командный
вид
колл
в ядро.
То есть они также без аргументов
в плане куда
перейти.
И куда переходит C-Cell
определяется MSR-ом
машино-специфичным регистром.
Но C-Cell,
в отличие от C-Enter,
сохраняет на стеке адрес возврата,
откуда из юзерспейса
вы вызвали
ядро.
И C-Thread возвращает вас
в это место.
То есть интерфейс C-Enter, C-Exit
требует, что у вас
в юзерспейсе было фиксированное
место, откуда вы
вызываете ядро, и куда ядро
возвращается.
А C-Cell, C-Thread
вы можете делать вот вызов
ядра почти откуда угодно
и не париться, чтобы
вот ядро с юзерспейсом договорилось.
Так что,
вот, AMD-шники, конечно, поддержали
Intel-овские команды, потому что
они поддерживают все Intel-овское,
и добавили свои команды.
Угадайте, какие команды
использовали красивые убитые
операционки?
Потому что они
есть и на Intel-овских просах,
и на AMD-шниках.
Зачем писать вот под это,
когда этих команд
на Intel-овских просах нет?
Intel-овцы, конечно, не ставят.
Поэтому все пользовались
этими командами.
Поэтому, AMD-шники,
когда
вот разрабатывали 64-битное
расширение, они сказали, что
в 64-битном режиме
эти команды
выброшены, нет, они не
работают.
Соответственно, ядро
только так можно вызывать,
ну и через NT, ну NT понятно,
и не очень интересно.
А Intel-овцы, когда поддерживают
AMD-шное расширение, они его поддерживали
но целиком.
Поэтому они и syscall, и sysread
поддержали, но только
в 64-битном режиме.
Соответственно, на Intel-овских
просах sysenter, sysexit
работает и в 32, и в 64-бит.
Поэтому ты сейчас читаешь
Intel-овскую документацию.
А на AMD-шных
просах это
существует только в 32-битном
режиме, а это
существует везде.
Но таким образом,
AMD-шники заставили 64-битные
операционки использовать
вот этот интерфейс
для вызова ядра.
Вот такой вот у них
тройленд
для ядра
и пропихивания своих форм
каналов.
А еще раз, а почему Intel
просто не использует?
Медленно.
Этот интерфейс гораздо быстрее, чем Intel.
Ну и вообще,
их пытаются, по-моему, выпилить
из ядра, как они и Linux.
Ну да.
Я читал, что там
хотят, ну если дохватно,
то понятно, что дохватно,
просто он этот факт по дефолту
еще поддерживает, или по дефолту
его уже переключили, уже нет.
Ну да, хотят, но перетянуты,
потому что это тяжелый интерфейс
и практически не особо
кому-то нужен.
То есть нормальные программы
используют либо просто
вызов библиотек,
которые уже идут в ядро,
а нормальные библиотеки используют
правильный механизм,
чтобы быстро отправиться в ядро,
а не тормознуть
через интерфейс.
Чтобы использовать эти команды,
тебе нужно знать,
где твоя операционка в юзерспейсе
держит вот эту пару
sys.enter
для sys.exe.
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
Это уже четвертая табличка.
В принципе, да. Только это не про это, а про то, как передавать аргументы,
про эти диски и всякое такое.
Из хорошего в физически убитом мире всего две конвенции есть.
Да, там существуют некоторые вариации на тему, но они не существенны.
Вот такого дикого запаха, как было в принципе, там нет.
Ничего же.
Какого запаха используют?
Ну, мне кажется, Дельфи используют.
Дельфи, мне кажется, используют.
У меня вообще не существовало Дельфи, поэтому не могу сказать.
Одно я уже что-то ковырял и все.
И вот оно очень даже множество.
Я его открывал, ужаснулся и закрыл.
Нет, я открывал код Дельфи.
Страдал.
Страдал.
Вообще, Дельфи гнирюет очень фаршиво.
Его прям очень больно читать.
Там для того, чтобы сделать кто-то аналог строкопивая из одной строчки в другую,
там выложены, по-моему, три уровня выложенности функций, чтобы сделать это действие.
То есть нормально, если что-то не компилировать, просто inline,
то у тебя такой мелкий цикл, который очевиден.
А там функция вызывает функцию, вызывает функцию, которая в итоге все,
что делает строкопивая.
Очень больно читается.
Итак, конверсии вызова.
Во-первых, рассмотрим штуку, которая называется FastCon64.
Обратите внимание, в отличие от того зоопарка, который был в крестоюбитом мире и назывался FastCon,
FastCon64 — это жесткая конверсия.
Это жесткая конкретная конверсия вызова без всяких неоднозначностей.
И это единственная конверсия вызова 64-х видов под Windows.
То есть вы, в принципе, можете сказать там в своем коде два подчеркивания CDECAL,
два подчеркивания STDECAL в C-шном коде.
Оно будет компилятором прочитано и жестко заебывается.
Потому что используется только...
Только одна конверсия.
И вот эти подобные комментарии будут просто игнорироваться.
Что здесь происходит?
— Игнорируются только виды. — Что?
— Игнорируются только виды. — Тоже игнорируются.
Там тоже только один вариант.
Но другой.
Итак, что здесь происходит?
Как следует из названия, это конверсия вида FastCon.
То есть она использует...
Регистры для передачи некоторого количества аргументов.
И регистры следующие.
Аргументы.
RCX,
RDX,
R8,
R9.
— Это два аргумента? — Да.
То есть первые четыре аргумента.
И двух регистров.
— Их три, да? — Да.
Или...
ХММ 0 по 3.
Ну и вот это вот последствия того, что мы ведем не исторически.
Эти ХММ-регистры — это про плавающую точку.
Его мы поскидываем пока.
Поэтому отметьте себе вот это вот замечание.
Это будет про ровные числа.
То есть если первые аргументы кто-то был фло,
что плавающая точка,
то он пойдет в соответствующий ХММ-регистр.
Обратите внимание на слово «или».
Это означает, что первый аргумент
идет либо в РЦХ,
либо в ХММ 0.
В зависимости от его типа.
Если он числочисленный,
то в РЦХ.
Если есть плавающая точка,
то в ХММ 0.
А второй аргумент идет куда?
Или в РДХ,
или в СММ 1.
И куда шел первый аргумент —
вообще неважно.
То есть первые четыре аргумента
идут в эти регистры.
А нельзя ли восемь аргументов?
Нет.
Еще раз.
Оно вот так вот поскидывается.
Первые четыре аргумента через регистры.
И эти регистры фиксированы следующим образом.
То есть можно мешать РЦХ и ХММ,
но только четыре регистра.
Еще раз.
Они отвечаются в зависимости от типа аргументов.
Целочисленные аргументы,
целые числа и указатели
идут в обычные регистры.
Плавающая точка идет сюда.
И первые четыре аргумента в регистрах.
Просто в каком регистре
зависит от типа аргументов.
А почему нельзя восемь аргументов?
Потому что так постулировали.
Почему так постулировали?
Потому что нужно было как-то постулировать,
и они постулировали вот так.
На самом деле это имеет смысл.
Мы увидим уже попозже.
А если у меня один Инт, один Флот?
Как я их отправлю?
Я что ж не догадался.
Я не уловил.
Инт, Флот в ХММ-1.
То есть если первый у тебя Инт,
а потом Флот,
то Инт идет в РЦХ,
Флот в ХММ-1.
То есть соотношение вот такое.
Или туда, или туда.
То есть Инт возвращает Флот на РЦХ.
Возвращает, да.
Мы же не дошли до этого.
Ну да, да.
Мы же не дошли,
мы возвращаем на франшизу.
Так.
Теперь какие регистры нужно сохранять?
Сохранять нужно.
다면
Aziku
И вот это вот.
Боль, страдания
и поумедяции.
И что значит
обидно?
Нет. Пока до СМА мы не дошли, давай так, о будущем. Говорю, что вот эту конвенцию составлял козел, который вообще не имеет мозга и не думал о будущем.
Вот всякое вот это разумно, окей, понятно, что они имеют в виду, имеют свои плюсы, к этому нет претензий. Вот это полный идиотизм, страдания, боль и неадекватность. Но, к сожалению, с этим уже ничего не сделать.
— Сейчас, то есть, типа, все вот эти регистры и вот эти?
— Да. Нет, ну вот это просто норм.
В этом нет ничего плохого. А вот это очень больно, глупо и так далее. Но почему, пока не знаете. Потому что мы вот идем этим другим путем.
— Потому что мы скипали свою точку.
— Да. Мы поскипали правую точку и синт, поэтому это вот залегай на будущее, пометьте себе, попозже поймете почему.
— А вызывающая стаканчик?
— Покрик.
— Вызываемая функция — эти регистры, если хочешь менять, то должна вернуть в исходное состояние.
В тридцатилюбительном мире у нас было вот так вот. Ну, только Е. Вот видишь, очень похоже.
— ЕВХ.
— ЕВХ, ЕВП, ЕСА, ЕДА. То есть вот это вот прям как вывел в тридцатилюбительном мире, только R.
Вот это новые регистры — тоже норм.
Вот это — большая, но вы ее пока не знаете.
Возвращаемое значение.
Результат.
В.
Сказать лучше.
Аккумуляторе.
Я вот так напишу.
Или...
— Это ХММО.
— ХММО, да.
Потому что это поплавающая точка.
На самом деле нужно будет небольшую штучку добавить.
И в тридцатилюбительной конвенции поплавающая точка.
Но я вам думаю, поплавающая точка — это последующая точка.
Занятие.
Поэтому так. Отложил.
А здесь уж.
Сейчас мы все целиком рассматриваем.
Наверное, довольно тесно здесь связано.
С происходящим. Поэтому...
— А если больше, то указатель сюда подороже записан.
— Да.
Если у вас аргументов больше,
то аргументы идут на стейки.
Если возвращаемое значение
не лезет
в аккумулятор,
то то же самое, что было в тридцатилюбительном мире,
это тоже нулевым значением указатель.
И поэтому указатель
будет сохранять значение.
И идеи эти такие еще.
— То есть ИСИ возможно вызвать
спецплюсными методами.
— Да.
То есть здесь нет всяких извращений
про
РЦХ или еще что-нибудь.
— Да.
— Другое дело, что, по-моему,
там порядок,
который крупное
возвращаемое значение
и ЗИС.
По-моему, там Microsoft.
Я, правда, не помню точно. Надо уточнить.
В каком порядке идут эти
аргументы.
— Это в конвенции начали?
— Да. Единственная конвенция,
которая была в тридцатилюбительном мире.
— Мы же говорили две.
— Нет. В шестидесятилюбительном мире
все конвенции. Одна обендована,
другая не обендована. Поэтому,
когда у вас есть операционка,
то вы строго привязаны
к одной конвенции.
— А.
— Вот.
Поэтому всякие комментарии в коде
про конвенцию игнорируются,
потому что какую конвенцию использовать
определяется таргетом под какую
конвенцию.
Потому что у вас один вариант,
что использовать.
Так.
Какие еще
базовые расходы
носите?
— Конвенция.
Я смотрю, какая-то мудро-красная
операционка. Она просто где-то
внутри себя указывается?
— Ваша операционка должна постулировать,
какую конвенцию использует она,
системные библиотеки и прочее.
— Такой вопрос.
Если у меня код
генерированный с фронтами,
и он использует CSW-конвенцию...
— Если он внутри себя использует,
то никто об этом не узнает,
пока он не взаимодействует
никак с внешним миром.
— Да.
И вот, если я буду пытаться
записать код на людей,
мне надо писать про ставки,
которые будут конвертировать...
— Если он внутри себя это использует
и ни с кем не взаимодействует,
если его вызывают,
то все будет так.
— Да. Надо писать про ставки,
которые будут конвертировать
обе магазины по-другому.
— Да. Вообще проще просто
компилировать.
Потому что целом мы можем сказать,
что компилируют это обе.
— Это G-code.
— Только еще раз.
— Я не использую G-code.
— Я думаю, что компиляторы
умеют использовать разные обе.
— Ну, это уже твои проблемы.
— Ну, это уже твои проблемы.
— Потому что мне надо писать
за ручками про ставки,
которые будут конвертировать
один обе.
— И просто компилировать
другой обе.
— Можно, например,
аналогистами писать.
— Так, это были базовые штучки.
И еще
в 64-битных конвенциях
есть
и в той, и в той фича.
Не знаю, как это
по-другому назвать.
Здесь она называется
shadow space.
Что это такое?
Shadow space —
это специальная конфигурация
стэка,
которая выглядит
следующим образом.
Вот.
Как выглядит стэк
в функции, когда ее
вызовут.
Вот здесь адрес возврата.
Здесь вы там
сохраняете всякие
быстрые ваши локальные
предметы, да,
на его адресе старшего.
И вот здесь
у вас аргументы, функции,
которые не вызовут людей.
Понятно, да?
Так вот,
shadow space —
это вот это место.
Это между
аргументами и ритмами?
Да.
32 байта.
Здесь пошли уже аргументы.
арг...
арг...
Ну, если считать, что это арг 0,
то это будет
арг 4, арг 5,
и так далее.
Смотрите,
у вас после
адреса возврата
и перед аргументами
есть 32 байта пространства,
которое вы можете использовать
как хотите.
Зачем?
Ну, на самом деле,
это не доказаться даже.
Вы указаете?
Нет.
Нет.
Кто добавляет
большого количества
заморочек
к конвенциям вызовов?
Нет.
Вы уже слышали это слово
в прошлый раз.
Сейчас еще раз.
Пора.
Функции
с неизвестным количеством аргументов.
Смотрите.
Чем удобно
это Shadow Space?
32 байта
это как раз место,
чтобы сбросить
эти аргументы
из регистров
на стэп
и получить
обычную линейную
адресацию, как
в вашем аргументе.
Проблема
с вараргами,
когда у вас фастхол,
что вы должны специальным образом
обрабатывать несколько
начальных значений,
а потом по-другому
все остальные аргументы.
А здесь вы можете
ваши специальные значения
из регистров сбросить
на стэп и получить
унифицированную адресацию
ко всем аргументам,
которые есть в вашем аргументе.
Это реально упрощается
относительно всяких других
фастхол-вариантов.
Ты можешь это сделать.
Ты не обязан это делать.
Но у тебя есть место,
куда ты можешь сбросить
и сделать простую индексацию
для варарг-функций.
Это просто место,
которое ты можешь использовать
как хочешь.
Оно явно предназначалось
в вашем аргументе.
Но никто не запрещает
использовать его как ты хочешь.
Например, располагать там
свои локальные ферменты.
И поэтому нельзя ввозить аргументы?
Нет, не поэтому.
Просто потому что так решили.
Еще раз.
Просто здесь так постулировать.
И на самом деле
то, что всего 4 аргумента,
они 4 вот сюда
в любом случае лезут.
То есть и добры,
тоже можно сбросить.
И все будет хорошо и удобно.
То есть это было
специально для вас проведено.
Потому что стек
изменяется в 64-битном мире
8-байтными порциями.
Если вы пытаетесь
передать в качестве аргумента
функции,
то этот инк на стеке
будет считать в 8 байт.
Частично будет намного лучше.
Потому что стек идет шагами
от видности.
Если ваш аргумент меньше,
у вас будет неиспользованное место.
Вот такая ключа.
Shadow Space.
Притом, обращаю ваше внимание,
что это место 32 байта
оно фиксировано.
Абсолютно все функции его получают.
Даже если у функции
один аргумент или
ноль аргументов,
все равно в Shadow Space
в полной размерности 32 байта
положен функция.
Я помню,
когда я
только начал экспериментировать
с 64-битными,
я вызывал функцию
лап-клатина ревендовую,
которая принимает один аргумент.
А если нет,
так я не выделю 8 байт.
Ни один аргумент.
У меня все покрашено.
Почему?
Потому что что происходило
внутри функции лап-клатины?
Она просто записывала константочки
в некоторые регистры
и делала джамп
на функцию лап-клатины
yes,
на которой требуем.
И та функция
уже на стек сохраняла
4 аргумента
и вылезала за мои 8 байтиков,
которые я выделил.
То есть, вот Shadow Space
имеет фиксированный размер 32 байта
и не связан
с количеством аргументов.
4 аргумента, 64,
2 аргумента,
в любом случае функция получает
Shadow Space размером 32 байта.
Понятно?
Это ключа
конденса.
Кроме того, есть еще одна особенность,
которая тоже относится ко всем
конденсиям 64.
Видно, что перед
вызовом функции,
то есть вот в этот момент,
стек поинта
должен быть кратен
64.
Вот тьфу, 16, 64.
16 байт.
Ну, вообще,
если вы ведете себя цивилизованно,
то
какая кратность может быть у
стек поинтера в 64 битах?
Либо
кратно 16,
либо на 8 не кратно
16.
То есть, либо кратно, либо полукратно.
Так вот,
в момент того, когда мы делаете
call, то есть
перед
вызовом функции,
стек поинтер должен быть кратен
16.
Соответственно, когда
войду в функцию,
то ваш стек поинтер будет
не кратен 16.
Да.
Поэтому, если вы решите
мгновенно кого-то вызвать,
то вам нужно
стек поинтер опустить не на
32 байта,
а на
40.
Потому что вам нужно выделить
32 байта
и выливать стек поинтер.
Вот, заключите себе,
что
в момент выполнения
команды call,
перед командой call, стек поинтер
должен быть кратен 16.
И, соответственно,
когда вы только что оказались
внутри функции, ваш
стек поинтер ровно на 8
не кратен 16.
Что будет,
если вы забьете на это
требование?
Либо все будет работать,
либо кто-то покрашится.
Почему кто-то может покрашиться,
если у вас не кратен
стек поинтер?
Поэтому мы узнаем,
когда дойдем до этих самых
xml-регистров.
Вот это требование к кратности 16,
оно связано с xml-регистрами.
Поэтому, если тот, кого вы вызываете,
не использует xml-регистры,
и кого он вызывает,
не использует xml-регистры,
то оно даже будет работать,
если вы нарушите это требование к кратности.
Но если кто-то там
использует xml-регистры,
то у вас есть хорошие шансы,
что оно в том месте покрашится.
Получается, перед каждым
вызовом группа 164
должен стоять sub-rsp 32?
Нет.
Нет.
Это я вам сейчас рассказал
как-то такую топологию стека.
Но
использование стека
в 64-битном мире
оно другое.
Если в 64-битном мире
вы привыкли
вызывать функции как
push-push-call,
push-push-call, push-push-call,
то в 64-битном мире
выглядит не так.
В 64-битном мире
стек-пойнтер обычно
один раз опускается
в самом начале функции,
резервируя место и под ваши
локальные переменные,
и под аргументы,
которые могут потребоваться,
а потом на стек аргументы
складываются командой mov.
То есть у вас перед каждым
вызовом функции
никакой shadow space
не выделяется.
Он выделяется один раз
при входе в функцию,
вы опускаете стек-пойнтер
вот насколько он может
максимум потребоваться.
Это справедливо
для почти всех функций,
кроме тех,
которые динамически
выделяют место на стеке
неизвестного размера
.
Обычные функции ведут себя
еще раз.
Стек-пойнтер опускается
и только в конце стек-пойнтер
возвращается обратно.
Поэтому аргументы
через mov.
shadow space
есть автоматически,
потому что вы должны его учесть,
когда опускаете стек-пойнтер.
Это место, принадлежащее
вызываемой функции,
которая может делать с ним
все, что хочет,
и, соответственно,
вы можете делать с этим местом
все, что хотите.
Вы можете сохранять переменные
как хотите,
используя эти 32 байка,
они принадлежат вам.
Понятно?
Вот.
Это была
диндовая конвенция
по стек-пойнту 64.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
. .
.
.
.
.
.
.
.
.
.
. .
.
.
.
.
.
.
.
.
.
. .
. .
.
.
.
.
.
.
.
.
Вот это аргументы.
То есть аргументы можно передавать через огромное количество регистров.
Обратите внимание,
на слово
И.
Это означает,
что
число с плавающей точкой
независимо
от
сочисленных аргументов
используют свои регистры.
То есть,
если у вас, например, первый аргумент
сочисленный,
а потом плавающая точка,
а потом снова целое число,
то
первое сочисленное значение
пойдет в RDI,
плавающая точка
в XM0,
а второе сочисленное
в RSE.
То есть используются и те регистры,
и те регистры
вместе, одновременно.
Не или как было
по сколу 64.
.
.
Да, можно дофигачивать
и передать регистры.
Но,
как несложно догадаться,
это резко повышает
сложность
по сколу функций.
.
Потому что в RAR
не разобраться,
что у вас происходит.
Удачи!
.
И,
поэтому,
если ваша функция
в RAR,
количество аргументов
вот в этих регистрах
необходимо указать
в RAX.
То есть,
если вы
вызываете
print,
то количество аргументов,
которые вы запихали вот сюда,
необходимо указать в RAX.
Если вы сюда запихали 0 аргументов,
вы должны указать 0 в RAX.
Если вы этого не сделаете
и оставите в RAX мусор,
то print у вас покрашится.
.
Количество аргументов
в XMM регистрах.
.
Еще раз.
Для VARARG функций
сколько аргументов вы
заполнили в XMM регистрах,
необходимо указать
в регистре RAX перед вызовом.
.
RAX – это количество используемых
XMM для VARARG функций.
.
Получается,
у нас через stack не передаются аргументы?
Или там избыток какой-то?
.
Конечно же,
остальные, которые не навестились в регистрах,
отправляются на stack в обратном порядке,
но это довольно интуитивная идея.
.
То есть другие аргументы на stack
в обратном порядке по обычным правилам.
Здесь ничего нового.
Но вот в регистрах
такие правила,
и для VARARG вот такие правила.
.
Плавающая точка уходит в эти регистры,
не плавающая точка
идет в регистр общего значения.
.
Так, что нужно сохранять?
Сохранять нужно меньше.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
. .
. .
.
.
.
.
.
.
.
.
.
.
Так, да, аккумулятор и вроде как XMM 0 по 1.
Тоже я об этом читал, но сам никогда не видел.
Зачем может потребоваться 2 XMM?
Я предполагаю, может быть для комплекса чисел.
Когда ваше значение состоит из 2 чисел, может быть вот эта комплексная часть пройдет XMM 1, но нужно проверить.
Какой размер XMM есть?
Да фига, но обычно используется в передаче организма только в меньшую часть.
То есть с точки зрения размеров, конечно, там хватит на 4 флота,
но так обычно.
Поэтому я предполагаю, зачем нужен XMM 1, чтобы для комплекса чисел.
Но надо проверить.
Стек также нужно выравнивать на 16.
Но здесь есть уже своя фича.
Фича называется здесь PREDU.
Что за RedDoll?
Это вот такая картинка.
Вот здесь аргументы, которые у нас в пенте.
Адрес возврата.
Стекпоинты выравниваем.
А RedDoll это вот эта штука.
Даже не совсем так она выглядит.
Адрес возврата.
Адрес возврата.
Адрес возврата.
Стекпоинты выравниваем.
Делаем вот так.
Там газовые батареи.
Режимы закрываю.
И это все.
Батарейка.
Видите?
Вот здесь они закрываются.
Этоzie рет Bloggers.
И это возможность поменять свой пакет.
Скажу, что я ещё час поставил.
Скажу, что изменилось.
Ну, и сейчас вы с нами.
Смотрите.
Что?
Смотрите.
сохранить на стеке.
Мы говорили о чем?
Как это сделать?
Вам нужно вначале опустить стекпоинтер
и потом
сохранять значение.
То есть писать ниже
стекпоинтера не надо.
Почему?
Потому что сохранность данных
ниже стекпоинтера, честно говоря,
не гарантируется системе.
Что может пройти
какое-нибудь там прерывание
или еще что,
и данные ниже стекпоинтера
считаются, что они никому
не принадлежат, мусор,
их можно портить.
Поэтому,
если вы сохраните там данные,
вас мгновенно никто не поругает.
Но сохранность
данных там
не гарантируется.
Так вот, Red Zone
это специальная гарантия,
что данные
ниже стекпоинтера
до 128
байт гарантированно
сохраняются.
То есть никакое прерывание
и подобное не будет
портить вам данные
на 128 байт
ниже стекпоинтера.
А у нас СВЦ актуально?
Нет. Это не СВЦ,
это операционка гарантирует.
А.
Ну, даже, я думаю, вот эта гарантия
уже олимпиада.
Я не верю, насколько эта антидашная конвенция
гарантировала.
Ну, здесь я уже так
затрудняюсь сказать,
чья это гарантия.
То есть под Linux это так.
Под другими системами, которые
используют подобную конвенцию,
так ли это?
Не могу сказать.
Ну, у нас так.
У нас только одна винда Linux.
Под MacOS
то же самое, что под Linux.
Ну, оно
BSD, на самом деле.
Тоже все время ядра, и там
то же самое.
Вот. Поэтому, если брать такие
крупные операционки, широко известные,
то вот
это правда.
Если брать какую-нибудь большую экзотику,
я не верю, что там
их редзон будет действовать. Но под Linux
это так.
А как под
System 5 вызывать
splitf, там, send, float, int, float?
Я же то, что сказал.
Первое, сочи себя, Гульен,
идет в r, d, i.
Второе, сочи себя,
в r, s, i.
Третье, сочи себя,
в r, d, x.
Первый, с плавающей точкой,
идет в x, n, 0.
Второе, с плавающей точкой, в x, n, 1.
И так, пока у вас не кончится
регистр. Когда регистры
кончились, то дальше
аргументы начинают
складываться на степ, в том
порядке, в котором
они у вас были
в аргументах.
И этот принтер, он
берет на себя ответственность,
какой регистр, в пользу какой.
Да. Почему и
важно
правильно указывать
в строке формата
вот процентик тип
и тип аргумента.
В традиционно убитом мире
вы можете
это соглашение
могло нарушать. Например, вы можете
сказать, я хочу напечатать
процентик,
ум, целое число без знаков,
и отдать туда флот.
И оно вам напечатает
представление флота,
как вот оно по битикам,
так сказать, по этикам
состоит.
В существенном убитом мире,
если вы такое сделаете,
вы получите мусор.
Потому что, когда
вы сказали, что у вас
аргумент сочисленный,
он будет искаться в целочисленном,
в разночисленном месте.
А если аргумент с плавающей точкой,
он будет искаться в месте
плавающей точки.
И под виндой
все, что вы получите, вы получите просто
мусор в этом месте, но у вас
ничего не сломается.
А под линуксом
у вас не просто будет мусор,
у вас еще все остальные аргументы
могут поехать.
И все остальные аргументы могут
появиться с отключением этого.
То, что...
Ну, есть флаг, как это называется.
Ну, вот.
Игре, значит, такого вам
не обещают.
Да.
Но вот
юзерстрейс...
Вообще, мы с вами в курсе про юзерстрейс.
Потому что
ядро — это отдельная история.
И ядро — это, честно говоря,
даже больше курса операционного, чем
смартфон.
То есть, я думаю,
может, это не будет прикольно,
но это специализировано
не совсем то,
чем мы занимаемся.
— Можете еще раз кратко повторить,
для чего вам нужно указывать
количество флотов, аргументов,
плеера и икс?
— Требуется по конвенции.
Конвенция требует, чтобы это было сделано.
Если этого не сделаешь,
у тебя принт реально покрапшет.
— Еще. Для чего нужен
R-flags?
— R-flags — это регистр флагов,
который теперь называется R,
потому что он стал
64-битным вместе со всеми остальными
эписками.
Да, но содержательные эпитеты у него
находятся все равно в нашей части,
как были, так и остались.
То есть флаги переноса, нуля
и подобное —
все они остались, по-прежнему
так же работают.
Просто регистр, как и все остальные,
теперь 64-битный.
— Пойдем.
— Просто про функции.
Какая функция принимает
флаговый инк и флот?
И если нам нужно передать в неправильном порядке,
то нам, в данном случае,
нужно представление флота и флот.
Ну, может быть, инк — специальный флот.
Ну, вместе с в.
Потому что, посмотрите, R-дай и
в основном ноль. — Нет, нет, нет.
Смотри, еще раз.
Если передать их в неправильном порядке,
то
сис-пайк
просто об этом
не узнает.
Он даже правильно будет
интерпретировать.
Нет, здесь не будет им представления делать.
Еще раз.
У тебя целочисленный
аргумент отправляется
в R-дай и
плавающая точка в xml.
То есть у тебя оно будет смотреть
вот в это место или в это место
в зависимости от
типа данных.
Да.
— Во-первых,
какая структура?
Они передаются в регистр?
— Еще раз.
С структурами там
темная история. Зависит от
размера структуры.
Если структуры маленькие,
которые уменьшаются
в регистре, они могут быть
переданы в регистр.
Если они в регистр не лезут,
они будут переданы на стеки.
Вот сколько там местных занимает.
И там тоже
разные хитрые штуки.
Если у тебя, скажем, второй аргумент
это вот большая структура,
которая в регистре не лезет.
Я, честно говоря, не помню, что там происходит,
но что-то дикое.
Может быть, указатель, да.
То есть
там что-то заморочено.
Но структуры может
сама целиком находиться, если это на стеке.
Не через регистр идет,
а просто, как говорится, функцию.
Скажем, 32 бита.
Оказывается, это структура.
Эта структура просто лезет на стеке.
— Еще в чем смысл зоны, если
функция, если нужны какие-то
переменные?
— В смысле в том, что если тебе нужно сохранять
меньше 128 байт
данных,
то ты можешь просто не трогать стекпоинт.
Такая мелкая оптимизация, что
стекпоинтер можете не опускать
и не возвращать на место.
— Все же, условно,
один раз опускается стекпоинтер,
и все параметры...
— А так ты можешь ноль раз
опускать стекпоинтер.
Если размер
всех твоих локальных
переменных не превышает
128 байт,
то ты стекпоинтер можешь
не опускать.
— И насколько сильно это оптимизирует?
— На одну команду.
— На две команды.
— Не допускаем записку на поднимающие.
— Да.
То есть вот такая просто
особенность.
Как сделать это?
Ты можешь
пользоваться этим, можешь не пользоваться.
Тебя никто
не заставляет использовать
эту Redzone.
Но если хочешь, ты можешь
использовать эту фичу.
Shadow Space — это более
взрослая штука. Вы должны
ее выделять, когда кого-то
вызываете. Не выделите —
он попортит вам стек.
А Redzone,
так как это ниже стекпоинтера,
то это заморочки операционной
системы, а не вас.
А для вас это чистый фича.
Не хотите — не пользуйтесь.
— То есть
в случае с Redzone,
я вам не буду выделять.
Сейчас.
В случае с Redzone
ты можешь
писать и ниже стекпоинтера
на 128 байт.
А в случае
с Shadow Space я
как пользователь...
— У тебя есть просто выше адреса
возврата, у тебя есть 32 байтика, которые
тоже вот тебе дают.
То есть Redzone тебе дает данные ниже
стекпоинтера, а Shadow Space
дает тебе место
выше адреса возврата.
— А стек
как портится в случае с Shadow Space?
— Никак не портится.
Даже он только что нарисовал
Shadow Space.
— Да, ладно.
Вы рассказывали историю, как...
— Я не
довыделил Shadow Space.
Я дал Shadow Space не 32 байтика,
а 8.
— Но это вы как пользователь, который
пишет программу.
— Как тот, который вызывает
функцию.
Я обратил
внимание, что Shadow Space
всегда, если нормально,
оно не привязано к размеру аргументов.
Исходно кажется,
если вы понимаете, зачем это сделано,
что оно должно соответствовать
аргументам, чтобы они
могли быть сброшены в степ.
Но оно,
как бы,
хоть для этого было спроектировано,
постулировано оно было не так.
Постулировано, что любая функция
получается 32 байтика.
Ну и здесь
в некотором смысле аналогично
постулировано, что
любая функция
получает вот этот Red Zone.
Но обратите внимание,
что Red Zone
полезна только
листовым функциям.
Если вы
кого-то вызываете,
то никакой Red Zone
у вас нет.
— У нас есть Red Zone,
я перед вызовом функции
ее поиспользую,
потом с длинной степ-поинтера вызову функцию.
— Да, но зачем тебе так делать,
когда ты можешь просто сразу
с длинной степ-поинтера?
— Ну да, мы просто к тому,
что если ты все равно собрал
с длинной степ-поинтер,
то ты можешь убрать.
Ну, насколько ты хочешь
настолько оптимизировать —
вопрос.
Обычно
не очень с этим
заморачиваются.
Бывает, конечно, что компиляторы
специальным образом обрабатывают
парочку начальных ифов.
Например, если ваша функция
начинается с иф какой-то аргумент
меньше нуля, тогда летел
какой-нибудь код возврата.
Вот такие ифы бывают,
что компиляторы ставят
очень рано,
раньше, чем стек-фрейм
вообще создается.
Но такое бывает не очень часто.
Как правило, функция начинается
с пролога, который
сохраняет регистры,
двигает стек-поинтер,
потом целая функция,
и в конце — эпилог,
который возвращается обратно.
— Ого!
Ну и на этом
про 64-битные
особенности, наверное,
все.
Еще есть замечание.
Вспоминаем, что под виндой
глобальные имена, они требовали
добавления начальных подчеркиваний.
Я вам говорил, это можно решить
просто ключиком.
Для нас —
подчеркивание в начале.
Под 64-битыми
никаких подчеркиваний,
потому что имена называются
вот как они есть, так и называются.
То есть это ключик
для добавления подчеркивания
в 64-битном мире под виндой
не нужен. Ваше название
один к одному, да.
— А 2D-тесты будут на винде?
— Там будет сказано.
Ну, фактически да. Там будет сказано,
какую коньянку использовать.
И, честно говоря, там
коньянки будет мало,
поэтому даже если вы пишете
некую другую... — А все можно
вызывать функцию там.
— Смотри, обычный
обычный
указатель конвенции —
это вот ситекл,
и так далее, да. Вот они,
как я уже сказал, влияют
только на 32 бита.
— А-а. — В 64-битном мире
на писательных мультиках
оно
скомпилируется, но компилятор
их проинновирует.
— А-а.
— Нет, в смысле,
компилятор их все так использует?
— Нет. Это
зависит от того, какой у вас
таргет,
под какую операционку
вы компилируетесь.
У компилятора есть таргет.
Если ничего не указывается,
то таргет — это ваша текущая
операционка.
Ну, а если компилятор
имеет кросс-компилированный, например,
слабый, то ты можешь
указать ему специальные ключи,
и тогда
он будет строить код
по правилам вот той системы,
под которую ты сказал,
какой у тебя таргет.
И, если говорить
про вот x86
и фланг, я знаю, что
у него есть магический
атрибут,
который вы можете поставить
на функцию через
два подчеркивания атрибута,
два подчеркивания
и вы можете
вот этим атрибутом
переключить
конвенцию вызова
конкретной функции
вот на другую.
Если вы можете сказать
компилятору, я хочу, чтобы
ты вот эту функцию сгенерировал
в такой конвенции вызова.
И он даже правильно сделает
вызов этой функции
из другого места. Другое дело,
что это жизнеспособно
только вот внутри вас.
Потому что
все внешние функции,
они, конечно же,
имеют дефолтную конвенцию.
А почему длинная система?
Потому что
обычно нормальный код
напрямую не вызывает.
Нормальный код вызывает
системные библиотеки,
которые уже вызывают СИСКОЛы.
Прямые СИСКОЛы это,
честно говоря, большая редкость
нормальных кодов.
То есть не всякие системные защиты
и бла-бла-бла.
Поэтому
открыть ту же самую
DLL-ку, подвинуться,
загрузить код и исполнять,
и оно
полностью работает.
Точнее, что я убит,
у меня там есть некоторые сложности,
но они связаны
чуть-чуть другим.
Они связаны
с TLS.
