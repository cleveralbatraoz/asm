Detecting language using up to the first 30 seconds. Use `--language` to specify the language
Detected language: Russian
[00:00.000 --> 00:02.520]  Которые постоянно не работают.
[00:03.360 --> 00:08.380]  Но если в какой-то задаче это позволяет вам снизить энергопотребление,
[00:09.180 --> 00:15.620]  то вы можете не только повысить скорость, но и, что весьма актуально, особенно в мобильных системах,
[00:16.380 --> 00:23.100]  повысить энергоэффективность соотношения сделанной работы к затраченной энергии.
[00:23.100 --> 00:29.940]  Вот такой сейчас типичный пример, это вот всякие блоки декодирования видео.
[00:31.060 --> 00:38.400]  Если ваш блогный телефончик, достаточно новый, то он это видео легко программно декодирует.
[00:39.120 --> 00:42.000]  Без всяких аппаратных блоков он успеет это сделать.
[00:43.420 --> 00:47.020]  Почему аппаратное декодирование супер актуально?
[00:47.020 --> 00:54.580]  Потому что он, конечно, успеет, но потратит на это энергии гораздо больше, чем аппаратный блок.
[00:55.580 --> 01:02.700]  И ваш фудосик сожжет аккумулятор раз в пять быстрее, чем специализированный блок.
[01:05.360 --> 01:13.020]  Поэтому вот транзисторы сегодня, они не такая большая ценность их количества.
[01:13.020 --> 01:18.020]  Сегодня вот главный момент, это энергоэффективность.
[01:19.640 --> 01:22.460]  Мы можем позволить себе специализированные блоки.
[01:24.060 --> 01:28.360]  И вот, когда мы будем рассматривать наборы команд современных процессоров,
[01:28.500 --> 01:33.360]  они вот постепенно обрастают такими все более специализированными командами.
[01:33.920 --> 01:41.020]  Из такого яркого примера, например, некоторое время назад на x86 добавили команду CRC32.
[01:41.020 --> 01:47.020]  CRC32, который одной командой считает алгоритм CRC32.
[01:48.080 --> 01:50.100]  А он сейчас до сих пор сильно используется?
[01:50.780 --> 01:51.100]  Да.
[01:52.120 --> 01:56.380]  И, кстати говоря, CRC32 используется в разных вариантах.
[01:56.820 --> 01:59.820]  Добавили вариант, который используют в стиле протокол.
[02:00.700 --> 02:02.320]  Ну, когда был для кого, для сервера.
[02:02.320 --> 02:10.060]  Потому что, если вы считаете TCP, то там как раз контрольная сумма, она CRC32.
[02:11.380 --> 02:13.140]  Я не знаю, в IP нет.
[02:13.680 --> 02:15.940]  Ну, в TCP, там контрольная сумма есть.
[02:16.800 --> 02:19.100]  И она, по-моему, как раз вот ровно этого видит.
[02:19.100 --> 02:26.440]  Так как протокол TCP никуда не собирает уходить, то эта контрольная сумма тоже никуда не собирается уходить.
[02:27.620 --> 02:33.620]  И в сервере вы можете считать эту контрольную сумму постоянно программно, он успеет.
[02:33.620 --> 02:44.800]  Но он будет сжать энергии существенно больше, чем если вы поставите специализированный блок и снизите энергопотребление от кучи серверов.
[02:45.880 --> 02:46.600]  Вот вы ответили.
[02:46.600 --> 03:11.580]  Там разве, это же сейчас вообще модное направление, средства его, пишут под каждое приложение, в плане под новый ритм, под какой-то кодек, под еще что-то, пишут новую инструкцию, представляют новую архитектуру.
[03:11.700 --> 03:12.400]  Ну и под каждое.
[03:12.400 --> 03:22.000]  Не-не-не, ну имеется в виду, там идея сейчас, что мы хотим снять трассу, из которой используется, то есть какое-то приложение, да, но, словно, мы там что-то кодируем, да, там какой-то вылит.
[03:22.000 --> 03:31.460]  И мы хотим на основе этой трассы писать экстеншн к архитектуре RISC-5, чтобы получить вот эти команды.
[03:31.460 --> 03:43.260]  А суть в том, что идейно, ну или вообще полная перекодировка RISC-5, чтобы конкретно под эту программу была эта штука эффективно исполнялась.
[03:43.260 --> 03:52.860]  И там, чтобы уменьшился размер, ну и динамического исполненного, более эстетического, там на какие-то проценты, и так это типа энергоэффективно.
[03:52.860 --> 04:02.860]  Смотри, это все здорово, но это опять нас возвращает к курсу архитектуры и к вопросу о программном и аппаратном управлении.
[04:02.860 --> 04:16.860]  Конечно, с точки зрения энергоэффективности и стоимости вот одного конечного кристалла, конечно, лучше сделать специализированный кристалл.
[04:16.860 --> 04:20.860]  Идеально вообще весь алгоритм зашить в кристалл.
[04:20.860 --> 04:26.860]  Но, какая обратная сторона этого аппаратного управления?
[04:26.860 --> 04:32.860]  Да, стоимость разработки и супервысокая специализация.
[04:32.860 --> 04:37.860]  А стоимость разработки железа, она официальная.
[04:37.860 --> 04:47.860]  Так что, если ты хочешь сделать в современном мире по новой технологии какой-то кристалл, это стоит супер дорого.
[04:47.860 --> 04:55.860]  Поэтому, если ты уверен, что ты продашь этих кристаллов каждому китайцу, то да, это оптимальное поведение.
[04:55.860 --> 05:08.860]  Но, если ты не уверен, что ты умеешь продать их в таком количестве, то ты потратишь на разработку этого кристалла гораздо больше денег, чем просто на продажу.
[05:08.860 --> 05:12.860]  Это вообще много, это вот на тебя вышло.
[05:12.860 --> 05:15.860]  Идея вообще много.
[05:15.860 --> 05:18.860]  Ну хорошо, именно реализовали эту штуку.
[05:18.860 --> 05:20.860]  Нет, ну можно развивать.
[05:20.860 --> 05:28.860]  Но еще раз, вопрос в том, насколько это имеет смысл в текущей предметной области.
[05:28.860 --> 05:31.860]  То есть абстрактная статья, ну да, интересно.
[05:31.860 --> 05:34.860]  Но насколько она практически полезна, вот еще вопрос.
[05:34.860 --> 05:44.860]  Эти идеи мы с вами рассматривали на архитектуре.
[05:44.860 --> 05:47.860]  Зачем вообще курс на архитектуре, потому что вы такие вещи понимаете.
[05:47.860 --> 05:49.860]  То есть идея вообще не такая.
[05:49.860 --> 05:52.860]  От того, что мне там рискфайв сказали...
[05:52.860 --> 05:54.860]  Почему?
[05:54.860 --> 05:57.860]  Ну вот с армом так сложно сделать?
[05:57.860 --> 05:59.860]  Прям слишком плотно.
[05:59.860 --> 06:01.860]  Нет, с армом там неправильная идея.
[06:01.860 --> 06:07.860]  Я не знаю, что архитектуре, это штука, которая контролируется лицензией одной компашки.
[06:07.860 --> 06:10.860]  И армом ничего такого просто делать не будет.
[06:10.860 --> 06:19.860]  То есть здесь как бы достоинство рискфайва, что рискфайв позволяет сделать.
[06:19.860 --> 06:21.860]  В этом нововведении.
[06:21.860 --> 06:26.860]  Но вот такая содержательная часть, она вообще не будет.
[06:26.860 --> 06:37.860]  И на самом деле, если уж в ту сторону клоняться, между чисто программным управлением и аппаратным существует еще один уровень.
[06:37.860 --> 06:39.860]  Кто это?
[06:39.860 --> 06:40.860]  Ганера Сонка?
[06:40.860 --> 06:41.860]  Нет.
[06:41.860 --> 06:43.860]  Это ПГА.
[06:43.860 --> 06:44.860]  Может быть.
[06:44.860 --> 06:52.860]  Это такое конфигурируемое аппаратное управление.
[06:52.860 --> 07:05.860]  И на самом деле, вот блоки ФПГА процессоров, народ вообще очень давно уже ожидает, ожидает, ожидает, ожидает.
[07:05.860 --> 07:09.860]  Но их что-то никто не выкатывает, не выкатывает, не выкатывает.
[07:11.860 --> 07:14.860]  Это можно конфигурировать?
[07:14.860 --> 07:15.860]  Да.
[07:15.860 --> 07:30.860]  То есть ФПГА это такая штука, где у вас есть набор логических элементов, и вы можете в процессе работы схемы динамически перестроить их соединение.
[07:30.860 --> 07:40.860]  Таким образом, вы пишете, ну, один из вариантов, вот, на вереводе схему и загружаете ее в эту микросхему.
[07:40.860 --> 07:44.860]  Ваша микросхема конфигурируется под эту конфигурацию.
[07:44.860 --> 07:55.860]  Вы получаете в итоге схему как аппаратное управление, но вы не платите кучу денег за разработки железки.
[07:55.860 --> 08:00.860]  Вы покупаете готовую ФПГАшку и просто ее конфигурируете.
[08:00.860 --> 08:14.860]  То есть это радикально дешевле, чем честно сделать специализированные микросхемы, но эффективнее энергетически, чем исполнять чисто программу.
[08:14.860 --> 08:17.860]  Главная проблема какая?
[08:17.860 --> 08:19.860]  Отсутствие железа такого.
[08:19.860 --> 08:20.860]  Нет.
[08:20.860 --> 08:22.860]  Что нужно писать на вореводе.
[08:22.860 --> 08:23.860]  Ну, не обязательно.
[08:23.860 --> 08:28.860]  Там же, там у каждой компании, я читал, у каждой компании свои, типа, языки.
[08:28.860 --> 08:29.860]  На уровне воревода.
[08:29.860 --> 08:31.860]  Ну, да, да, да.
[08:31.860 --> 08:34.860]  А там это специально же делается, чтобы и по тактово как-то...
[08:34.860 --> 08:35.860]  Да, да, да.
[08:35.860 --> 08:39.860]  И вот писать на таком уровне большинство программистов не способны.
[08:39.860 --> 08:42.860]  Ну, кстати говоря, из хорошего, из хорошего...
[08:42.860 --> 08:43.860]  Сейчас.
[08:43.860 --> 08:47.860]  У нас есть ФПГА.
[08:47.860 --> 08:52.860]  И это буквально железка конфигурируется по программе, которую вы выбрали.
[08:52.860 --> 08:53.860]  Да.
[08:53.860 --> 09:08.860]  То есть это железка, где у тебя соединение логических элементов внутри, не статическое, как обычно, а конфигурируется, ну, можно сказать, программой, которая туда загружается.
[09:08.860 --> 09:12.860]  Ну, значит, условно, система строится после другой программы?
[09:12.860 --> 09:14.860]  Нет, она уже типа построена...
[09:14.860 --> 09:23.860]  Она не строится, внутри соединения переключаются в соответствии с теми данными, которые ты заливаешь.
[09:23.860 --> 09:31.860]  То есть сами элементы, они фиксированы, но соединение их между собой оно не фиксировано.
[09:31.860 --> 09:37.860]  И оно переключается в соответствии с тем, что ты туда заливаешь.
[09:37.860 --> 09:39.860]  И оно довольно быстро переключается.
[09:39.860 --> 09:42.860]  Не знаю, как раз, сколько миллисекунд.
[09:42.860 --> 09:45.860]  То есть не на уровне так.
[09:45.860 --> 09:46.860]  Ну, не на уровне так.
[09:46.860 --> 09:47.860]  Ну, не на уровне так.
[09:47.860 --> 09:48.860]  Ну, да.
[09:48.860 --> 09:49.860]  Это не очень быстро.
[09:49.860 --> 09:50.860]  То есть не так.
[09:50.860 --> 09:51.860]  Ну, не по каждому чипу.
[09:51.860 --> 10:01.860]  Но на уровне запуска программы одной это дешево.
[10:01.860 --> 10:02.860]  Вот.
[10:02.860 --> 10:14.860]  И вот такие FPGA-шки, как вот такая оптимизация, что ты вот что-то такое специализированное делаешь, и ты это выносишь в FPGA.
[10:14.860 --> 10:15.860]  Да.
[10:15.860 --> 10:18.860]  Вот это намного более осмысленно, чем бревать...
[10:18.860 --> 10:22.860]  Ну, и для нового архитектура, конечно, хорошо будет.
[10:22.860 --> 10:24.860]  Ну, это и для старых архитектур будет.
[10:24.860 --> 10:29.860]  Хорошо, если бы вот этот такой модуль, можно было как-то цивилизованно программное строение.
[10:29.860 --> 10:31.860]  Ну, вот это уже не один десяток лет.
[10:31.860 --> 10:32.860]  Что?
[10:32.860 --> 10:35.860]  Никто пока ничего такого не любит.
[10:35.860 --> 10:37.860]  Просто, по-моему, большие действия пришли.
[10:37.860 --> 10:39.860]  Нет, нам же тяжело.
[10:39.860 --> 10:43.860]  Это, получается, нужно какую-то программу собирать под новую программу.
[10:43.860 --> 10:47.860]  А, значит, тебе нужен компилятор, который ты будешь собирать под новую программу.
[10:47.860 --> 10:49.860]  Значит, тебе и компилятор нужно собирать.
[10:49.860 --> 10:56.860]  На самом деле, про компиляцию под эти железки есть один приятный момент.
[10:56.860 --> 11:05.860]  Именно не всегда обязательно писать новые логи, а некоторые крупные компашки,
[11:05.860 --> 11:11.860]  они под некоторые такие более крутые свои железки выпустили компилятор с OpenCL.
[11:11.860 --> 11:16.860]  То есть вы можете на OpenCL вместо верилога писать куда-то туда.
[11:16.860 --> 11:24.860]  Ну, это, конечно, нормальный C вместо верилога.
[11:24.860 --> 11:26.860]  Типа как-то алюмина, что ли?
[11:26.860 --> 11:27.860]  Нет.
[11:27.860 --> 11:28.860]  Никак.
[11:28.860 --> 11:33.860]  Не в смысле убогий C, а в смысле язык уровня C.
[11:33.860 --> 11:36.860]  Надо было на карточки ходить.
[11:36.860 --> 11:41.860]  Есть только язык, как WordDSL называется.
[11:41.860 --> 11:46.860]  И вот на нём ты описываешь инструкцию, семантику, как она кодируется.
[11:46.860 --> 11:51.860]  А потом из всего этого можете, там, из генерируется декодер и всякие...
[11:51.860 --> 11:57.860]  Не, ну понятно, что существует великое множество всяких языков для этих штучек.
[11:57.860 --> 11:59.860]  Я, честно говоря, не очень виспредельствовании.
[11:59.860 --> 12:03.860]  Я знаю, что оно существует, на общие принципы.
[12:03.860 --> 12:07.860]  Но вот я бы, на самом деле, с удовольствием поднялся без какой-то железки.
[12:07.860 --> 12:09.860]  Но с этими железками следующая проблема.
[12:09.860 --> 12:12.860]  Эти РПГ-шки существуют в двух вариантах.
[12:12.860 --> 12:16.860]  Либо нечто дешёвое, но вещь в себе.
[12:16.860 --> 12:22.860]  То есть какая-то такая платка, где это вот в духе центрального процессора.
[12:22.860 --> 12:25.860]  И вы туда можете что-то залить.
[12:25.860 --> 12:29.860]  Всякие там робототехники и прочее любят подобные железки.
[12:29.860 --> 12:35.860]  Либо это карта, которая втыкается в компьютер PCI-Express.
[12:35.860 --> 12:38.860]  И может использоваться как вот такой генеринг-акселератор.
[12:38.860 --> 12:44.860]  Но стоимость её добавляет некоторое количество ноликов.
[12:44.860 --> 12:47.860]  В конце цены.
[12:47.860 --> 12:49.860]  И они как-то дико дорого стоят.
[12:51.860 --> 13:00.860]  Чего-нибудь такое адекватное и по стоимости, и удобное к использованию, как именно акселератор, а не как стендового железка.
[13:00.860 --> 13:02.860]  Вот чего-то я такого не видел.
[13:02.860 --> 13:09.860]  Вопрос в том, что вы говорили, что под камеры условно удобно свою железку, потому что она...
[13:09.860 --> 13:11.860]  Смотря что вы делаете.
[13:11.860 --> 13:14.860]  Вопрос в том, что под видеокамерой точно не имеет смысла.
[13:14.860 --> 13:17.860]  Она постоянно подключена в телефон.
[13:17.860 --> 13:24.860]  Если телефончик ещё понятно, то камеры, условно какие-то видеокамеры, это вообще безусловно.
[13:24.860 --> 13:25.860]  Почему?
[13:25.860 --> 13:28.860]  Потому что ты делаешь какую-то обработку изображений?
[13:28.860 --> 13:31.860]  Ну, у нас же нет вопроса.
[13:31.860 --> 13:35.860]  У нас пытания постоянно есть.
[13:35.860 --> 13:36.860]  Ну почему?
[13:36.860 --> 13:42.860]  Если это промышленная камера, то у тебя ограничения на размеры не может.
[13:42.860 --> 13:45.860]  Рядом с промышленной камерой поставить десктоп.
[13:45.860 --> 13:48.860]  Особенно там, где-нибудь рядом со столбом.
[13:48.860 --> 13:50.860]  То у тебя вот все камеры висит.
[13:50.860 --> 13:52.860]  Рядом десктоп стоит, не трогайте, пожалуйста.
[13:52.860 --> 13:56.860]  Ты можешь данные передавать, просто обрабатывайте в каком-то месте.
[13:56.860 --> 13:58.860]  А данные передавай с камерой.
[13:58.860 --> 14:00.860]  Вот дворода там, большой поток.
[14:00.860 --> 14:01.860]  Да.
[14:01.860 --> 14:07.860]  То есть как бы там очень даже может иметь смысл обрабатывать на камеру.
[14:07.860 --> 14:09.860]  Ещё раз, это зависит от задач.
[14:09.860 --> 14:15.860]  Где-то проще проложить просто сетку пожирнее и не париться.
[14:15.860 --> 14:20.860]  А где-то проще поставить камеру умнее и не париться с сеткой.
[14:20.860 --> 14:22.860]  Потому что сетку ты не контролируешь.
[14:22.860 --> 14:26.860]  Что тебе досталось, там у головы иногда работает, иногда нет.
[14:26.860 --> 14:28.860]  Вот получишь ничто.
[14:31.860 --> 14:34.860]  Важно, какую задачу вы решаете.
[14:34.860 --> 14:43.860]  И вот всякие статейки, они как-то хорошие, но нужно понимать, как они соотносятся с реальностью.
[14:43.860 --> 14:50.860]  То есть статейки, конечно, напишут про то, что им интересно и что это такое нововидейство.
[14:50.860 --> 14:53.860]  Но на сколько оно тебе полезно будет?
[14:53.860 --> 14:55.860]  Вообще вопрос, да.
[14:55.860 --> 14:57.860]  Вот.
[14:57.860 --> 15:00.860]  Что-то мы совсем не туда ушли.
[15:00.860 --> 15:01.860]  В компиляции.
[15:01.860 --> 15:04.860]  Можно вопрос, кстати, про команды?
[15:04.860 --> 15:05.860]  Да.
[15:05.860 --> 15:08.860]  Флотовые команды, они влияют на флаги FPU?
[15:08.860 --> 15:10.860]  Флаги FPU, да, существует.
[15:10.860 --> 15:13.860]  Там куча разных фадов, разных регистров.
[15:13.860 --> 15:15.860]  Может меняться, хотя оно словно FAD.
[15:15.860 --> 15:19.860]  А вот почему корпиляторы выкидывают эти фады?
[15:19.860 --> 15:21.860]  Какие идеи вообще?
[15:21.860 --> 15:25.860]  Давай, значит, про плавающую крышку, когда дойдём на плавающую крышку.
[15:25.860 --> 15:26.860]  Хорошо.
[15:26.860 --> 15:29.860]  Мы до неё дойдём, но явно несчастный.
[15:29.860 --> 15:34.860]  Поэтому все замороженные с плавающей крышкой и так далее.
[15:36.860 --> 15:41.860]  Так, это было про свечи, что у нас из таких управляющих конструкций.
[15:41.860 --> 15:45.860]  Следующее про организацию функций.
[15:45.860 --> 15:51.860]  В двух словах я в вас такую необходимую информацию уже влил.
[15:51.860 --> 15:54.860]  А теперь более подробно.
[15:54.860 --> 16:06.860]  Что вы можете наблюдать и как вам полезно писать, а не изобретать совсем уж дикие велосипеды.
[16:06.860 --> 16:18.860]  Во-первых, если вы хотите выделить место под локальные переменные, то замечательное место, чтобы под них выделить, это stack.
[16:18.860 --> 16:25.860]  То есть ваша функция, она начинается с того, что выделяет место на stack.
[16:25.860 --> 16:28.860]  Повторюсь ещё раз, stack растёт вниз.
[16:28.860 --> 16:34.860]  Поэтому выделение места на stack – это оплетание stack-поинта.
[16:34.860 --> 16:41.860]  SAM, ESP и, например, 32.
[16:41.860 --> 16:45.860]  Вот вы выделили на stack 32 байт памяти.
[16:45.860 --> 16:51.860]  Если вам нужно выделить там 37 байт памяти,
[16:51.860 --> 16:53.860]  горкость не объявляет.
[16:53.860 --> 16:56.860]  ESP и 4.
[16:56.860 --> 17:03.860]  Если вы в 30 битном режиме, следует округлить вверх до битности вашей программы.
[17:03.860 --> 17:14.860]  Рекомендуется, чтобы ESP был кратен в битности.
[17:14.860 --> 17:16.860]  Обращаться можно?
[17:16.860 --> 17:19.860]  Нет, можно и даже ESP сделать кратен.
[17:19.860 --> 17:23.860]  Просто это может тебе ударить по скорости.
[17:23.860 --> 17:25.860]  То есть от обращения тоже?
[17:25.860 --> 17:26.860]  Обращения нет.
[17:26.860 --> 17:28.860]  Обращения как хочешь.
[17:28.860 --> 17:32.860]  И с обращениями как раз на x86 очень хорошо.
[17:32.860 --> 17:37.860]  На x86 вы можете долбиться невыровненными обращениями куда угодно.
[17:37.860 --> 17:39.860]  И они стоят крайне низко.
[17:39.860 --> 17:45.860]  А именно на современных процессорах даже невыровненное обращение,
[17:45.860 --> 17:51.860]  если оно не пересекает к кашлинию бесплатно,
[17:51.860 --> 17:54.860]  дополнительно вы ничего не платите за то,
[17:54.860 --> 17:58.860]  что читаете невыровненные или пишете невыровненные данные,
[17:58.860 --> 18:02.860]  если они не пересекают кашлинию.
[18:02.860 --> 18:06.860]  То есть там все эти проблемы решены аккуратно,
[18:06.860 --> 18:09.860]  и вы вообще не наблюдаетесь, как продается.
[18:09.860 --> 18:14.860]  На некоторых архитектурах невыровненные обращения существуют,
[18:14.860 --> 18:17.860]  но они существенно дороже,
[18:17.860 --> 18:20.860]  а на некоторых архитектурах их просто нет.
[18:20.860 --> 18:22.860]  Поэтому хочется невыровненное обращение,
[18:22.860 --> 18:28.860]  разбивай его на мелкие кусочки и делай по байтам отдельно.
[18:28.860 --> 18:32.860]  И страдай при этом очень долго.
[18:32.860 --> 18:35.860]  Но еще раз, невыровненные обращения бесплатные,
[18:35.860 --> 18:37.860]  если они не пересекают кашлинию.
[18:37.860 --> 18:40.860]  То есть они пересекают кашлинию, они, конечно, дороже,
[18:40.860 --> 18:45.860]  и особенно дорого, если они пересекают границу страниц.
[18:45.860 --> 18:48.860]  По странице в конце.
[18:48.860 --> 18:52.860]  Но кто слышал такой термин, то он сработает.
[18:52.860 --> 18:57.860]  То есть по возможности выравнивать данные все равно смысл имеет.
[18:57.860 --> 19:00.860]  А функция выравнивает смыслу?
[19:00.860 --> 19:07.860]  Небольшой смысл имеет в плане того, что оно может улучшить каширу.
[19:07.860 --> 19:11.860]  Потому что код кашируется, как и данные кашлинии.
[19:11.860 --> 19:17.860]  Поэтому если твоя функция начинается с более выравненного адреса,
[19:17.860 --> 19:22.860]  то больше шансов, что она вот так большим куском запишет.
[19:25.860 --> 19:27.860]  Насколько это прям критично?
[19:27.860 --> 19:29.860]  Мне кажется, не особо критично.
[19:29.860 --> 19:34.860]  Интериаторы по-прежнему любят выравнивать начало функции.
[19:34.860 --> 19:42.860]  По PDCount они, как правило, выравнивают начало функции на адрес кратный длину 16.
[19:43.860 --> 19:46.860]  Ну да, можно ставить ключ к оператору.
[19:46.860 --> 19:49.860]  Я не могу сказать, насколько это прям критично.
[19:50.860 --> 19:53.860]  Если вас вопрос интересует, попробуйте.
[19:57.860 --> 20:02.860]  Итак, выделение памяти на стеке — это вот subESP что-то.
[20:02.860 --> 20:05.860]  и что-то вы хотите кратное выказать.
[20:05.860 --> 20:08.860]  То есть кратное четырём байсиком.
[20:08.860 --> 20:11.860]  То есть уделение должно быть кратное.
[20:11.860 --> 20:13.860]  То есть уделение должно быть кратное.
[20:13.860 --> 20:15.860]  Уделение должно быть кратное восьми.
[20:15.860 --> 20:17.860]  Четырёх.
[20:18.860 --> 20:21.860]  Ничего себе, не должно, а рекомендуется.
[20:23.860 --> 20:26.860]  Это рекомендация, которую вы можете научить.
[20:26.860 --> 20:32.860]  Если вы сдвинете ESP на 31, ничего мгновенно не сломается.
[20:33.860 --> 20:38.860]  Просто некая оптимизация внутри современных процессоров, например,
[20:38.860 --> 20:43.860]  ОТС работает, и какие-то операции не могут работать больше.
[20:44.860 --> 20:48.860]  Чтобы случайно не наступить на какое-то внезапное замедление,
[20:50.860 --> 20:53.860]  выделите на эти три несчастных пайти побольше.
[20:54.860 --> 20:59.860]  Вряд ли это прям сильно повлияет на потребление памяти вашей программы.
[20:59.860 --> 21:07.860]  Можно пренебрегать, потому что это рекомендация.
[21:07.860 --> 21:12.860]  Рекомендация рекомендуется стэк-пойнтом двигать на границу кратной восьми.
[21:15.860 --> 21:23.860]  И в конце, перед возвратом функции, не забывайте, вернуть всё обратно.
[21:23.860 --> 21:30.860]  Под освободительность.
[21:35.860 --> 21:37.860]  Это всё просто.
[21:37.860 --> 21:38.860]  Да.
[21:38.860 --> 21:50.860]  И вообще, если все живут в цивилизованных границах, то он тебя будет выработкой.
[21:53.860 --> 21:57.860]  И в 64-битном мире там даже есть требования, что он должен быть.
[21:58.860 --> 22:01.860]  В 64-битном мире, мне кажется, требований нету,
[22:02.860 --> 22:06.860]  потому что оно сложилось раньше, чем какие-то требования были.
[22:06.860 --> 22:10.860]  Но если все себя нормально ведут,
[22:11.860 --> 22:15.860]  то тебе все стэк-поинтеры будут двигать на сравнительную кратную.
[22:16.860 --> 22:17.860]  Не хуже, чем...
[22:21.860 --> 22:25.860]  Поэтому если тебе, когда выгодка его стэк-поинтер, то виноват не ты.
[22:25.860 --> 22:32.860]  Это, как бы, такой более экономичный.
[22:33.860 --> 22:35.860]  А что вы можете неверно встретить,
[22:36.860 --> 22:39.860]  особенно если посмотрите на то, что генерируют компиляторы,
[22:39.860 --> 22:44.860]  вы можете встретить вот такое начало, конец функции,
[22:44.860 --> 22:47.860]  как
[22:47.860 --> 22:51.860]  как
[22:51.860 --> 22:52.860]  на фигуре,
[22:52.860 --> 22:53.860]  так как
[22:53.860 --> 22:55.860]  и
[22:55.860 --> 22:56.860]  и
[22:56.860 --> 22:57.860]  и
[22:57.860 --> 22:58.860]  и
[22:58.860 --> 22:59.860]  и
[22:59.860 --> 23:00.860]  и
[23:00.860 --> 23:01.860]  и
[23:01.860 --> 23:02.860]  и
[23:02.860 --> 23:03.860]  и
[23:03.860 --> 23:04.860]  и
[23:04.860 --> 23:05.860]  и
[23:05.860 --> 23:06.860]  и
[23:06.860 --> 23:10.860]  что угодно, а в конце будет
[23:10.860 --> 23:12.860]  но
[23:12.860 --> 23:14.860]  есть
[23:14.860 --> 23:16.860]  p
[23:16.860 --> 23:18.860]  и vp
[23:18.860 --> 23:22.860]  и vp
[23:22.860 --> 23:24.860]  то есть
[23:24.860 --> 23:26.860]  обращения вот этого
[23:26.860 --> 23:28.860]  не будет
[23:28.860 --> 23:30.860]  посмотрите внимательно на эту конструкцию
[23:30.860 --> 23:32.860]  конструкция называется
[23:32.860 --> 23:34.860]  stackFrame
[23:34.860 --> 23:36.860]  получается в том, что
[23:36.860 --> 23:38.860]  вы на stack
[23:38.860 --> 23:40.860]  вот у вас здесь
[23:40.860 --> 23:42.860]  адрес
[23:42.860 --> 23:44.860]  возврата
[23:44.860 --> 23:46.860]  вот здесь
[23:46.860 --> 23:48.860]  сохраненное значение
[23:48.860 --> 23:50.860]  ebp
[23:50.860 --> 23:52.860]  старое
[23:52.860 --> 23:54.860]  и
[23:54.860 --> 23:56.860]  вы создаете
[23:56.860 --> 23:58.860]  указатель
[23:58.860 --> 24:00.860]  ebp, который
[24:00.860 --> 24:02.860]  привязан к этому месту
[24:02.860 --> 24:04.860]  дальше
[24:04.860 --> 24:06.860]  esp
[24:06.860 --> 24:08.860]  как-то
[24:08.860 --> 24:10.860]  двигается
[24:10.860 --> 24:12.860]  а
[24:12.860 --> 24:14.860]  ваши переменные, которые лежат где-нибудь
[24:14.860 --> 24:16.860]  по фиксированному адресу
[24:16.860 --> 24:18.860]  они остаются по фиксированному смещению
[24:18.860 --> 24:20.860]  относительно ebp
[24:20.860 --> 24:22.860]  то есть
[24:22.860 --> 24:24.860]  вы там что-нибудь на stack
[24:24.860 --> 24:26.860]  запушили
[24:26.860 --> 24:28.860]  и адреса ваших локальных переменных
[24:28.860 --> 24:30.860]  относительно esp
[24:30.860 --> 24:32.860]  поехали
[24:32.860 --> 24:34.860]  если же вы используете
[24:34.860 --> 24:36.860]  такой код
[24:36.860 --> 24:38.860]  то позиция относительно
[24:38.860 --> 24:40.860]  она будет фиксирована
[24:40.860 --> 24:42.860]  единственное что ваши локальные переменные
[24:42.860 --> 24:44.860]  будут иметь адреса
[24:44.860 --> 24:46.860]  ebp-
[24:46.860 --> 24:48.860]  сколько
[24:48.860 --> 24:49.860]  ebp-
[24:49.860 --> 24:50.860]  будут аргументы
[24:50.860 --> 24:51.860]  ваших
[24:51.860 --> 24:52.860]  а ebp-
[24:52.860 --> 24:54.860]  это будут локальные переменные
[24:54.860 --> 24:56.860]  ваши
[24:56.860 --> 24:58.860]  это позволяет вам
[24:58.860 --> 25:00.860]  существенно меньше
[25:00.860 --> 25:02.860]  заморачиваться с тем
[25:02.860 --> 25:04.860]  куда у вас поехали
[25:04.860 --> 25:06.860]  но какой очевидный минус
[25:06.860 --> 25:08.860]  нам это
[25:08.860 --> 25:10.860]  регистр
[25:10.860 --> 25:12.860]  то есть из уже
[25:12.860 --> 25:14.860]  семи регистров общего назначения
[25:14.860 --> 25:16.860]  степпоинтер вы не особенно потрогаете
[25:16.860 --> 25:18.860]  при вычислении
[25:18.860 --> 25:20.860]  у вас уже шесть регистров
[25:20.860 --> 25:22.860]  общего назначения
[25:22.860 --> 25:24.860]  что довольно довольно
[25:24.860 --> 25:26.860]  почему компиляторы так
[25:26.860 --> 25:28.860]  любят делать
[25:28.860 --> 25:30.860]  потому что это
[25:30.860 --> 25:32.860]  сильно-сильно упрощает
[25:32.860 --> 25:34.860]  операцию раскрутка степпо
[25:34.860 --> 25:36.860]  то есть определение
[25:36.860 --> 25:37.860]  того
[25:37.860 --> 25:39.860]  откуда вас вызвали
[25:39.860 --> 25:41.860]  если все работают
[25:41.860 --> 25:42.860]  по такому принципу
[25:42.860 --> 25:43.860]  то смотрите
[25:43.860 --> 25:45.860]  вы легко можете определить
[25:45.860 --> 25:47.860]  откуда вас вызвали
[25:47.860 --> 25:48.860]  потому что
[25:48.860 --> 25:50.860]  ваш ebp
[25:50.860 --> 25:52.860]  он
[25:52.860 --> 25:53.860]  показывает
[25:53.860 --> 25:55.860]  на ваши локальные переменные
[25:55.860 --> 25:56.860]  за ним
[25:56.860 --> 25:58.860]  адрес возврата
[25:58.860 --> 26:00.860]  то есть даже если
[26:00.860 --> 26:01.860]  где-то посередине
[26:01.860 --> 26:02.860]  вот здесь у вас что-то
[26:02.860 --> 26:03.860]  покрашилось
[26:03.860 --> 26:04.860]  сейчас
[26:04.860 --> 26:05.860]  мы же поставили
[26:05.860 --> 26:07.860]  мы же сказали что
[26:07.860 --> 26:08.860]  ebp плюс
[26:08.860 --> 26:09.860]  это будет
[26:09.860 --> 26:10.860]  будет
[26:10.860 --> 26:11.860]  так
[26:11.860 --> 26:12.860]  то есть ты обращаешься к ним
[26:12.860 --> 26:13.860]  как ebp плюс что-то
[26:13.860 --> 26:14.860]  да
[26:14.860 --> 26:15.860]  а сам ebp
[26:15.860 --> 26:17.860]  ты не трогаешь
[26:17.860 --> 26:19.860]  то есть все время работы функции
[26:19.860 --> 26:21.860]  вот отсюда
[26:21.860 --> 26:22.860]  и досюда
[26:22.860 --> 26:23.860]  ebp не трогается
[26:23.860 --> 26:25.860]  если
[26:25.860 --> 26:26.860]  здесь
[26:26.860 --> 26:27.860]  нечто
[26:27.860 --> 26:28.860]  покрашилось
[26:28.860 --> 26:29.860]  и
[26:29.860 --> 26:30.860]  значит
[26:30.860 --> 26:31.860]  знает
[26:31.860 --> 26:32.860]  что используется
[26:32.860 --> 26:33.860]  вот
[26:33.860 --> 26:34.860]  такая структура
[26:34.860 --> 26:35.860]  входа
[26:35.860 --> 26:36.860]  он
[26:36.860 --> 26:37.860]  легко определяет
[26:37.860 --> 26:38.860]  кто
[26:38.860 --> 26:39.860]  вас вызвал
[26:39.860 --> 26:41.860]  то есть
[26:41.860 --> 26:42.860]  адрес
[26:42.860 --> 26:43.860]  возврата
[26:43.860 --> 26:44.860]  просто
[26:44.860 --> 26:45.860]  ebp
[26:45.860 --> 26:46.860]  плюс 4
[26:46.860 --> 26:48.860]  это раз
[26:48.860 --> 26:49.860]  то
[26:49.860 --> 26:50.860]  второе
[26:50.860 --> 26:51.860]  если по адресу
[26:51.860 --> 26:52.860]  ebp
[26:52.860 --> 26:53.860]  прочесть значения
[26:53.860 --> 26:54.860]  то это будет
[26:54.860 --> 26:55.860]  ebp
[26:55.860 --> 26:56.860]  вот
[26:56.860 --> 26:57.860]  того кто вас вызвал
[26:57.860 --> 26:59.860]  и по адресу
[26:59.860 --> 27:00.860]  который
[27:00.860 --> 27:01.860]  вы прочли
[27:01.860 --> 27:02.860]  плюс 4
[27:02.860 --> 27:04.860]  прибежит адрес возврата
[27:04.860 --> 27:05.860]  того
[27:05.860 --> 27:06.860]  кто вызвал
[27:06.860 --> 27:07.860]  вас
[27:07.860 --> 27:09.860]  то есть вы можете
[27:09.860 --> 27:10.860]  легко
[27:10.860 --> 27:11.860]  построить
[27:11.860 --> 27:12.860]  вот этот
[27:12.860 --> 27:13.860]  стек вызов
[27:13.860 --> 27:15.860]  понятно
[27:15.860 --> 27:17.860]  и
[27:17.860 --> 27:18.860]  просто
[27:18.860 --> 27:19.860]  вот такая структура
[27:19.860 --> 27:20.860]  позволяет
[27:20.860 --> 27:21.860]  легко
[27:21.860 --> 27:22.860]  строить
[27:22.860 --> 27:23.860]  стек вызов
[27:23.860 --> 27:24.860]  да
[27:32.860 --> 27:33.860]  да
[27:33.860 --> 27:34.860]  в принципе
[27:36.860 --> 27:37.860]  более сложную
[27:37.860 --> 27:38.860]  вещь
[27:38.860 --> 27:39.860]  чем мы здесь
[27:39.860 --> 27:40.860]  делаем
[27:40.860 --> 27:41.860]  есть специализированная
[27:41.860 --> 27:42.860]  инструкция
[27:42.860 --> 27:44.860]  Enter
[27:44.860 --> 27:46.860]  у нас есть аргументы
[27:46.860 --> 27:47.860]  но ее
[27:47.860 --> 27:48.860]  компиляторы
[27:48.860 --> 27:49.860]  используют
[27:49.860 --> 27:50.860]  никогда
[27:50.860 --> 27:51.860]  потому
[27:51.860 --> 27:56.660]  Потому что её сложная функциональность в современном мире никому не нужна.
[27:57.660 --> 28:02.660]  А раз её компиляторы не используют, работают на какой скорости? Черепашью.
[28:03.360 --> 28:07.660]  Про enter? Нет, компиляторы её не используют.
[28:08.060 --> 28:14.360]  Так, конечно, какой-то её вариант, можно написать аргументы, которые будут эквивалентны вот чему-то такому.
[28:15.160 --> 28:19.660]  Любое дело, что так никто не делает, потому что это будет менее лучше написать эти команды.
[28:19.660 --> 28:25.160]  А вот комбинация вот этих команд, она эквивалентна команде leave.
[28:27.160 --> 28:32.660]  Но с какой скоростью работает команда leave на текущем процессоре?
[28:33.160 --> 28:38.160]  Компиляторы обычно также предпочитают не заниматься спекуляцией.
[28:38.160 --> 28:44.160]  То есть если ты скажешь компилятору, я оптимизирую под такой-то стройкой процессора,
[28:44.160 --> 28:48.160]  и компилятор знает, что команда leave на этом процессоре быстро,
[28:48.160 --> 28:52.660]  то он может вместо вот этих команд поставить в консентре.
[28:53.660 --> 28:55.660]  Но если ты не сказал ему так генерику компиляцию,
[28:55.660 --> 28:59.660]  тогда он не будет экспериментировать и поставить вот это,
[28:59.660 --> 29:04.660]  потому что шансов проиграть от команды leave немало.
[29:04.660 --> 29:08.160]  Да.
[29:08.160 --> 29:09.160]  Да.
[29:09.160 --> 29:10.160]  Да.
[29:10.160 --> 29:11.160]  Да.
[29:11.160 --> 29:12.160]  Да.
[29:12.160 --> 29:16.160]  Еще раз, стек-преймы, они нужны для чего?
[29:16.160 --> 29:19.160]  Для того, чтобы вам, как программистам,
[29:19.160 --> 29:23.160]  было легче обращаться к локальным переменным,
[29:23.160 --> 29:26.660]  чтобы не напрягать себя в вычислении.
[29:26.660 --> 29:29.660]  И второй плюс,
[29:29.660 --> 29:31.660]  что легко
[29:31.660 --> 29:33.660]  делать
[29:33.660 --> 29:34.660]  trace
[29:34.660 --> 29:36.660]  стек вызова
[29:36.660 --> 29:37.660]  даже
[29:37.660 --> 29:39.660]  без наличия опалочной информации.
[29:39.660 --> 29:44.160]  Понятно, что первый элемент компиляторов вообще не применим,
[29:44.160 --> 29:48.160]  то есть они явно не ради облегчения вычислений это делают.
[29:48.160 --> 29:54.160]  Они это делают ради того, чтобы легко можно было построить стек вызова.
[29:54.160 --> 29:58.660]  Но цена этому один регистр.
[29:58.660 --> 30:02.660]  Поэтому если вы скажете специальную опцию компилятору
[30:02.660 --> 30:04.660]  не заводи стек-фреймы,
[30:04.660 --> 30:07.660]  то у компилятора будет плюс один регистр,
[30:07.660 --> 30:10.660]  он будет меньше сбрасывать данные в оперативку,
[30:10.660 --> 30:12.160]  и все будет побыстрее,
[30:12.160 --> 30:14.660]  но без отладочной информации
[30:14.660 --> 30:17.160]  отладчик тебе будет показывать
[30:17.160 --> 30:19.660]  полный минус в качестве стек-фрейма.
[30:19.660 --> 30:25.160]  С моей точки зрения, конечно, это того стоит.
[30:25.160 --> 30:28.160]  Только еще раз.
[30:28.160 --> 30:30.660]  А по дефолту, даже в релизе,
[30:30.660 --> 30:32.660]  по-моему, современные компиляторы
[30:32.660 --> 30:34.660]  находятся в состоянии
[30:34.660 --> 30:36.660]  без тек-фрейма кинги.
[30:36.660 --> 30:38.660]  Ну что это в дефолту?
[30:42.160 --> 30:44.160]  Разумность стек-фрейма...
[30:44.160 --> 30:46.160]  Но функции зависят еще, наверное.
[30:46.160 --> 30:47.160]  Нет.
[30:47.160 --> 30:49.160]  Так называется foreign convention.
[30:49.160 --> 30:50.160]  Это не только оптимизация,
[30:50.160 --> 30:52.660]  но и есть foreign convention с таким названием.
[30:52.660 --> 30:53.660]  Нет.
[30:53.660 --> 30:55.660]  В смысле, у нас функция
[30:55.660 --> 30:57.660]  инкфу,
[30:57.660 --> 30:59.660]  она не только оптимизация,
[30:59.660 --> 31:02.660]  но и есть foreign convention с таким названием.
[31:02.660 --> 31:03.660]  Инкфу,
[31:03.660 --> 31:05.660]  она возвращает какой-то return bar.
[31:05.660 --> 31:06.660]  Ну и что?
[31:06.660 --> 31:07.660]  Зачем ей это делать?
[31:07.660 --> 31:08.660]  Еще раз, для того, чтобы,
[31:08.660 --> 31:09.660]  когда посреди твоей функции
[31:09.660 --> 31:10.660]  что-то покрасить,
[31:10.660 --> 31:13.660]  можно было построить легко и без дебаг информации
[31:13.660 --> 31:14.660]  стек-фрейма кинги.
[31:14.660 --> 31:15.660]  А зачем он нужен?
[31:15.660 --> 31:18.660]  Ну вот в релизе
[31:18.660 --> 31:19.660]  зачем он нужен?
[31:19.660 --> 31:20.660]  Это же стоит вот сколько?
[31:20.660 --> 31:21.660]  Раз, два, три, четыре, пять.
[31:21.660 --> 31:22.660]  Да.
[31:22.660 --> 31:23.660]  Да.
[31:23.660 --> 31:24.660]  Да.
[31:24.660 --> 31:25.660]  Ну и что?
[31:25.660 --> 31:26.660]  Зачем ей это делать?
[31:26.660 --> 31:28.660]  Еще раз, для того, чтобы,
[31:28.660 --> 31:31.660]  когда посреди твоей функции
[31:31.660 --> 31:33.660]  что-то покрашивать,
[31:33.660 --> 31:38.660]  можно было построить легко и без дебаг информации
[31:38.660 --> 31:40.660]  стек-фрейма кинги.
[31:40.660 --> 31:42.660]  А зачем он нужен?
[31:42.660 --> 31:44.660]  Ну вот в релизе зачем он нужен?
[31:44.660 --> 31:47.660]  Это же стоит вот сколько?
[31:47.660 --> 31:48.660]  Раз, два, три, четыре, пять.
[31:48.660 --> 31:49.660]  Нет.
[31:49.660 --> 31:52.660]  На самом деле, сейчас операции не такие дорогие.
[31:52.660 --> 31:54.660]  Это больше стоимость,
[31:54.660 --> 31:56.660]  что ты минус-регистер.
[31:56.660 --> 31:58.660]  Минус-регистер более заметно,
[31:58.660 --> 32:00.660]  чем эти парочки операций.
[32:05.660 --> 32:06.660]  Просто я вам говорю, что обратите внимание,
[32:06.660 --> 32:08.660]  вот это вот понятие стек-фрейма,
[32:08.660 --> 32:11.660]  и компиляторы обычно так же нелегко.
[32:11.660 --> 32:13.660]  А как без этого?
[32:13.660 --> 32:14.660]  Если у меня эксепшен прилетит,
[32:14.660 --> 32:15.660]  я хочу развернуть стек.
[32:15.660 --> 32:17.660]  Вот я C++ разработчик.
[32:17.660 --> 32:18.660]  Или я вот решил эксепшен использовать?
[32:18.660 --> 32:19.660]  Нет, нет, нет, нет.
[32:19.660 --> 32:20.660]  Это про другое.
[32:20.660 --> 32:23.660]  Чтобы развернуть стек
[32:23.660 --> 32:26.660]  вот внутри себя,
[32:26.660 --> 32:28.660]  компилятор в компании тебе
[32:28.660 --> 32:30.660]  достаточной информации.
[32:30.660 --> 32:34.660]  То есть, чтобы развернуть стек,
[32:34.660 --> 32:36.660]  кстати, я пришел эксепшен,
[32:36.660 --> 32:38.660]  в любом случае,
[32:38.660 --> 32:39.660]  как бы оно не скомпировалось,
[32:39.660 --> 32:41.660]  оно будет работать.
[32:41.660 --> 32:43.660]  Там же отдельная информация
[32:43.660 --> 32:45.660]  да, нет, там отдельная информация
[32:45.660 --> 32:47.660]  после каких-либо скомпироваться.
[32:47.660 --> 32:50.660]  А это как бы удобство
[32:50.660 --> 32:53.660]  для внешнего отладчика
[32:53.660 --> 32:57.660]  или каких-то автоматизированных средств.
[32:57.660 --> 33:00.660]  вообще выдавать стек вызова
[33:00.660 --> 33:02.660]  очень все любят,
[33:02.660 --> 33:04.660]  когда случилась какая-то ошибка,
[33:04.660 --> 33:06.660]  потому что это хоть какая-то
[33:06.660 --> 33:07.660]  осмысленная информация о том,
[33:07.660 --> 33:08.660]  что пошло не так.
[33:08.660 --> 33:10.660]  Да.
[33:10.660 --> 33:13.660]  То есть даже если вы просто
[33:13.660 --> 33:14.660]  в релизе совершенно,
[33:14.660 --> 33:16.660]  без всяких профайлеров отладчиков,
[33:16.660 --> 33:18.660]  куча программ,
[33:18.660 --> 33:22.660]  которые специальные библиотеки используют,
[33:22.660 --> 33:24.660]  что в случае каша,
[33:24.660 --> 33:26.660]  выдать стек трейс.
[33:26.660 --> 33:28.660]  Оно действительно полезно.
[33:28.660 --> 33:32.660]  Просто вот этот вот такой легкий стек трейс,
[33:32.660 --> 33:37.660]  он обеспечивается вот такой тьмой.
[33:37.660 --> 33:45.660]  если вы делаете без стек фреймов,
[33:45.660 --> 33:47.660]  как я вам перед этим написал,
[33:47.660 --> 33:50.660]  просто напрямую опускаете ESP,
[33:50.660 --> 33:53.660]  то без дополнительной информации,
[33:53.660 --> 33:57.660]  которая содержится вот в отладочной информации,
[33:57.660 --> 34:01.660]  надежно нельзя сказать,
[34:01.660 --> 34:04.660]  откуда нас вызвали.
[34:04.660 --> 34:07.660]  Потому что непонятно, где в стеке
[34:07.660 --> 34:09.660]  лежит адрес возврата.
[34:09.660 --> 34:11.660]  Там какие-то указатели,
[34:11.660 --> 34:13.660]  киша, то есть там какие-то значения,
[34:13.660 --> 34:17.660]  некоторые из них похожи на адреса.
[34:17.660 --> 34:20.660]  Кто знает, какой из них адресов тракт,
[34:20.660 --> 34:21.660]  а датчик явно без.
[34:21.660 --> 34:23.660]  Это без оптимизации.
[34:23.660 --> 34:25.660]  Что с оптимизацией?
[34:25.660 --> 34:26.660]  Вот это стек фрейм,
[34:26.660 --> 34:28.660]  это компиляторы, это с оптимизацией.
[34:28.660 --> 34:29.660]  Не-не, я вот без оптимизацией
[34:29.660 --> 34:30.660]  он просто нажал в теке.
[34:30.660 --> 34:32.660]  Нет, без оптимизации он где-то такой себя.
[34:32.660 --> 34:33.660]  Ну да.
[34:33.660 --> 34:35.660]  Потому что вот этот стек фрейм,
[34:35.660 --> 34:37.660]  это, можно сказать, структура кода,
[34:37.660 --> 34:40.660]  которую нелегко генерирует компилятор
[34:40.660 --> 34:43.660]  даже в релизе.
[34:43.660 --> 34:45.660]  Даже в релизе.
[34:45.660 --> 34:48.660]  Ради того, чтобы можно было построить
[34:48.660 --> 34:52.660]  стек вызова без отладочной информации.
[34:52.660 --> 34:56.660]  если вы понимаете, что вам это вообще не критично,
[34:56.660 --> 35:00.660]  то следует сказать ключ к компилятору
[35:00.660 --> 35:02.660]  не генерируй стек фрейм.
[35:05.660 --> 35:07.660]  Понятно?
[35:07.660 --> 35:10.660]  Т.е. вот дефолт здесь генерировать стек фрейм.
[35:10.660 --> 35:12.660]  А во 2 включено убрать стек фрейм?
[35:12.660 --> 35:13.660]  Нет.
[35:13.660 --> 35:17.660]  Значит, символ 1 уже включено убрать стек фрейм.
[35:17.660 --> 35:23.660]  Ну, на самом деле оно зависит от всего окружающего.
[35:23.660 --> 35:27.660]  И если говорить про всякие, ну, по сути,
[35:27.660 --> 35:33.660]  там это больше настройки вашего действия.
[35:33.660 --> 35:37.660]  Ну, что там они решили?
[35:41.660 --> 35:44.660]  Ну, еще раз, нелегко даже в релизе
[35:44.660 --> 35:46.660]  стек фрейм генерируют.
[35:48.660 --> 35:51.660]  Т.е. это именно для отладки ашемерного отладки?
[35:51.660 --> 35:53.660]  Ну, еще раз, не отладки,
[35:53.660 --> 35:56.660]  а для того, чтобы когда покрашивать
[35:56.660 --> 35:59.660]  можно было легко увидеть стек вызов.
[35:59.660 --> 36:03.660]  Ну, или при профилировании.
[36:03.660 --> 36:06.660]  Потому что когда профайлер вас профилирует,
[36:06.660 --> 36:08.660]  он же тоже как профилирует.
[36:08.660 --> 36:11.660]  Он видит, что вот в данный момент времени
[36:11.660 --> 36:13.660]  исполняется вот эта команда.
[36:15.660 --> 36:17.660]  А вы, наверное, хотите видеть,
[36:17.660 --> 36:20.660]  что эта команда исполнялась довольно часто.
[36:20.660 --> 36:24.660]  А что вот к этому месту мы пришли вот отсюда.
[36:24.660 --> 36:29.660]  Т.е. если кому-то другому так же потребуется
[36:29.660 --> 36:32.660]  как-то построить стек вызова,
[36:32.660 --> 36:37.660]  то вот это помогает, а отсутствие этого мешает.
[36:39.660 --> 36:42.660]  И еще раз, стек вызова вы можете построить
[36:42.660 --> 36:45.660]  при наличии отладочной информации.
[36:45.660 --> 36:48.660]  Т.е. если вы сами компилировали программу,
[36:48.660 --> 36:52.660]  и вы сказали компилятору построить
[36:52.660 --> 36:54.660]  откладочную информацию,
[36:57.660 --> 36:59.660]  то вам стек фреймы не нужны.
[37:02.660 --> 37:05.660]  Т.е. это можно написать, а можно попросить компилятор сделать .
[37:05.660 --> 37:06.660]  Т.е. можно даже сделать .
[37:06.660 --> 37:07.660]  Т.е. не это сделать.
[37:07.660 --> 37:09.660]  Т.е. можно вот эту откладочную информацию,
[37:09.660 --> 37:11.660]  например, вот под виндой,
[37:11.660 --> 37:14.660]  фреймы тогда складывать в отдельный файл.
[37:14.660 --> 37:17.660]  Т.е. не в компиливать прямо в самоисполняемый файл,
[37:17.660 --> 37:19.660]  а в отдельный файл.
[37:19.660 --> 37:21.660]  Т.е. ты в релизе компиливаешься,
[37:21.660 --> 37:24.660]  можешь скопилироваться вот без тек фрейма,
[37:24.660 --> 37:27.660]  и если у тебя есть дополнительные файлы,
[37:27.660 --> 37:29.660]  тогда у тебя отладчик, отфайлеров,
[37:29.660 --> 37:31.660]  все хорошо понимают, что это устройство.
[37:31.660 --> 37:35.660]  А если ты убей, ну, все.
[37:35.660 --> 37:38.660]  Т.е. они не уверены, что происходит,
[37:38.660 --> 37:41.660]  говорят, что непонятное со стеком происходит.
[37:41.660 --> 37:45.660]  Не могу тебе поставить, построить стек визит.
[37:46.660 --> 37:49.660]  Т.е. если я включил дебаг информацию,
[37:49.660 --> 37:52.660]  мне стек фреймы в целом не нужны утверждения такое.
[37:52.660 --> 37:54.660]  Т.е. если у тебя есть эта дебаг информация,
[37:54.660 --> 37:59.660]  то, да, вот это вот применение стек фреймов
[37:59.660 --> 38:01.660]  для того, чтобы построить стек визит,
[38:01.660 --> 38:03.660]  абсолютно не нужно,
[38:03.660 --> 38:05.660]  потому что дебаг информации несет больше информации,
[38:05.660 --> 38:10.660]  и позволяет все это сделать через билл-гоинт.
[38:14.660 --> 38:18.660]  Т.е. если я хочу, чтобы в GDB отображался кастер не особо...
[38:18.660 --> 38:20.660]  Т.е. если я хочу, чтобы GDB отображался кастер не особо...
[38:20.660 --> 38:25.660]  Т.е. если ты говоришь не делай стек фрейм, то GDB это просто обычный регистр,
[38:25.660 --> 38:27.660]  в котором компилятор может хранить твои локальные переменные,
[38:27.660 --> 38:28.660]  и делает все то же самое, что…
[38:28.660 --> 38:31.660]  Т.е. если ты говоришь не делай стек фрейм, то GDB это просто обычный регистр,
[38:31.660 --> 38:50.020]  очень даже если ты говоришь не делай сфрейм это просто обычный регистра
[38:50.020 --> 38:54.720]  которым компилятор может хранить свои локальные переменные делают то же самое
[38:54.720 --> 39:04.860]  на самом деле смотрите ситуация она даже немножко интереснее а именно посмотрите
[39:04.860 --> 39:12.420]  на табличку как можно обращаться в памяти я вам прошлый раз ее рисовал табличку про 16
[39:12.420 --> 39:18.660]  что там в этой табличке
[39:18.660 --> 39:33.120]  смотрите что в этой табличке присутствует
[39:33.120 --> 39:47.460]  вы можете обращаться в памяти через bp но не через sp поэтому в 16-битном мире стейк фрейм
[39:47.460 --> 39:55.080]  вы фактически обязателен потому что если вы хотите обращаться к данным на стейке вы не можете это
[39:55.080 --> 40:02.640]  делать через регистр сп у вас просто нет такого способа адресации поэтому там вот этот стейк фрейм
[40:02.640 --> 40:10.860]  был железобетонный это был единственный способ обратиться к данным на стейке а в 30-битном мире
[40:10.860 --> 40:19.260]  так как разрешили обращаться через ESP стейк фрейм он стал такой опциональный ключ и я никак
[40:19.260 --> 40:26.940]  не дойду до третьего применения стейк фрейма третье применение зачем может потребоваться стейк фрейм
[40:26.940 --> 40:35.160]  в этом случае компиляторы всегда будут генерировать это если вы посреди функций делаете
[40:35.160 --> 40:50.160]  аллока или аналогичное действие кто курс что такое аллока это мы аллокируем динамического размера массив на стеке
[40:50.160 --> 40:58.380]  не массив просто ты выделяешь место на стеке аллока это в каком-то смысле аналог маллока
[40:58.380 --> 41:08.100]  но выделяет место не в куче а на стеке с такими свойствами что эта память автоматически освобождается
[41:08.100 --> 41:12.380]  когда вы выходите из функции и только так ее можно освободить
[41:12.380 --> 41:28.600]  а вот смотри как работает аллока аллока просто вычитает из ESP что ты сказал
[41:28.600 --> 41:30.600]  размер
[41:30.600 --> 41:33.600]  там динамический
[41:33.600 --> 41:35.600]  ну да
[41:35.600 --> 41:36.600]  да
[41:36.600 --> 41:38.600]  динамический время выполнения в этом
[41:38.600 --> 41:39.600]  да да да
[41:39.600 --> 41:40.600]  например на каком языке
[41:40.600 --> 41:41.600]  на си
[41:41.600 --> 41:43.600]  а я не знаю
[41:43.600 --> 41:46.600]  ну и на аналогичных языках которые себе позволяют
[41:46.600 --> 41:48.600]  но на плюсах такое нет
[41:48.600 --> 41:49.600]  есть
[41:49.600 --> 41:50.600]  на плюсах
[41:50.600 --> 41:53.600]  си означает
[41:53.600 --> 41:55.600]  и на плюсах почти всегда
[41:55.600 --> 41:58.600]  а какая
[41:58.600 --> 42:02.600]  ну где как на стеке выделить
[42:02.600 --> 42:03.600]  ты можешь вызывать стишные функции
[42:03.600 --> 42:05.600]  вместо маллока пишу так
[42:05.600 --> 42:06.600]  аааа
[42:06.600 --> 42:08.600]  ааа
[42:08.600 --> 42:09.600]  ааа
[42:09.600 --> 42:10.600]  я понял
[42:10.600 --> 42:11.600]  ну представь это ничего не меняет
[42:11.600 --> 42:12.600]  это функция
[42:12.600 --> 42:13.600]  это функция
[42:13.600 --> 42:16.600]  еще раз это аналог маллока
[42:16.600 --> 42:18.600]  примерно
[42:18.600 --> 42:20.600]  маллок
[42:20.600 --> 42:24.600]  но по ней не нужно и нельзя говорить free
[42:24.600 --> 42:26.600]  ааа
[42:26.600 --> 42:31.600]  потому что эта память освобождается автоматически при выходе из функции
[42:31.600 --> 42:32.600]  да
[42:32.600 --> 42:34.600]  и выделяется она на стеке
[42:34.600 --> 42:39.600]  то есть это выделение памяти стоит одну ассемберную команду сам
[42:39.600 --> 42:40.600]  а
[42:40.600 --> 42:41.600]  а
[42:41.600 --> 42:42.600]  а
[42:42.600 --> 42:43.600]  несколько
[42:43.600 --> 42:44.600]  несколько
[42:44.600 --> 42:46.600]  нигде несколько
[42:46.600 --> 42:47.600]  нигде несколько
[42:47.600 --> 42:48.600]  нигде несколько
[42:48.600 --> 42:49.600]  смотри
[42:49.600 --> 42:50.600]  как оно работает
[42:50.600 --> 42:53.600]  вот этот аулек а
[42:53.600 --> 42:54.600]  это
[42:54.600 --> 42:56.600]  фактически
[42:56.600 --> 43:05.600]  ЗАПЕСПРАЗМЕР
[43:05.600 --> 43:08.600]  Внимательно посмотрели, что я написал.
[43:08.600 --> 43:13.600]  Да. Вот это значение нигде не трекается.
[43:13.600 --> 43:15.600]  А, в смысле, что ИПП должен быть.
[43:15.600 --> 43:21.600]  Да, потому что у нас TechFrame позволяет тебе командой вот этой вот
[43:21.600 --> 43:26.600]  освободить всю выделенную память без необходимости наблюдать за этим.
[43:26.600 --> 43:36.600]  Поэтому если вы используете внутри их эмоции ALK или какой-то аналог ее, например, VLA-VASIL,
[43:36.600 --> 43:41.600]  то компилятор будет использовать TechFrame в любом случае.
[43:41.600 --> 43:49.600]  Потому что TechFrame в этом случае используется для того, чтобы просто трекать выделение памяти.
[43:49.600 --> 43:52.600]  То есть это вот третье использование TechFrame.
[43:52.600 --> 43:56.600]  И оно вот осмысленное, да, работает.
[43:56.600 --> 44:02.600]  И оно того стоит, если вы хотите вот так динамически выделять на стеке, потому что это очень дешево.
[44:02.600 --> 44:03.600]  Да.
[44:03.600 --> 44:07.600]  Это я бы не знаю, что я назвал имя ALK.
[44:07.600 --> 44:08.600]  В смысле не знаю.
[44:08.600 --> 44:11.600]  Это такая функция, которую кандидата знает.
[44:11.600 --> 44:14.600]  Это функция, честно говоря, intrinsic.
[44:14.600 --> 44:20.600]  То есть функция, о которой компилятор имеет глубокие внутренние познания.
[44:20.600 --> 44:35.600]  То есть то, что выглядит для тебя синтактическая функция, но на самом деле это специфическая штука, про которую компилятор имеет свои собственные знания.
[44:35.600 --> 44:43.600]  И такие функции мы будем еще встречать, когда там дальше поговорим про специальные команды, всякие специальные команды в мире.
[44:43.600 --> 44:51.600]  Как современные компиляторы вытаскивают на уровень C при помощи интенсива.
[44:51.600 --> 44:57.600]  То есть вы можете написать на стеке и в плюсах тоже, для тех, кто уже понял.
[44:57.600 --> 44:59.600]  Да, это конечно.
[45:00.600 --> 45:09.600]  Нечто, что синтактически выглядит как вызов функции, но на самом деле компиляторы в это место просто поставят какую-то хитрую команду.
[45:11.600 --> 45:12.600]  Нет, это не имлайн.
[45:12.600 --> 45:33.600]  Интенсив — это вот такие штуки, которые выглядят синтактически как функции, но компилятор имеет про них свои собственные внутренние и секретные знания, и они превращаются в результат не постменинковки, а прямо в момент компиляции.
[45:33.600 --> 45:44.600]  Вот. Это было про АЛОКА.
[45:48.600 --> 45:50.600]  Какие-то вопросы?
[45:52.600 --> 45:56.600]  Сейчас АЛОКА, когда вызывается, или заранее у тебя?
[45:56.600 --> 46:01.600]  Вот, как написал АЛОКА, тогда и происходит сам ЕСПР.
[46:01.600 --> 46:03.600]  Вот именно в этом месте.
[46:03.600 --> 46:04.600]  То есть не с АЛОКА, да.
[46:07.600 --> 46:16.600]  Поэтому, если ты делаешь этот цикл, то каждый вызов АЛОКА тебе будет выделять всю новую-новую порцию на стеке.
[46:17.600 --> 46:19.600]  Как АМАЛОКА, только не на стеке.
[46:19.600 --> 46:21.600]  Ну, АМАЛОКА там всё понятно.
[46:22.600 --> 46:25.600]  Так, что это только на белутину на АЛОКА.
[46:25.600 --> 46:26.600]  Да, да, да.
[46:26.600 --> 46:28.600]  Он, кстати, округляет тоже.
[46:28.600 --> 46:29.600]  Ну, конечно.
[46:29.600 --> 46:31.600]  200, 200, 800, даже на 200.
[46:31.600 --> 46:32.600]  Да, да.
[46:32.600 --> 46:33.600]  Да, да.
[46:33.600 --> 46:37.600]  Ну, за счёт компилятор ведёт себя, не знаю, как здесь.
[46:37.600 --> 46:39.600]  Да, да.
[46:39.600 --> 46:51.600]  Вот, поэтому, в принципе, я бы рекомендовал отключать стек-фреймы, потому что это даёт вам плюс один регистр.
[46:51.600 --> 46:52.600]  Сейчас.
[46:52.600 --> 47:05.600]  Но в некоторых случаях стек-фреймы нужны, например, вот этот пример, где у вас используется АЛОКА, там вы что бы не сказали, компилятор в любом случае это не стек-фрейм.
[47:07.600 --> 47:09.600]  Наоборот, тут нужно...
[47:10.600 --> 47:11.600]  Он по дефолту не генерит.
[47:11.600 --> 47:13.600]  Тут нужно ставить флажок, чтобы он их генерил.
[47:13.600 --> 47:17.600]  Нет, то есть ты используешь АЛОКА, он не сам отключить.
[47:17.600 --> 47:21.600]  Нет, в смысле я про стек-фреймы.
[47:21.600 --> 47:23.600]  Что он по дефолту не генерит.
[47:23.600 --> 47:25.600]  Нужно ставить флажок, чтобы он их генерил.
[47:25.600 --> 47:28.600]  Там no emit frame pointer.
[47:28.600 --> 47:29.600]  Да.
[47:29.600 --> 47:30.600]  No emit frame pointer.
[47:30.600 --> 47:31.600]  Да, no emit frame pointer.
[47:31.600 --> 47:32.600]  Я слышал, когда он не генерит.
[47:32.600 --> 47:33.600]  Но emit, значит по дефолту он emit.
[47:33.600 --> 47:34.600]  Нет, там omit.
[47:34.600 --> 47:35.600]  А, not omit.
[47:35.600 --> 47:36.600]  Да, no emit frame pointer.
[47:36.600 --> 47:37.600]  А, ну окей.
[47:37.600 --> 47:39.600]  Ну, в общем я нередко люблю, что компиляторы даже не генерируют.
[47:39.600 --> 47:42.600]  Конечно, можно из себя от настроек и так далее.
[47:42.600 --> 48:03.600]  Просто имеете ввиду, что вот frame pointer.
[48:03.600 --> 48:05.600]  No emit frame pointer.
[48:05.600 --> 48:07.600]  Может быть.
[48:07.600 --> 48:09.600]  Может быть.
[48:09.600 --> 48:20.600]  Такая активизация есть, но она применяется даже в релизе не всегда.
[48:20.600 --> 48:25.600]  С этим сборюсь.
[48:25.600 --> 48:27.600]  Еще раз повторюсь.
[48:27.600 --> 48:34.600]  Я вам все-таки, наверное, больше рекомендовал бы работать без frame pointer,
[48:34.600 --> 48:37.600]  потому что это .
[48:37.600 --> 48:51.600]  И как не запутаться, повторяю, что вы можете при обращении к аргументам писать
[48:51.600 --> 48:57.600]  ESP плюс чего-нибудь там 36.
[48:57.600 --> 49:00.600]  Вот мы обращаемся к первому размеру плюс.
[49:00.600 --> 49:03.600]  Описать это как...
[49:03.600 --> 49:27.600]  Где вот это смещение, это ваше техническое смещение, которое возникло в результате там опускания стоппоинтера, всяких пушек и так далее.
[49:27.600 --> 49:30.600]  А вот это уже смещение по смыслу.
[49:30.600 --> 49:38.600]  И поэтому, если вы там где-нибудь, что-нибудь, какой-нибудь там пуш добавите, вам нужно сохранить какое-то рипистое.
[49:38.600 --> 49:47.600]  То в этом случае вам нужно всего лишь поменять вот это число, а не пересчитывать все.
[49:47.600 --> 49:53.600]  И вы видите просто по вот этому окончанию, что вот это вы обращаетесь к первому аргументу.
[49:53.600 --> 49:56.600]  И намного проще разбираться с предстоящим.
[49:56.600 --> 49:59.600]  Обратите внимание, что нет необходимости вы что-нибудь засчитывать.
[49:59.600 --> 50:02.600]  Вот такие простенькие технические выражения.
[50:02.600 --> 50:06.600]  Да, да, это все считается компилятором.
[50:06.600 --> 50:14.600]  То есть это вот многим не очевидно, а читабельность вашего кода сильно повышает.
[50:14.600 --> 50:22.600]  Если уж вы прям совсем хотите развлечить себе красоту, то в ассендере также существуют макросы.
[50:22.600 --> 50:26.600]  Притом макросы в ассендере даже более мощные, чем си.
[50:26.600 --> 50:34.600]  Поэтому вы можете даже вот эту штуку на макросе и вот эту штуку на макросе,
[50:34.600 --> 50:39.600]  чтобы у вас там были прям вообще именованные названия в ваших локальных предметах.
[50:39.600 --> 50:45.600]  Ну я не могу сказать, что они так рекомендуют, но если не хочется, то можно.
[50:45.600 --> 50:53.600]  Потом можно даже завести там у себя макросчетчик на сколько вы сдвинули ESP.
[50:53.600 --> 50:59.600]  И взять вместо команд SUBESP какую-нибудь там макрооперацию,
[50:59.600 --> 51:06.600]  выделить место на стэке, которое будет делать SUBESP и двигать ваш макросчетчик,
[51:06.600 --> 51:10.600]  чтобы вот это значение у вас вычислялось автоматически.
[51:10.600 --> 51:16.600]  Ну если захочется вот экспериментировать, то можно.
[51:16.600 --> 51:20.600]  Ну я вам рекомендую, ну хотя бы вот так.
[51:20.600 --> 51:26.600]  Так можно закройте этих.
[51:26.600 --> 51:28.600]  Там открытое окошко.
[51:28.600 --> 51:42.600]  Немножко потише.
[51:44.600 --> 51:46.600]  У нас так было посреди Матана.
[51:46.600 --> 51:48.600]  У нас было посреди Матана.
[51:48.600 --> 51:52.600]  Там в аудитории красиво.
[51:52.600 --> 51:54.600]  И вот так греческий с окна орал.
[51:54.600 --> 51:56.600]  Вот так посреди Матана.
[51:56.600 --> 51:58.600]  Там в дороге в воде.
[52:00.600 --> 52:02.600]  Приободляет меня.
[52:02.600 --> 52:04.600]  Да я не знаю.
[52:04.600 --> 52:06.600]  Меня очень сбивает.
[52:06.600 --> 52:08.600]  Когда в тебя вливает жесткий Матан.
[52:08.600 --> 52:12.600]  А тебе такой СБ.
[52:12.600 --> 52:14.600]  Подарочек.
[52:14.600 --> 52:18.600]  С этим мы разобрались.
[52:18.600 --> 52:23.600]  Что еще всякого про структуру пункции?
[52:23.600 --> 52:26.600]  Давайте более подробно про конвенцию виза.
[52:26.600 --> 52:29.600]  В прошлый раз было как по-быстрому.
[52:29.600 --> 52:32.600]  Теперь по манаме.
[52:32.600 --> 52:34.600]  Ну тоже не совсем до конца.
[52:34.600 --> 52:36.600]  Потому что еще мы не все сейчас смотрели.
[52:36.600 --> 52:40.600]  Что можно сказать про конвенцию виза?
[52:40.600 --> 52:42.600]  Вообще что приземляет конвенция виза?
[52:42.600 --> 52:46.600]  Правила, как вызывать функции.
[52:46.600 --> 52:50.600]  И этим правилом отнесется что в них?
[52:50.600 --> 52:55.600]  Во-первых, где сохранять возвращаемый адрес?
[52:55.600 --> 52:57.600]  Куда возвращаться?
[52:57.600 --> 53:04.600]  На x86 с этим просто почти всегда это просто стэк.
[53:04.600 --> 53:05.600]  Да.
[53:05.600 --> 53:10.600]  То есть с адресом возврата на x86 стэк и не париться.
[53:10.600 --> 53:12.600]  Следующий вопрос.
[53:12.600 --> 53:15.600]  Как передавать аргументы?
[53:15.600 --> 53:20.600]  Аргументы, как правило, передаются двумя способами.
[53:20.600 --> 53:23.600]  Либо стэк, либо регистры.
[53:23.600 --> 53:26.600]  И вот здесь вот есть разница.
[53:26.600 --> 53:33.600]  Конвенция CDECL.
[53:33.600 --> 53:35.600]  Что у нас еще есть?
[53:35.600 --> 53:37.600]  STD call.
[53:37.600 --> 53:39.600]  Fast call.
[53:39.600 --> 53:43.600]  Call и fast call.
[53:43.600 --> 53:47.600]  Ну вот из того, что можно...
[53:47.600 --> 53:49.600]  Ну что здесь call?
[53:49.600 --> 53:50.600]  Вектор call.
[53:50.600 --> 53:51.600]  Вектор call.
[53:51.600 --> 53:52.600]  Это вариация на тему fast call 64.
[53:52.600 --> 53:53.600]  Это по-моему, 64 битвая конвенция.
[53:53.600 --> 53:54.600]  У меня было нет предслужительного варианта.
[53:54.600 --> 53:58.600]  И она пока про вообще то, до чего мы не дошли, про симп-регистры.
[53:58.600 --> 54:07.600]  Поэтому про обычные аргументы вектор call не будет отличаться от одного из этих на полную основу.
[54:07.600 --> 54:16.600]  Итак, что можно сказать про аргументы?
[54:16.600 --> 54:17.600]  Аргументы?
[54:17.600 --> 54:18.600]  Аргументы почти везде.
[54:18.600 --> 54:23.600]  Это стэк и так называемый обратный порядок.
[54:23.600 --> 54:24.600]  Тоже самое.
[54:24.600 --> 54:25.600]  Тоже самое.
[54:25.600 --> 54:26.600]  Тоже самое.
[54:26.600 --> 54:27.600]  Тоже самое.
[54:27.600 --> 54:28.600]  Тоже самое.
[54:28.600 --> 54:30.600]  Тоже самое.
[54:30.600 --> 54:31.600]  Тоже самое.
[54:31.600 --> 54:32.600]  Здесь.
[54:32.600 --> 54:40.600]  Почти везде. Это стэк и так называемый обратный порядок.
[54:46.600 --> 54:47.600]  То же самое.
[54:49.600 --> 54:50.600]  Все же самое.
[54:51.600 --> 54:52.600]  Вот здесь.
[54:53.600 --> 54:54.600]  Комментарий.
[54:55.600 --> 54:56.600]  А, нет.
[54:57.600 --> 54:58.600]  О, он там.
[55:02.600 --> 55:13.600]  Ну, это какие-то регистры плюс стэк.
[55:18.600 --> 55:19.600]  Что происходит?
[55:20.600 --> 55:23.600]  Ну, во-первых, обратный порядок.
[55:24.600 --> 55:26.600]  Кто в прошлый раз помнит?
[55:26.600 --> 55:27.600]  То же самое.
[55:28.600 --> 55:36.600]  Если функция тэк вызывается инструментами А, В, С, то это означает, что вызов выглядит как
[55:36.600 --> 55:48.600]  Пуш-С, Пуш-Б, Пуш-А, О, Т.
[55:49.600 --> 56:03.600]  Ну, вообще, в потенциале существует конвенция Pascal, у которой стэк в прямой порядок.
[56:03.600 --> 56:10.600]  Но Pascal, как конвенция, мало кому нужна.
[56:11.600 --> 56:16.600]  Она, как я понимаю, была популярна в 16-ти линии.
[56:17.600 --> 56:30.600]  И, вроде бы, она использовалась в Pascal и Pascal-Вазме, музыкальной, в смысле, в дельфе, и в треструбительной.
[56:30.600 --> 56:36.600]  Правда, я уже как-то давно, благо, не встречался с дельфе.
[56:37.600 --> 56:39.600]  Как ни странно, он жив.
[56:40.600 --> 56:44.600]  Но, вот, я уже забыл.
[56:44.600 --> 56:48.600]  Используют они эту конвенцию, не используют.
[56:48.600 --> 56:50.600]  Но, если кто-то использует, то дей.
[56:53.600 --> 56:55.600]  Больше это никому не надо.
[56:55.600 --> 57:05.600]  Какой плюс обратного порядка аргументов, вы знаете место, где раскладается первый аргумент.
[57:05.600 --> 57:08.600]  Первый аргумент всегда раскладается по адресу
[57:08.600 --> 57:11.600]  ЕСП плюс 4.
[57:11.600 --> 57:17.600]  Второй ЕСП плюс 4, плюс размер первого аргумента.
[57:17.600 --> 57:20.600]  Как правило, плюс 4, но не обязательно.
[57:20.600 --> 57:24.600]  Если ваш первый аргумент жирный, то он может раскладаться и дальше.
[57:24.600 --> 57:33.600]  А если у вас прямой порядок аргументов, то есть push-a, push-b, push-c,
[57:33.600 --> 57:38.600]  ну, тогда вам нужно знать точно, сколько у вас аргументов.
[57:38.600 --> 57:47.600]  Поэтому, с прямым порядком, невозможно, без какой-то хитрой дополнительной информации, написать, например, barart функцию.
[57:48.600 --> 57:52.600]  Функция, которая принимает переменное число аргументов.
[57:52.600 --> 57:55.600]  Вот, с Pascal-конвенцией невозможно.
[57:59.600 --> 58:03.600]  Итак, stack-обратный порядок сделком.
[58:03.600 --> 58:05.600]  std-code тоже самое.
[58:05.600 --> 58:13.600]  Fast-call – это взять несколько аргументов первым и передать их через регистры.
[58:14.600 --> 58:19.600]  А остальные аргументы через tag в обратном порядке.
[58:20.600 --> 58:25.600]  Но, к сожалению, я не зря так сказал в серпе первого, не договорились.
[58:26.600 --> 58:32.600]  Разные компиляторы разное количество аргументов через разные регистры передают.
[58:32.600 --> 58:45.600]  То есть fast-call – это не какая-то конкретная конвенция, это вот, к сожалению, такая идея, которая разными компиляторами реализуется немножко по-разному.
[58:45.600 --> 59:00.600]  Довольно часто можно встретить это как два регистра – ecx и edx, то есть первый аргумент – ecx, второй – edx.
[59:00.600 --> 59:04.600]  Например, микрософский компилятор так себе делает.
[59:04.600 --> 59:13.600]  Но другие компиляторы могут делать с другом.
[59:13.600 --> 59:22.600]  Поэтому fast-call – это вот такое не очень совместимое создание в принципе любительный метод.
[59:22.600 --> 59:27.600]  И есть еще this-call.
[59:27.600 --> 59:31.600]  This-call – это порождение микрософта.
[59:31.600 --> 59:33.600]  Оно заключается в чем?
[59:33.600 --> 59:40.600]  В том, что когда вы вызываете какой-то метод у класса,
[59:40.600 --> 59:42.600]  что методу нужно?
[59:42.600 --> 59:43.600]  This-call.
[59:43.600 --> 59:44.600]  Указатель this.
[59:44.600 --> 59:49.600]  И вот this-call, этот самый указатель на this,
[59:49.600 --> 59:52.600]  передает в регистре gecx.
[59:52.600 --> 01:00:06.600]  А аргументы и прочие действия как std-call?
[01:00:06.600 --> 01:00:08.600]  Тогичный вопрос.
[01:00:08.600 --> 01:00:13.600]  А если у нас не this-call, то как передается указатель this?
[01:00:13.600 --> 01:00:16.600]  Как обычный аргумент?
[01:00:16.600 --> 01:00:18.600]  Как обычный аргумент, да.
[01:00:18.600 --> 01:00:20.600]  Но где обычный аргумент?
[01:00:20.600 --> 01:00:21.600]  Да.
[01:00:21.600 --> 01:00:25.600]  Как нулевой аргумент перед самым первым.
[01:00:25.600 --> 01:00:27.600]  То есть это такой скрытый аргумент,
[01:00:27.600 --> 01:00:30.600]  который компилятор втыкает перед самым первым,
[01:00:30.600 --> 01:00:35.600]  то есть при вызове функции он будет вот здесь вот.
[01:00:35.600 --> 01:00:36.600]  Да.
[01:00:36.600 --> 01:00:40.600]  А почему ты сейчас сидел бы и есть т.д-call?
[01:00:40.600 --> 01:00:41.600]  Кого?
[01:00:41.600 --> 01:00:42.600]  Сидел бы.
[01:00:42.600 --> 01:00:43.600]  Пока никакого.
[01:00:43.600 --> 01:00:44.600]  Пока никакого.
[01:00:44.600 --> 01:00:45.600]  Пока никакого.
[01:00:45.600 --> 01:00:51.600]  Т.е. если у нас this-call, то this идет в лице is.
[01:00:51.600 --> 01:00:57.600]  Если это не this-call, то на самом деле у вашей функции на один аргумент больше,
[01:00:57.600 --> 01:01:02.600]  и у вас перед самым первым аргументом добавляется этот самый this.
[01:01:02.600 --> 01:01:12.600]  Он не явный в полюсах, а на самом деле очень даже явный.
[01:01:12.600 --> 01:01:14.600]  Это было про аргументы.
[01:01:14.600 --> 01:01:15.600]  Потом.
[01:01:15.600 --> 01:01:18.600]  Когда аргументы мы запихали на стэк,
[01:01:18.600 --> 01:01:22.600]  в конце их должен кто-то со стэка убрать,
[01:01:22.600 --> 01:01:25.600]  чтобы наш стэк оказался сбалансированным.
[01:01:25.600 --> 01:01:28.600]  И кто это должен сделать?
[01:01:28.600 --> 01:01:29.600]  Так вот.
[01:01:29.600 --> 01:01:30.600]  Это...
[01:01:30.600 --> 01:01:31.600]  Ой.
[01:01:31.600 --> 01:01:32.600]  Там просто...
[01:01:32.600 --> 01:01:35.600]  Вызывающие и вызываемые,
[01:01:35.600 --> 01:01:37.600]  они очень похожи,
[01:01:37.600 --> 01:01:39.600]  как вам это означает.
[01:01:39.600 --> 01:01:40.600]  Коля и Коля.
[01:01:40.600 --> 01:01:45.600]  Стрелочка вверх – это тот, кто вызывал.
[01:01:45.600 --> 01:01:49.600]  А стрелочка вниз – это тот, кого вызывали.
[01:01:49.600 --> 01:01:51.600]  Кого вызывали?
[01:01:51.600 --> 01:01:53.600]  Кого вызывали?
[01:01:53.600 --> 01:01:55.600]  Чего-то не знаем?
[01:01:55.600 --> 01:01:57.600]  Кого вызывали?
[01:01:57.600 --> 01:02:02.600]  Это тот...
[01:02:02.600 --> 01:02:03.600]  Да.
[01:02:03.600 --> 01:02:06.600]  Эти аргументы со стэка должны быть.
[01:02:06.600 --> 01:02:09.600]  Если это CIDECL,
[01:02:09.600 --> 01:02:14.600]  то означает, что у вас вот здесь вот есть
[01:02:14.600 --> 01:02:19.600]  ADD ESP 12.
[01:02:19.600 --> 01:02:25.600]  Вот так комбирится вызов CIDECL.
[01:02:25.600 --> 01:02:32.600]  Если у вас конвенция StzCode,
[01:02:32.600 --> 01:02:35.600]  то здесь у вас ничего нету.
[01:02:35.600 --> 01:02:38.600]  А каким образом аргументы числятся?
[01:02:38.600 --> 01:02:40.600]  Так.
[01:02:40.600 --> 01:02:42.600]  Адрес просто передвигается.
[01:02:42.600 --> 01:02:43.600]  Так.
[01:02:45.600 --> 01:02:46.600]  Нет, нет.
[01:02:46.600 --> 01:02:48.600]  Мы перемещаем...
[01:02:48.600 --> 01:02:49.600]  В ADD ESP 12.
[01:02:49.600 --> 01:02:50.600]  Функция заканчивается на что?
[01:02:50.600 --> 01:02:52.600]  На red.
[01:02:52.600 --> 01:02:56.600]  А если это CIDECL функция,
[01:02:56.600 --> 01:02:59.600]  она заканчивается на что?
[01:02:59.600 --> 01:03:05.600]  Мы на этом достаем адрес возврата ручками
[01:03:05.600 --> 01:03:07.600]  и очищаем стэкл.
[01:03:07.600 --> 01:03:12.600]  А, прочитать, что я вам рассказываю про команды?
[01:03:12.600 --> 01:03:13.600]  Red N.
[01:03:13.600 --> 01:03:15.600]  И?
[01:03:15.600 --> 01:03:18.600]  Значит, на что вот эта функция здесь заканчивается?
[01:03:18.600 --> 01:03:20.600]  На red N.
[01:03:20.600 --> 01:03:21.600]  Какой N?
[01:03:21.600 --> 01:03:22.600]  По количеству?
[01:03:22.600 --> 01:03:23.600]  Да.
[01:03:23.600 --> 01:03:24.600]  Вот это включился stdCode.
[01:03:24.600 --> 01:03:25.600]  Ещё раз.
[01:03:25.600 --> 01:03:26.600]  Что делает red с аргументом?
[01:03:26.600 --> 01:03:27.600]  Он снимает адрес возврата и он не нашли.
[01:03:27.600 --> 01:03:28.600]  Да.
[01:03:28.600 --> 01:03:30.600]  Снимает адрес возврата со стэка,
[01:03:30.600 --> 01:03:31.600]  а потом увеличивает стэкпоинтер на указанное значение.
[01:03:31.600 --> 01:03:46.600]  И, честно говоря, с точки зрения происходящего это лучше, чем стэкпоинтер на указанное значение.
[01:03:46.600 --> 01:03:49.600]  А потом увеличивает стэкпоинтер на указанное значение.
[01:03:49.600 --> 01:04:01.600]  И, честно говоря, с точки зрения происходящего это лучше, чем стэкпоинтер на указанное значение.
[01:04:01.600 --> 01:04:04.600]  Потому что у вас на одну команду меньше.
[01:04:04.600 --> 01:04:08.600]  Но какой минус?
[01:04:08.600 --> 01:04:15.600]  Ну надо посчитать, сколько поймать.
[01:04:15.600 --> 01:04:19.600]  Варар можно тут.
[01:04:19.600 --> 01:04:21.600]  Варар не сделать.
[01:04:21.600 --> 01:04:25.600]  То есть, таким образом нельзя сделать варар функцию.
[01:04:25.600 --> 01:04:30.600]  Потому что вы хардкодите количество аргументов в саму функцию.
[01:04:30.600 --> 01:04:33.600]  Значит, это количество аргументов должно быть константой.
[01:04:35.600 --> 01:04:42.600]  Вот stdCode это конвенция, которую использует большинство vnapy функций.
[01:04:44.600 --> 01:04:46.600]  Кроме тех, которые варар.
[01:04:46.600 --> 01:04:51.600]  Если это vnapy функция, которая варар, она использует stdCode.
[01:04:52.600 --> 01:04:56.600]  Если это не варар, она использует stdCode.
[01:04:56.600 --> 01:04:57.600]  Да.
[01:04:59.600 --> 01:05:09.600]  Насколько быстрее stdCode с аргументом, чем stdCode и плюс stdCode?
[01:05:09.600 --> 01:05:11.600]  На одну команду как вообще?
[01:05:11.600 --> 01:05:14.600]  Ну, на команду уже по-разному планируется.
[01:05:14.600 --> 01:05:18.600]  Ну, я думаю, stdCode с аргументом, но stdCode это только обычный z.
[01:05:18.600 --> 01:05:26.600]  Потому что он отличается только тем, насколько прибавляется значение esp.
[01:05:26.600 --> 01:05:31.600]  Он управляет так 4, а так он управляет 4 плюс констант.
[01:05:31.600 --> 01:05:41.600]  Но самое главное отличие, что ты вот здесь помешаешь код.
[01:05:41.600 --> 01:05:47.600]  То есть при stdCode ты на каждый вызов должен стэкпоинтер подвинуть.
[01:05:47.600 --> 01:05:53.600]  У тебя каждый вызов функции на одну команду почты.
[01:05:53.600 --> 01:05:59.600]  А stdCode эту команду убирает из места вызова.
[01:05:59.600 --> 01:06:13.600]  В смысле он же знает, что он будет чистить. Он же может сразу почистить.
[01:06:13.600 --> 01:06:15.600]  Нет, это не будет.
[01:06:15.600 --> 01:06:16.600]  Почему?
[01:06:16.600 --> 01:06:19.600]  Потому что вы не обязаны сразу продвигать стэкпоинтер.
[01:06:19.600 --> 01:06:22.600]  Нет, здесь у нас red. Мы двигаем стэкпоинтер.
[01:06:22.600 --> 01:06:23.600]  Нет, red-то да.
[01:06:23.600 --> 01:06:25.600]  В смысле аргумент из стэка выделить,
[01:06:25.600 --> 01:06:27.600]  red-то не обязаны вот здесь.
[01:06:27.600 --> 01:06:28.600]  Ну да, да, да.
[01:06:28.600 --> 01:06:29.600]  Сразу, да.
[01:06:29.600 --> 01:06:36.600]  А red-12 мы говорим про то, что...
[01:06:36.600 --> 01:06:42.600]  После снятия со стэка добавить к ESP 12.
[01:06:42.600 --> 01:06:46.600]  12 это произведение 4 на 3.
[01:06:46.600 --> 01:06:49.600]  То есть 3 аргумента по 4 байта.
[01:06:49.600 --> 01:06:53.600]  Потому что push пушит по нашей битности.
[01:06:53.600 --> 01:06:56.600]  То есть каждый push это 32 бита и 4 байта.
[01:06:56.600 --> 01:07:01.600]  А FASCOL там на FASCOL?
[01:07:01.600 --> 01:07:03.600]  Там по-моему не договорились.
[01:07:03.600 --> 01:07:05.600]  То есть там бывает и так, и так.
[01:07:09.600 --> 01:07:13.600]  То есть FASCOL это штука такая, ну вот идея, да.
[01:07:13.600 --> 01:07:18.600]  А как компиляторы ее реализовали, ну, разно.
[01:07:19.600 --> 01:07:22.600]  То есть по факту консеркционности DECAL
[01:07:22.600 --> 01:07:25.600]  мы не после каждого выданного функции будем делать red.
[01:07:25.600 --> 01:07:27.600]  А в SDCOL мы...
[01:07:27.600 --> 01:07:29.600]  Не после каждого выданного функции,
[01:07:29.600 --> 01:07:32.600]  а функция заканчивается на просто red.
[01:07:32.600 --> 01:07:36.600]  А вызов функции, после вызова функции,
[01:07:36.600 --> 01:07:38.600]  вам нужно почистить аргумент.
[01:07:38.600 --> 01:07:43.600]  Вот это сейчас нарисована картинка для SDCOL.
[01:07:43.600 --> 01:07:45.600]  запомнили?
[01:07:45.600 --> 01:07:46.600]  Запомнили?
[01:07:46.600 --> 01:07:49.600]  Теперь сейчас я его обратно верну в SDCOL.
[01:07:49.600 --> 01:07:51.600]  SDCOL выглядит...
[01:07:51.600 --> 01:08:03.600]  Вот так выглядит степень.
[01:08:03.600 --> 01:08:05.600]  То есть просто red.
[01:08:05.600 --> 01:08:08.600]  А здесь очистить красота.
[01:08:08.600 --> 01:08:09.600]  Да.
[01:08:09.600 --> 01:08:10.600]  Да.
[01:08:10.600 --> 01:08:12.600]  А как там можно, ребята,
[01:08:12.600 --> 01:08:14.600]  снисленный БААР с фасковым?
[01:08:14.600 --> 01:08:16.600]  Ну, если выживает функция,
[01:08:16.600 --> 01:08:17.600]  она чистит.
[01:08:17.600 --> 01:08:18.600]  Снисленный?
[01:08:18.600 --> 01:08:21.600]  Нет, мне кажется,
[01:08:21.600 --> 01:08:22.600]  так не перейдет.
[01:08:26.600 --> 01:08:28.600]  Когда мы перейдем к 64-битным конвенциям,
[01:08:28.600 --> 01:08:30.600]  вот там вы увидите это развлечение,
[01:08:30.600 --> 01:08:32.600]  потому что они фасковы,
[01:08:32.600 --> 01:08:33.600]  по смыслу,
[01:08:33.600 --> 01:08:36.600]  но они поддерживают ВАРА.
[01:08:36.600 --> 01:08:38.600]  Поэтому развлечение...
[01:08:38.600 --> 01:08:39.600]  Вот.
[01:08:39.600 --> 01:08:43.600]  Пока у нас все так по-простому.
[01:08:43.600 --> 01:08:45.600] ιмир...
[01:08:45.600 --> 01:09:02.600]  Конечно,
[01:09:02.600 --> 01:09:03.600]  Важная особенность,
[01:09:03.600 --> 01:09:05.600]  что аргументы функции
[01:09:05.600 --> 01:09:07.600]  принадлежат самой функции.
[01:09:07.600 --> 01:09:09.600]  Я не верен
[01:09:09.600 --> 01:09:19.140]  про то, что будет, если вы пометите их как const, но мне очень сильно кажется, что в любом случае
[01:09:19.140 --> 01:09:26.480]  никто не рассчитывает, что аргументы сохранятся на стейке. Поэтому вы можете где-то прочитать,
[01:09:26.480 --> 01:09:33.600]  что типа сидя-ка лучше тем, что можно вот так натушить аргументы один раз, а потом несколько раз
[01:09:33.600 --> 01:09:39.680]  вызывать функцию. Мало того, что это довольно какое-то бредовое занятие, зачем вам несколько раз вызывать функцию
[01:09:39.680 --> 01:09:46.440]  с одними и теми же аргументами, но и это на самом деле незаконно, потому что функция имеет право свои
[01:09:46.440 --> 01:09:56.520]  аргументы-то и порушить на стейке. Аргументы принадлежат вызываемой функции. Она может и очень даже
[01:09:56.520 --> 01:10:03.960]  делаем, туда что-нибудь подписать. Например, вместо того, чтобы выделять стек, компеллятор может в это
[01:10:03.960 --> 01:10:11.880]  место, там где были аргументы, если они больше не нужны, сохранять ваши локальные перемены, чем не активизация.
[01:10:11.880 --> 01:10:28.760]  Вот. Это кто чистит стек? Следующий вопрос. Возвращаемое значение. Возвращаемое значение, я вам говорил,
[01:10:28.760 --> 01:10:41.640]  везде в аккумуляторе. Вот именно в такой формулировке. Что это означает? Если вы возвращаете 32-бутные
[01:10:41.640 --> 01:10:57.520]  число, то где оно будет? Яйц. Если вы возвращаете там какой-нибудь бул, где он будет? AL. То есть в той части аккумулятора,
[01:10:57.520 --> 01:11:06.600]  которая соответствует подбитности вашему возвращаемому значению. Если вы возвращаете 8-битное значение, то
[01:11:06.600 --> 01:11:16.320]  старшая часть я икса, мусор. Не надо рассчитывать, что там кто-то вам что-то обнули. Поэтому если функция
[01:11:16.320 --> 01:11:27.480]  возвращает вам бул, вы проявляете AL, а не я икс. Я икс может содержать, будет содержать мусор. Имейте это в виду.
[01:11:27.480 --> 01:11:35.480]  Не промахнитесь с размерами к аккумулятору. Это раз. Во-вторых, нередко, ну, как я поцелую
[01:11:35.480 --> 01:11:45.200]  документацию, вроде не всегда, еще используется расширение dx. Например, подлингой вот это точно работает.
[01:11:45.200 --> 01:11:54.480]  Если вы возвращаете в 3-бутном мире 6-бутное значение, то оно возвращается в расширенном аккумуляторе,
[01:11:54.480 --> 01:12:02.480]  то есть, младше 32-битное в я иксе, старше 32-битное в я иксе. Но, я еще раньше
[01:12:02.480 --> 01:12:08.480]  сказал, что и подлингусно так работает. Ничего не стало, не уверен. Посмотрите, вот у кого рукой
[01:12:08.480 --> 01:12:22.480]  Linux. Если ваша функция, если убитное, возвращает там клонг-клонг, то оно отправится в я икс, я икс или нет.
[01:12:22.480 --> 01:12:40.480]  Соответственно, если ваше значение умещается, то есть какой-нибудь там указатель, то те же самые правила.
[01:12:40.480 --> 01:12:46.480]  В я икс, еды икс положилось. Ну, я на год болте попробовал. Там, скорее всего, Linux на серваке.
[01:12:46.480 --> 01:12:50.480]  Нет, там зависит от того, как пишешь. Ну, конечно, там по дефолту, скорее всего, Linux.
[01:12:50.480 --> 01:13:00.480]  У меня GCC, так что. Ну, GCC, который 32-бит. Да, минус M32. Ну, наверное, да. Окей. Все хорошо тогда.
[01:13:00.480 --> 01:13:14.480]  Вот. И у нас встает вопрос, а что делать, если функция возвращает больше, что не лезет даже в расширенный аккумулятор?
[01:13:14.480 --> 01:13:22.480]  Почему? Потому что даже на C вы легко можете вернуть мегабайт. Как?
[01:13:22.480 --> 01:13:30.480]  Структуркой. Да. Вы отписываете структуру, заводите внутри нее массив черный мегабайт, и потом говорите,
[01:13:30.480 --> 01:13:35.480]  тип возвращаемого значения моей функции вот это структура.
[01:13:35.480 --> 01:13:39.480]  Этот мегабайт, конечно, ни в какие регистры никогда не лезет.
[01:13:39.480 --> 01:13:42.480]  Что делать в этом случае?
[01:13:42.480 --> 01:13:49.480]  В этом случае, конечно же, придется как-то возвращать чрез-указатель.
[01:13:49.480 --> 01:13:54.480]  То есть нужно где-то выделить память и передать на нее указатель.
[01:13:54.480 --> 01:14:01.480]  Вопрос только в том, кто эту память выделяет?
[01:14:01.480 --> 01:14:02.480]  Вызывающая.
[01:14:02.480 --> 01:14:04.480]  Кто этот мегабайт выделяет?
[01:14:04.480 --> 01:14:06.480]  Кто вызывает функцию?
[01:14:06.480 --> 01:14:10.480]  Или сама функция, которая возвращает это значение?
[01:14:10.480 --> 01:14:11.480]  И к чему?
[01:14:11.480 --> 01:14:15.480]  Тот кто, потому что если бы это выделялась сама функция, которую вызвали,
[01:14:15.480 --> 01:14:18.480]  память, которую она выделила, бы потом инвалидировалась.
[01:14:18.480 --> 01:14:20.480]  Нет. Ну, в смысле, если смастер.
[01:14:20.480 --> 01:14:21.480]  Ну, вообще.
[01:14:21.480 --> 01:14:23.480]  Мне кажется, кто угодно.
[01:14:23.480 --> 01:14:33.480]  Я хочу не просто кто, а еще аргументацию почему.
[01:14:33.480 --> 01:14:37.480]  Потому что он знает, куда может их поймать.
[01:14:37.480 --> 01:14:38.480]  Наверняка.
[01:14:38.480 --> 01:14:40.480]  У нас все выделилось, понятно.
[01:14:40.480 --> 01:14:44.480]  Мне не нравится ваша аргументация.
[01:14:44.480 --> 01:14:48.480]  Ну, правильный ответ тот, кто вызывает.
[01:14:48.480 --> 01:14:52.480]  Ну, а аргументацию и что-то я пока нормальнее не взвожу.
[01:14:52.480 --> 01:15:02.480]  Если это выделяет тот, кого вызвали, то молока у нас нет, у нас через стэк передается только.
[01:15:02.480 --> 01:15:08.480]  А если он выделяет это где-то на своем стэке, то у нас этот стэк потом выходит из скопа...
[01:15:08.480 --> 01:15:09.480]  А кто из хорошего выделяет нас?
[01:15:09.480 --> 01:15:10.480]  Окей.
[01:15:10.480 --> 01:15:24.480]  Если мы это пытаемся делать где-то без стандартной влете и так далее, то у нас все равно работает.
[01:15:24.480 --> 01:15:25.480]  Вопрос.
[01:15:25.480 --> 01:15:26.480]  А мы будем выделять где?
[01:15:26.480 --> 01:15:27.480]  Очевидными, мы по идее не на стэке.
[01:15:27.480 --> 01:15:28.480]  Почему?
[01:15:28.480 --> 01:15:29.480]  Можно на стэке.
[01:15:29.480 --> 01:15:30.480]  Можно на стэке.
[01:15:30.480 --> 01:15:31.480]  Ну, можно на стэке.
[01:15:31.480 --> 01:15:32.480]  Ну, хорошо.
[01:15:32.480 --> 01:15:33.480]  Мы выделяем на стэке.
[01:15:33.480 --> 01:15:34.480]  Но когда мы знаем, что...
[01:15:34.480 --> 01:15:35.480]  И когда функция закончится, скорее...
[01:15:35.480 --> 01:15:36.480]  Это ладно.
[01:15:36.480 --> 01:15:37.480]  Знаете, состав для доников очень простая.
[01:15:37.480 --> 01:15:42.480]  Она заключается в том, что память уже не только выделяет, но и освобождает.
[01:15:42.480 --> 01:16:09.480]  От этого становится все понятно, что кто выделяет память, только он знает, как ее правильно освободить.
[01:16:09.480 --> 01:16:16.480]  Поэтому если память выделяет вызываемая функция, то она завершилась.
[01:16:16.480 --> 01:16:21.480]  И как ты из нее узнаешь функция, как ты выделяла память?
[01:16:21.480 --> 01:16:24.480]  Все, она уже завершилась.
[01:16:24.480 --> 01:16:27.480]  С нее уже ничего не получить.
[01:16:27.480 --> 01:16:35.480]  Поэтому тот, кто вызывает, он должен выделять память, потому что ему же ее потом и освобождать.
[01:16:35.480 --> 01:16:40.480]  Он знает, как ее выделил, он ее освободит.
[01:16:40.480 --> 01:16:44.480]  Конечно, как правило, выделяется место на стэке.
[01:16:44.480 --> 01:16:47.480]  Но, в принципе, никто не обязывает.
[01:16:47.480 --> 01:16:52.480]  Он может выделить, как он хочет, и оно все будет работать.
[01:16:52.480 --> 01:16:59.480]  Но вот этот вот кусок выделенной памяти нужно как-то передать.
[01:16:59.480 --> 01:17:01.480]  Очевидно, что это указатель.
[01:17:01.480 --> 01:17:04.480]  Не очевидно, куда его спихать.
[01:17:04.480 --> 01:17:09.480]  Запихивает его, сюрприз, нулевым аргументом.
[01:17:09.480 --> 01:17:24.480]  То есть, если ваша функция возвращает что-то большое, класс, еще что-то, то у вас аргументов у функции на самом деле на один больше.
[01:17:24.480 --> 01:17:35.480]  И вот в этот один дополнительный аргумент, тот, кто вызывает, он там как-то выделяет память, скорее всего, у себя на стэке,
[01:17:35.480 --> 01:17:44.480]  передает вам указатель этим аргументом на то место, где вам нужно создать возвращаемое значение.
[01:17:44.480 --> 01:17:52.480]  И когда функция возвращается, то вот этот указатель, она дублирует в я икси преобразователь.
[01:17:54.480 --> 01:17:55.480]  Понятно?
[01:17:55.480 --> 01:17:59.480]  Но, конечно же, дает очевидный вопрос.
[01:17:59.480 --> 01:18:08.480]  Если у нас метод класса возвращает дофига, то у нас получается два нолевых значения.
[01:18:08.480 --> 01:18:10.480]  И кто из них более нолевого?
[01:18:12.480 --> 01:18:13.480]  Ответ.
[01:18:13.480 --> 01:18:16.480]  Не договорились.
[01:18:16.480 --> 01:18:17.480]  Понятно.
[01:18:17.480 --> 01:18:18.480]  Да.
[01:18:18.480 --> 01:18:19.480]  Не договорились.
[01:18:19.480 --> 01:18:22.480]  В смысле два возвращаемого значения.
[01:18:22.480 --> 01:18:23.480]  Нет, нет.
[01:18:23.480 --> 01:18:25.480]  Два нолевых аргумента.
[01:18:25.480 --> 01:18:26.480]  Типа this call.
[01:18:26.480 --> 01:18:28.480]  У нас не this call.
[01:18:28.480 --> 01:18:31.480]  У нас какой-нибудь там сетек.
[01:18:31.480 --> 01:18:38.480]  И это метод класса, который возвращает тебе там 256 байт.
[01:18:38.480 --> 01:18:39.480]  Ага.
[01:18:39.480 --> 01:18:40.480]  Я понял.
[01:18:40.480 --> 01:18:42.480]  У тебя метод класса, который возвращает какой-то класс.
[01:18:42.480 --> 01:18:44.480]  А мы тебе заговорились, что this это все нолевое.
[01:18:44.480 --> 01:18:45.480]  Да.
[01:18:45.480 --> 01:18:51.480]  Мы говорили, что метод класса принимает указатель на this нолевым аргументом.
[01:18:51.480 --> 01:18:56.480]  И вы теперь знаете, что если значение не лезет в аккумулятор, упрощаемое,
[01:18:56.480 --> 01:19:00.480]  то указатель на него передается тоже нулевым аргументом.
[01:19:00.480 --> 01:19:02.480]  У нас есть два нулевых аргумента.
[01:19:02.480 --> 01:19:04.480]  И кто из них более нулевой?
[01:19:04.480 --> 01:19:06.480]  Компулятор зависит.
[01:19:06.480 --> 01:19:08.480]  К сожалению, не договорились.
[01:19:08.480 --> 01:19:09.480]  Да.
[01:19:09.480 --> 01:19:17.480]  И Майкрософт более нулевым считает this.
[01:19:17.480 --> 01:19:24.480]  То есть последним на стек отправится this.
[01:19:24.480 --> 01:19:34.480]  Весь остальной мир считает, наоборот, что более нулевое это возвращаемое значение.
[01:19:34.480 --> 01:19:37.480]  Честно говоря, второй вариант лучше.
[01:19:37.480 --> 01:19:38.480]  Почему?
[01:19:38.480 --> 01:19:39.480]  Четыре байка в день есть.
[01:19:39.480 --> 01:19:40.480]  Один ваш.
[01:19:40.480 --> 01:19:41.480]  ИСИ можно.
[01:19:41.480 --> 01:19:42.480]  По правилам.
[01:19:42.480 --> 01:19:43.480]  По правилам.
[01:19:43.480 --> 01:19:45.480]  Кстати, не то и то можно вызвать ИСИ.
[01:19:45.480 --> 01:19:46.480]  Смотрите.
[01:19:46.480 --> 01:19:50.480]  Ну, кстати, не то и то можно вызвать ИСИ.
[01:19:50.480 --> 01:19:57.480]  Ну, СИ можно написать, первое, сказать, это казачий, неоплаз.
[01:19:57.480 --> 01:19:58.480]  Смотрите.
[01:19:58.480 --> 01:20:04.480]  Ну, кстати говоря, да, имеете в виду, что вызвать ИСИ,
[01:20:04.480 --> 01:20:08.480]  это синоним в данном случае не из плюсов.
[01:20:08.480 --> 01:20:09.480]  Вот так называется.
[01:20:09.480 --> 01:20:13.480]  То есть что угодно, кроме плюсов.
[01:20:13.480 --> 01:20:20.480]  Пусть у нас есть метод.
[01:20:20.480 --> 01:20:35.480]  Мы возвращаем какой-то ажирный Х.
[01:20:35.480 --> 01:20:41.480]  У нас метод N, который АВ.
[01:20:41.480 --> 01:20:50.480]  А в микрософтовской конвенции у вас на самом деле происходит следующее.
[01:20:50.480 --> 01:21:13.480]  У вас возвращается указатель на M, которая принимает вот здесь вот указатель на this A, B.
[01:21:13.480 --> 01:21:16.480]  Вот так на самом деле выглядит функция.
[01:21:16.480 --> 01:21:22.480]  В микрософтовской конвенции.
[01:21:22.480 --> 01:21:25.480]  В микрософтовских, ну, в смысле,
[01:21:25.480 --> 01:21:28.480]  даже не брать за это микрософтов, например.
[01:21:28.480 --> 01:21:31.480]  Вот и Linux и подобная система.
[01:21:31.480 --> 01:21:35.480]  Потому что это привязано не к компилятору, а к ABI-системе.
[01:21:35.480 --> 01:21:41.480]  То есть, например, какой-нибудь там MinGv будет использовать микрософтовскую конвенцию,
[01:21:41.480 --> 01:21:43.480]  иначе он не говорит о служащем.
[01:21:43.480 --> 01:21:46.480]  А вы же вроде говорили, что Минкрософт, наоборот.
[01:21:46.480 --> 01:21:47.480]  Да, здесь, наоборот.
[01:21:47.480 --> 01:21:48.480]  Да.
[01:21:48.480 --> 01:21:49.480]  Думаю.
[01:21:49.480 --> 01:21:51.480]  И там наверно войду.
[01:21:51.480 --> 01:21:52.480]  Нет.
[01:21:52.480 --> 01:21:53.480]  Здесь?
[01:21:53.480 --> 01:21:54.480]  Да.
[01:21:54.480 --> 01:21:55.480]  Это нормально.
[01:21:55.480 --> 01:21:56.480]  Это нормально.
[01:21:56.480 --> 01:21:57.480]  Почему?
[01:21:57.480 --> 01:21:58.480]  Да.
[01:21:58.480 --> 01:21:59.480]  Это нормально.
[01:21:59.480 --> 01:22:00.480]  Почему?
[01:22:00.480 --> 01:22:28.480]  Вот такая вот картина.
[01:22:28.480 --> 01:22:32.480]  Да, вот этот вот указатель на возвращаемое значение
[01:22:32.480 --> 01:22:35.480]  функция дублирует при возврате в аккумуляторе.
[01:22:35.480 --> 01:22:38.480]  Поэтому то, что я вам здесь написал, это правда.
[01:22:38.480 --> 01:22:40.480]  На самом деле оно вот так вот.
[01:22:40.480 --> 01:22:41.480]  Почему так? Я не понимаю.
[01:22:41.480 --> 01:22:42.480]  Ну такая конверсия.
[01:22:42.480 --> 01:22:43.480]  Не-не, а вообще зачем?
[01:22:43.480 --> 01:22:45.480]  Мы же можем без этого обойтись.
[01:22:45.480 --> 01:22:47.480]  Мы же на стеке, если у нас большой объект,
[01:22:47.480 --> 01:22:49.480]  мы все равно через стек его будем передавать.
[01:22:49.480 --> 01:22:50.480]  Не обязательно через стек.
[01:22:50.480 --> 01:22:52.480]  Через указатель.
[01:22:52.480 --> 01:22:55.480]  Ты можешь выделить его где хочешь.
[01:22:55.480 --> 01:22:57.480]  Как правило, он выделяется на стеке,
[01:22:57.480 --> 01:23:00.480]  но никто не отвязывал тебя, а выделяется его на стеке.
[01:23:00.480 --> 01:23:02.480]  Ну это что-то в чем-то.
[01:23:02.480 --> 01:23:04.480]  Не очень, не очень.
[01:23:04.480 --> 01:23:08.480]  Мы же знаем, грубо говоря, сайзов всех параметров.
[01:23:08.480 --> 01:23:13.480]  Мы знаем сайзов, возвращаем его в значение.
[01:23:13.480 --> 01:23:16.480]  Возвращаем его в значение?
[01:23:16.480 --> 01:23:17.480]  Нет.
[01:23:17.480 --> 01:23:18.480]  А почему мы не знаем сайзов, возвращаем его в значение?
[01:23:18.480 --> 01:23:19.480]  Знаешь, сайзов, возвращаем его в значение?
[01:23:19.480 --> 01:23:22.480]  Да, ну только можно просто на стеке выделить это место,
[01:23:22.480 --> 01:23:25.480]  типа перед параметрами в семье.
[01:23:25.480 --> 01:23:27.480]  В каких случаях вообще нет?
[01:23:27.480 --> 01:23:28.480]  Нет.
[01:23:28.480 --> 01:23:31.480]  Ты так можешь сделать, только передать этот указатель
[01:23:31.480 --> 01:23:33.480]  в качестве параметра.
[01:23:33.480 --> 01:23:37.480]  Ты выделишь место на стеке где?
[01:23:37.480 --> 01:23:39.480]  Перед всеми объемом?
[01:23:39.480 --> 01:23:41.480]  Ну, например, перед.
[01:23:41.480 --> 01:23:46.480]  Не так, что ты хочешь там его хранить.
[01:23:46.480 --> 01:23:51.480]  Ну, мало ли какое у тебя расположение локальных аргументов.
[01:23:51.480 --> 01:23:56.480]  Представь, что ты вызываешь парочку таких функций.
[01:23:56.480 --> 01:24:01.480]  Не одну такую функцию, а несколько функций, которые выражают в тебе разный объект.
[01:24:01.480 --> 01:24:04.480]  Это же разные объекты перед раз возвращаем.
[01:24:04.480 --> 01:24:05.480]  Да, но просто правильно.
[01:24:05.480 --> 01:24:07.480]  Это у тебя локальные элементы.
[01:24:07.480 --> 01:24:10.480]  Компилятор так может их расположить на стеке, как хочет,
[01:24:10.480 --> 01:24:13.480]  и передать указатели на то, где он на стеке расположил.
[01:24:13.480 --> 01:24:17.480]  А не обязательно стараться, чтобы они оказались в конце,
[01:24:17.480 --> 01:24:19.480]  а потом их как-то перемещать.
[01:24:19.480 --> 01:24:22.480]  То есть, представь, что у тебя идет не один вызов,
[01:24:22.480 --> 01:24:25.480]  а несколько вызовов таких методов,
[01:24:25.480 --> 01:24:27.480]  которые устраняются разный объект.
[01:24:27.480 --> 01:24:29.480]  Очень хорошо.
[01:24:29.480 --> 01:24:34.480]  Например, если мы возвращаем на два вызова наверх.
[01:24:34.480 --> 01:24:43.480]  То есть, у нас объект создался в вызове на два метода вниз,
[01:24:43.480 --> 01:24:46.480]  и нам надо его вернуть неизмененным наверх.
[01:24:46.480 --> 01:24:50.480]  У нас создавать место под объект может самая верхняя,
[01:24:50.480 --> 01:24:52.480]  а куда не просто провасывать указатели.
[01:24:52.480 --> 01:24:55.480]  А что лучше, например, делать?
[01:24:55.480 --> 01:24:57.480]  Нет, это функция...
[01:24:57.480 --> 01:24:59.480]  Вара.
[01:24:59.480 --> 01:25:01.480]  Ну, если она...
[01:25:01.480 --> 01:25:05.480]  Просто вара.
[01:25:05.480 --> 01:25:07.480]  Ну да, ничего не сделать.
[01:25:07.480 --> 01:25:08.480]  Да.
[01:25:08.480 --> 01:25:11.480]  Вопрос, наверное, глупый, а стек вообще где находится?
[01:25:11.480 --> 01:25:13.480]  Ну, то есть, насколько адекватно нам там мегабайт выделять?
[01:25:13.480 --> 01:25:14.480]  Или там 10 мегабайт?
[01:25:14.480 --> 01:25:21.480]  Зависит от того, как там у тебя операционная система решила,
[01:25:21.480 --> 01:25:24.480]  и что ты там сказал ручками.
[01:25:24.480 --> 01:25:28.480]  Вообще, на стеке вы можете так более-менее свободно
[01:25:28.480 --> 01:25:30.480]  рассчитывать где-то до мегабайта.
[01:25:30.480 --> 01:25:33.480]  Вот до мегабайта вы можете не особенно париться,
[01:25:33.480 --> 01:25:37.480]  но еще раз, мегабайт это не на вашу функцию, а на всех.
[01:25:37.480 --> 01:25:39.480]  На Linux получение 8 мегабайт.
[01:25:39.480 --> 01:25:40.480]  Погодите.
[01:25:40.480 --> 01:25:43.480]  Еще раз, до мегабайта ты можешь довольно свободно не париться.
[01:25:43.480 --> 01:25:48.480]  Если тебе нужно несколько больше мегабайта, там в районе 2,
[01:25:48.480 --> 01:25:51.480]  то ты можешь почитать дефолты своей системы,
[01:25:51.480 --> 01:25:54.480]  где-то там до 8, где-то нет.
[01:25:54.480 --> 01:25:57.480]  Там уже ситуация небезопасна.
[01:25:57.480 --> 01:26:00.480]  Если тебе нужно там 10 мегабайт,
[01:26:00.480 --> 01:26:05.480]  почти наверняка ты их не получишь по дефолту.
[01:26:05.480 --> 01:26:09.480]  Но я не зря сказал по дефолту.
[01:26:09.480 --> 01:26:15.480]  Всегда вы можете при создании треда настроить размеры его стека.
[01:26:15.480 --> 01:26:18.480]  Вот это вот порядка мегабайта это дефолт.
[01:26:18.480 --> 01:26:21.480]  То есть, когда вы создаете тред,
[01:26:21.480 --> 01:26:24.480]  вы просите операционную систему,
[01:26:24.480 --> 01:26:28.480]  указываете не только откуда стартовать его,
[01:26:28.480 --> 01:26:31.480]  но вы указываете операционной системе
[01:26:31.480 --> 01:26:35.480]  и размер стека, сколько зарезервируешь под этот стек.
[01:26:35.480 --> 01:26:38.480]  И здесь вы можете сказать хоть 300 мегабайт.
[01:26:38.480 --> 01:26:45.480]  То есть, если вы знаете, что в этом треде вам потребуется большой стек,
[01:26:45.480 --> 01:26:48.480]  вы можете это получить.
[01:26:48.480 --> 01:26:53.480]  Единственная особенность, что если этот тред – это ваш стартовый тред.
[01:26:53.480 --> 01:26:56.480]  Какой размер стека в стартовом треде?
[01:26:56.480 --> 01:27:01.480]  Он определяется флагами вашего исполнительного файла.
[01:27:01.480 --> 01:27:06.480]  Вот под виндой формат PE исполнительных файлов,
[01:27:06.480 --> 01:27:09.480]  там прямо точно есть такое поле «размер стека».
[01:27:09.480 --> 01:27:12.480]  Можно сказать дефолт, а можно сказать «я хочу быть столько».
[01:27:12.480 --> 01:27:16.480]  В эльфе, я думаю, наверняка есть аналогичное поле,
[01:27:16.480 --> 01:27:19.480]  которое задает размер стека стартового треда.
[01:27:21.480 --> 01:27:25.480]  Поэтому еще раз, если у тебя меньше негабайта, ты не паришься.
[01:27:25.480 --> 01:27:30.480]  Если у тебя больше негабайта, то стоит подумать,
[01:27:30.480 --> 01:27:34.480]  а стоит ли заморачиваться, если заморачиваться стоит,
[01:27:34.480 --> 01:27:39.480]  то ты можешь себе обеспечить практически любой размер разумный,
[01:27:39.480 --> 01:27:43.480]  вот специальным образом повлияв на создание треда,
[01:27:43.480 --> 01:27:45.480]  если это не стартовый тред,
[01:27:45.480 --> 01:27:49.480]  и ключиком компиляции, чтобы поставить правильное поле
[01:27:49.480 --> 01:27:54.480]  в твой исполняемый файл, если это стартовый тред.
[01:27:54.480 --> 01:27:59.480]  Ну еще раз, ты имеешь над этим, как бы, такое влияние,
[01:27:59.480 --> 01:28:01.480]  если ты исполняемый файл.
[01:28:01.480 --> 01:28:07.480]  Если ты библиотека, ну то придется жить по цивилизованным правилам,
[01:28:07.480 --> 01:28:11.480]  то есть рассчитывать, что больше негабайта ты можешь не получить.
[01:28:11.480 --> 01:28:14.480]  Не надо уделять столько на стеки.
[01:28:14.480 --> 01:28:16.480]  Если ты библиотек.
[01:28:16.480 --> 01:28:21.480]  Так вот, есть ли какие-то стандартные коллинг-конвенчоны,
[01:28:21.480 --> 01:28:25.480]  которые используют рефлакс для возврата в булл?
[01:28:25.480 --> 01:28:29.480]  Ну, иногда, конечно, буллевское значение,
[01:28:29.480 --> 01:28:32.480]  я видел, что компиляторы возвращали через кэрри флаг,
[01:28:32.480 --> 01:28:37.480]  но не сказать, что это как-то прям прижилось.
[01:28:37.480 --> 01:28:46.480]  Поэтому такое бывало, но, скорее, нет чем-то.
[01:28:46.480 --> 01:28:48.480]  Просто Гидро такое не понимает.
[01:28:48.480 --> 01:28:52.480]  А Гидро, по-моему, не понимает.
[01:28:52.480 --> 01:28:55.480]  И можно такое писать.
[01:28:55.480 --> 01:28:59.480]  Там, кажется, не через кэрри флаг было, а через кэрри флаг.
[01:28:59.480 --> 01:29:01.480]  Нет, через кэрри флаг это я не видел.
[01:29:01.480 --> 01:29:03.480]  А вот через кэрри флаг было.
[01:29:05.480 --> 01:29:08.480]  Ничего, это не степично.
[01:29:09.480 --> 01:29:13.480]  Итак, вот такая внутренняя фигня.
[01:29:14.480 --> 01:29:18.480]  Я утверждаю, что этот вариант существенно нет.
[01:29:18.480 --> 01:29:20.480]  Почему?
[01:29:20.480 --> 01:29:29.480]  Потому что вот это вы можете на C написать как
[01:29:29.480 --> 01:29:37.480]  X, M, Z, A, Z.
[01:29:37.480 --> 01:29:38.480]  Да.
[01:29:40.480 --> 01:29:45.480]  То есть вы можете превратить вызов метода
[01:29:45.480 --> 01:29:54.480]  в C-шный вызов функции, просто тупо, механически добавив
[01:29:54.480 --> 01:29:56.480]  вот этот аргумент.
[01:29:56.480 --> 01:29:59.480]  И не париться про возвращаемое значение.
[01:29:59.480 --> 01:30:02.480]  Просто его копипастите возвращаемое значение,
[01:30:02.480 --> 01:30:04.480]  и оно правильно транслируется.
[01:30:04.480 --> 01:30:08.480]  Если у вас вот такая нотация, и вы это превращаете в C-шный фон,
[01:30:08.480 --> 01:30:12.480]  ну вот ничего умнее, чем это вы не сделаете.
[01:30:12.480 --> 01:30:17.480]  Вам придется действительно ручками как-то выделять место под аргумент,
[01:30:17.480 --> 01:30:22.480]  передать адрес на него, и вот это здесь тоже в таком порядке.
[01:30:22.480 --> 01:30:26.480]  То есть вот так сократить эту нотацию и не получится.
[01:30:26.480 --> 01:30:27.480]  Да.
[01:30:27.480 --> 01:30:29.480]  Есть еще такая веселая штука, как manly.
[01:30:29.480 --> 01:30:30.480]  И прям там...
[01:30:30.480 --> 01:30:32.480]  Я понимаю, но...
[01:30:32.480 --> 01:30:33.480]  Нет, нет.
[01:30:33.480 --> 01:30:34.480]  Никакой пока не...
[01:30:34.480 --> 01:30:36.480]  Не прохажите, мы выбираемся.
[01:30:38.480 --> 01:30:40.480]  И, соответственно, у меня будет не поинтер возвращаемый,
[01:30:40.480 --> 01:30:42.480]  а прямо сам объект на C.
[01:30:42.480 --> 01:30:43.480]  Ну вот...
[01:30:43.480 --> 01:30:44.480]  Нет, нет, нет.
[01:30:44.480 --> 01:30:47.480]  Это просто сокращенная запись вот ровно этого.
[01:30:47.480 --> 01:30:49.480]  Да, но там возвращаем значение, нет поинтера.
[01:30:49.480 --> 01:30:50.480]  Это...
[01:30:50.480 --> 01:30:51.480]  Ну...
[01:30:51.480 --> 01:30:52.480]  Ну, если иди так.
[01:30:52.480 --> 01:30:54.480]  Это вас пытается донести.
[01:30:54.480 --> 01:30:57.480]  Вот это синонимы.
[01:30:57.480 --> 01:31:04.480]  Просто если ты написал вот так, означает, что ты должен ручками выделять вот как-то.
[01:31:04.480 --> 01:31:08.480]  Просто создать объект и передавать на него указатель.
[01:31:08.480 --> 01:31:11.480]  А здесь это компилятор сделает сам.
[01:31:11.480 --> 01:31:12.480]  Ок.
[01:31:12.480 --> 01:31:13.480]  Да, вот это я хотел, спасибо.
[01:31:13.480 --> 01:31:14.480]  Вот.
[01:31:14.480 --> 01:31:18.480]  То есть вот эти вещи, они работают одинаково в смысле вызова функции.
[01:31:18.480 --> 01:31:23.480]  Но если ты на C это написал, то здесь у тебя объект получается автоматом,
[01:31:23.480 --> 01:31:28.480]  а здесь тебе синтаксически нужно передавать на него указатель на него ручку.
[01:31:28.480 --> 01:31:33.480]  Но компилиция вот этого, в смысле вызова, абсолютно одинаково.
[01:31:34.480 --> 01:31:36.480]  Просто удобство на C...
[01:31:36.480 --> 01:31:38.480]  Да, я осознал.
[01:31:38.480 --> 01:31:43.480]  Ну и на любом другом языке, в котором нет C, конечно, вот так удобно.
[01:31:43.480 --> 01:31:46.480]  То есть вот здесь вот мы просто...
[01:31:46.480 --> 01:31:47.480]  Спасибо.
[01:31:47.480 --> 01:31:49.480]  А потом включить на окружающие...
[01:31:49.480 --> 01:31:54.480]  Гарантируется ли, что указатель, который мы передали, будет ровно тем указательом, который мы получили?
[01:31:54.480 --> 01:31:55.480]  Да.
[01:31:55.480 --> 01:31:56.480]  Да.
[01:31:56.480 --> 01:31:59.480]  Значит, я должна вернуть то, что ей передали вот здесь.
[01:31:59.480 --> 01:32:12.480]  Еще важный момент, обратите внимание, что если вы хотите код, который вызываем откуда-то вниз в плюсок,
[01:32:12.480 --> 01:32:16.480]  то вы ни в коем случае не хотите использовать this call.
[01:32:16.480 --> 01:32:30.480]  this call нифига невыразимо через другие конвенции в языке.
[01:32:30.480 --> 01:32:31.480]  Видите?
[01:32:31.480 --> 01:32:48.480]  Поэтому если вы захотите сделать какие-то биндинги к вашим классам не из плюсов, не обязательно C, откуда угодно из другого мира, то вы не сможете их сделать для this call конвенции.
[01:32:48.480 --> 01:33:07.480]  Вам придется написать кучу убогих переходников, которые наружу торчат как-то цивилизованно, а внутри себя преобразуют вот это вот в этот дикий ERCX.
[01:33:07.480 --> 01:33:14.480]  И вот этот this call – это дефолт для методов Microsoft-овских компиляторов.
[01:33:14.480 --> 01:33:18.480]  И компиляторы, которые работают разными совместимыми с ними.
[01:33:18.480 --> 01:33:24.480]  То есть если вы компилистесь под винду, то и сланг, и интел тоже будут себя так же вести.
[01:33:24.480 --> 01:33:40.480]  И вот такой камень в сторону некоторого народа, что разработчики всяких API делятся на понимающих в происходящем и не считая не понимающих в происходящем.
[01:33:40.480 --> 01:33:44.480]  Когда вы смотрите на API, это очень чувствуется.
[01:33:44.480 --> 01:33:51.480]  Пример разработчиков, которые очень хорошо понимают в происходящем, это те, кто проектировал DirectX.
[01:33:51.480 --> 01:33:56.480]  DirectX – это на самом деле такое плюсовое API.
[01:33:56.480 --> 01:34:00.480]  У вас такие там классы, методы, бла-бла-бла.
[01:34:00.480 --> 01:34:10.480]  Но вся вот эта вот конструкция с классами и методами у них, по крайней мере, раньше вообще совершенно официально, у них был C-шный интерфейс.
[01:34:10.480 --> 01:34:16.480]  То есть вы инкрудите вот этот же файринг, который инкрудит DirectX из C,
[01:34:16.480 --> 01:34:22.480]  и у вас вместо иерархии классов получается набор аккуратных структур.
[01:34:22.480 --> 01:34:29.480]  Вместо методов у вас функции, которые вот в таблице виртуальных функций.
[01:34:29.480 --> 01:34:32.480]  Сейчас мы еще не дошли до этого, но сейчас зайдем.
[01:34:32.480 --> 01:34:37.480]  То есть там все аккуратненько называется, добавляются дополнительные аргументы.
[01:34:37.480 --> 01:34:41.480]  И несмотря на эту фигню, вот это вот вообще не проблема.
[01:34:41.480 --> 01:34:42.480]  Почему?
[01:34:42.480 --> 01:34:52.480]  Потому что во всем API абсолютно нигде, абсолютно никто не возвращает значение, которое не уместилось бы в регистр.
[01:34:52.480 --> 01:35:05.480]  То есть если функция должна вернуть большое значение, всегда во всем API используется возвращение значения через дополнительный указатель в аргумент.
[01:35:05.480 --> 01:35:11.480]  А возвращаемое значение, как правило, вида код успешности-неуспешности.
[01:35:11.480 --> 01:35:24.480]  Поэтому вот это вот плюсовое API, оно вообще чисто автоматически внутри самих гидеров транслируется в стишный интерфейс, ну или в какой-то другой язык, куда вы хотите оттранслировать.
[01:35:24.480 --> 01:35:29.480]  Без всяких загружек, перекладников и подобных.
[01:35:29.480 --> 01:35:43.480]  В другой стороне, я вот некоторое время назад наблюдал API OpenWare, это для VR-шлемов от Steam.
[01:35:43.480 --> 01:35:52.480]  У них главное в том, что классы, они ничего не сказали, и у них там рискован.
[01:35:52.480 --> 01:35:59.480]  Поэтому по 30-довбитным миром туда по-нормальному пристыковаться можно только из плюсов.
[01:35:59.480 --> 01:36:01.480]  Больше не оттуда.
[01:36:01.480 --> 01:36:08.480]  Хочешь пристыковаться не из плюсов, тебе придется на плюсах написать файлик переходчиков,
[01:36:08.480 --> 01:36:20.480]  которые транслируют первый аргумент в вызов ECX, и местами у них вот такая фигня случается.
[01:36:20.480 --> 01:36:24.480]  То есть еще и удача вот этот пробег решится.
[01:36:24.480 --> 01:36:30.480]  То есть сам народ крепал API вообще не думая о том, во что у нас компилиться.
[01:36:30.480 --> 01:36:35.480]  Ну и пока вот так в всех плюсах, внутри одного компилятора он действительно работает.
[01:36:35.480 --> 01:36:42.480]  Пока не захочется из другого мира это вызвать, ну тогда наступают проблемы.
[01:36:42.480 --> 01:36:46.480]  То есть Microsoft, не сказать, что он прям совсем здесь плохой,
[01:36:46.480 --> 01:36:49.480]  там у них есть вообще такие здравые мысли.
[01:36:49.480 --> 01:36:55.480]  То есть пока когда я видел, что это плюсовая API автоматически транслируется в C-шное,
[01:36:55.480 --> 01:36:57.480]  просто когда вы C так включаете.
[01:36:57.480 --> 01:36:59.480]  Мне это очень впечатлило.
[01:36:59.480 --> 01:37:00.480]  Вот.
[01:37:00.480 --> 01:37:10.480]  Это было про возвращаемое значение, которое не умещается в регистр.
[01:37:10.480 --> 01:37:17.480]  На самом деле про аргументы и возвращаемое значение там немного больше заморочек,
[01:37:17.480 --> 01:37:24.480]  кто в курсе, про что я говорил, про передачу структур.
[01:37:24.480 --> 01:37:31.480]  Потому что со структурами, особенно с маленькими структурами, там свои правила.
[01:37:31.480 --> 01:37:39.480]  А именно, в некоторых случаях, если структура умещается в регистр,
[01:37:39.480 --> 01:37:43.480]  то следует ли ее просто запихать в регистр?
[01:37:43.480 --> 01:37:52.480]  То есть, например, ваша структура состоит там из двух байтов и одного шорта.
[01:37:52.480 --> 01:37:55.480]  В сумме прекрасно 32 бита.
[01:37:55.480 --> 01:38:00.480]  Но вот следует ли всю эту структуру передавать 32 битным регистрам?
[01:38:00.480 --> 01:38:03.480]  Или нет?
[01:38:03.480 --> 01:38:06.480]  Зависит от calling convention, а вот бы нет.
[01:38:06.480 --> 01:38:12.480]  Вот в разных calling convention, по-разному, я, честно говоря, не помню где как.
[01:38:12.480 --> 01:38:17.480]  Довольно очевидно, что если ваша структура не влезет в регистр,
[01:38:17.480 --> 01:38:22.480]  то какой вариант, всегда какой указатель.
[01:38:22.480 --> 01:38:26.480]  То есть функция, на самом деле, принимает не саму структуру,
[01:38:26.480 --> 01:38:29.480]  а принимает указатель на нее.
[01:38:29.480 --> 01:38:32.480]  То, что вы синтаксически написали структуру,
[01:38:32.480 --> 01:38:36.480]  это влияет только на синтаксис на уровне c.
[01:38:36.480 --> 01:38:41.480]  При вызове вместо структуры будет указатель.
[01:38:41.480 --> 01:38:46.480]  А вот если ваша структура маленькая, и она способна влезть в регистр,
[01:38:46.480 --> 01:38:49.480]  вот будет в этом месте указатель,
[01:38:49.480 --> 01:38:53.480]  или в этом месте вся структура будет запихана в регистр,
[01:38:53.480 --> 01:38:56.480]  вот это я не помню.
[01:38:56.480 --> 01:39:00.480]  И по этому и подобных тонких случаях
[01:39:00.480 --> 01:39:05.480]  я вам рекомендую почитать очень хорошую PDF-ку,
[01:39:05.480 --> 01:39:08.480]  которая так и называется calling conventions,
[01:39:08.480 --> 01:39:10.480]  и автор у нее Agna.
[01:39:10.480 --> 01:39:17.480]  Если вы найдете в Google Agna.com conventions,
[01:39:17.480 --> 01:39:19.480]  то вы найдете PDF-ку,
[01:39:19.480 --> 01:39:22.480]  там описаны конвенции не только 30-битные,
[01:39:22.480 --> 01:39:25.480]  но и 60-битные, и даже 16-битные,
[01:39:25.480 --> 01:39:29.480]  куча компиляторов, куча всяких специальных случаев,
[01:39:29.480 --> 01:39:33.480]  и даже он там описывает name-manly,
[01:39:33.480 --> 01:39:37.480]  то есть каким образом разные компиляторы
[01:39:37.480 --> 01:39:40.480]  захажают плюсовые на функции,
[01:39:40.480 --> 01:39:44.480]  как они туда заковыривают информацию о аргументах.
[01:39:46.480 --> 01:39:49.480]  А это у него же было по всем инструкциям x86?
[01:39:49.480 --> 01:39:50.480]  Да, да, да.
[01:39:50.480 --> 01:39:52.480]  Ну мы еще не дошли до этого, да,
[01:39:52.480 --> 01:39:56.480]  это тот же автор, который идет еще тоже очень хорошие PDF-ки,
[01:39:56.480 --> 01:40:00.480]  он пишет про микроархитектуру,
[01:40:00.480 --> 01:40:02.480]  анализ такой независимый,
[01:40:02.480 --> 01:40:06.480]  и ведет таблички, что он там намерил,
[01:40:06.480 --> 01:40:09.480]  про скорость исполнения разных команд.
[01:40:09.480 --> 01:40:11.480]  В чем идея?
[01:40:11.480 --> 01:40:13.480]  Идея в том, что на самом деле ИСА,
[01:40:13.480 --> 01:40:15.480]  которая официальная документация,
[01:40:15.480 --> 01:40:17.480]  она про что?
[01:40:17.480 --> 01:40:19.480]  Про результат.
[01:40:19.480 --> 01:40:23.480]  Как команды работают с точки зрения результата.
[01:40:23.480 --> 01:40:27.480]  И в ИСА информация о скорости,
[01:40:27.480 --> 01:40:29.480]  сюрприз, не входит.
[01:40:29.480 --> 01:40:36.480]  И сами разработчики тоже не горят особым желанием сообщить народу,
[01:40:36.480 --> 01:40:40.480]  а с какой скоростью работают различные команды.
[01:40:40.480 --> 01:40:45.480]  Поэтому народу приходится самостоятельно изобретать,
[01:40:45.480 --> 01:40:47.480]  как бы померить эту информацию.
[01:40:47.480 --> 01:40:52.480]  И вот один из таких крупных источников этой информации,
[01:40:52.480 --> 01:40:54.480]  это как раз тот же самый Акнерфон.
[01:40:54.480 --> 01:40:57.480]  у него там есть соседние PDF-ки,
[01:40:57.480 --> 01:41:00.480]  про что он там намерил,
[01:41:00.480 --> 01:41:02.480]  про разные процессоры,
[01:41:02.480 --> 01:41:05.480]  про все команды, которые они там поддерживают.
[01:41:05.480 --> 01:41:07.480]  У него какая-то юзерспейс-команда,
[01:41:07.480 --> 01:41:10.480]  которая имеет смысл заморачиваться.
[01:41:10.480 --> 01:41:11.480]  Акнерфон.
[01:41:11.480 --> 01:41:12.480]  К примеру, Суперисон.
[01:41:12.480 --> 01:41:13.480]  Тут Дельник Острогор,
[01:41:13.480 --> 01:41:15.480]  и там короткий уже.
[01:41:15.480 --> 01:41:16.480]  И там политично.
[01:41:16.480 --> 01:41:17.480]  То есть,
[01:41:17.480 --> 01:41:18.480]  не будет волноваться все равно.
[01:41:18.480 --> 01:41:19.480]  Придется тело,
[01:41:19.480 --> 01:41:20.480]  и туда будет.
[01:41:20.480 --> 01:41:21.480]  Смятники быстро.
[01:41:21.480 --> 01:41:22.480]  Смятники быстро.
[01:41:22.480 --> 01:41:23.480]  Смятники.
[01:41:23.480 --> 01:41:25.480]  Вот.
[01:41:25.480 --> 01:41:26.480]  Ну,
[01:41:26.480 --> 01:41:28.480]  то, что у Меднина известно,
[01:41:28.480 --> 01:41:31.480]  у него есть хорошая подрепка про
[01:41:31.480 --> 01:41:32.480]  calling conventions.
[01:41:32.480 --> 01:41:34.480]  И я вам рекомендую,
[01:41:34.480 --> 01:41:37.480]  чтобы разобраться вот во всех этих мелочах.
[01:41:37.480 --> 01:41:40.480]  Как там структуры передаются,
[01:41:40.480 --> 01:41:42.480]  как имена на английском,
[01:41:42.480 --> 01:41:43.480]  и подобное.
[01:41:43.480 --> 01:41:46.480]  На этом, наверное,
[01:41:46.480 --> 01:41:50.480]  про конвенции вызова все.
[01:41:50.480 --> 01:41:51.480]  А,
[01:41:51.480 --> 01:41:52.480]  инвестирук.
[01:41:52.480 --> 01:41:53.480]  Что?
[01:41:53.480 --> 01:41:54.480]  Ведитель.
[01:41:54.480 --> 01:41:55.480]  А, да.
[01:41:55.480 --> 01:41:57.480]  Просто рассказал, все забыл.
[01:41:57.480 --> 01:41:58.480]  На самом деле,
[01:41:58.480 --> 01:41:59.480]  да,
[01:41:59.480 --> 01:42:01.480]  следующий правильный,
[01:42:01.480 --> 01:42:03.480]  правильный
[01:42:03.480 --> 01:42:04.480]  параметр,
[01:42:04.480 --> 01:42:06.480]  который нужно указать.
[01:42:06.480 --> 01:42:07.480]  Ну, а здесь то же самое,
[01:42:07.480 --> 01:42:08.480]  что он сказал в прошлый раз.
[01:42:08.480 --> 01:42:11.480]  Какие регистры функция
[01:42:11.480 --> 01:42:13.480]  может произвольным образом портить,
[01:42:13.480 --> 01:42:16.480]  а какие регистры она должна сохранить.
[01:42:16.480 --> 01:42:19.480]  И вот везде вот здесь вот
[01:42:19.480 --> 01:42:21.480]  используется конвенция,
[01:42:21.480 --> 01:42:23.480]  что регистры
[01:42:23.480 --> 01:42:25.480]  EBX,
[01:42:25.480 --> 01:42:27.480]  EBP,
[01:42:27.480 --> 01:42:28.480]  ESI,
[01:42:28.480 --> 01:42:29.480]  EDI
[01:42:29.480 --> 01:42:30.480]  EDI,
[01:42:30.480 --> 01:42:34.480]  это сохраняемые.
[01:42:34.480 --> 01:42:35.480]  То есть,
[01:42:35.480 --> 01:42:38.480]  когда вызывали вас,
[01:42:38.480 --> 01:42:41.480]  вы можете эти значения менять,
[01:42:41.480 --> 01:42:44.480]  но должны вначале сохранить,
[01:42:44.480 --> 01:42:47.480]  перед возвратом восстановить.
[01:42:47.480 --> 01:42:48.480]  И,
[01:42:48.480 --> 01:42:49.480]  в обратную сторону,
[01:42:49.480 --> 01:42:52.480]  когда вы вызываете какую-то функцию,
[01:42:52.480 --> 01:42:53.480]  там,
[01:42:53.480 --> 01:42:54.480]  какой-нибудь там,
[01:42:54.480 --> 01:42:55.480]  ПУТС,
[01:42:55.480 --> 01:42:56.480]  как мы ее называем,
[01:42:56.480 --> 01:42:58.480]  эта функция гарантирует вам
[01:42:58.480 --> 01:43:00.480]  сохранение этих регистров.
[01:43:01.480 --> 01:43:02.480]  И,
[01:43:02.480 --> 01:43:03.480]  вы можете смело считать,
[01:43:03.480 --> 01:43:04.480]  что регистры
[01:43:04.480 --> 01:43:05.480]  EAX,
[01:43:05.480 --> 01:43:06.480]  ECX,
[01:43:06.480 --> 01:43:07.480]  EDX
[01:43:07.480 --> 01:43:09.480]  будут попорчены.
[01:43:09.480 --> 01:43:12.480]  даже если вы видите,
[01:43:12.480 --> 01:43:14.480]  что у вас какой-нибудь там
[01:43:14.480 --> 01:43:15.480]  EDX сохранился,
[01:43:15.480 --> 01:43:18.480]  на это рассчитывать нельзя.
[01:43:18.480 --> 01:43:19.480]  Там,
[01:43:19.480 --> 01:43:21.480]  какая-нибудь другая версия,
[01:43:21.480 --> 01:43:23.480]  после какого-нибудь там
[01:43:23.480 --> 01:43:24.480]  апдейта системы,
[01:43:24.480 --> 01:43:26.480]  иметь полное право этот
[01:43:26.480 --> 01:43:27.480]  EDX портит.
[01:43:27.480 --> 01:43:28.480]  То есть,
[01:43:28.480 --> 01:43:29.480]  не надо смотреть,
[01:43:29.480 --> 01:43:30.480]  что вот значение
[01:43:30.480 --> 01:43:31.480]  вдруг вышло.
[01:43:31.480 --> 01:43:33.480]  Это просто
[01:43:33.480 --> 01:43:34.480]  чистость и чайность.
[01:43:34.480 --> 01:43:35.480]  То есть,
[01:43:35.480 --> 01:43:36.480]  A,
[01:43:36.480 --> 01:43:37.480]  C,
[01:43:37.480 --> 01:43:38.480]  D,
[01:43:38.480 --> 01:43:39.480]  регистры
[01:43:39.480 --> 01:43:40.480]  портятся.
[01:43:40.480 --> 01:43:41.480]  Поэтому,
[01:43:41.480 --> 01:43:42.480]  если они вам нужны,
[01:43:42.480 --> 01:43:43.480]  перед тем,
[01:43:43.480 --> 01:43:45.480]  как кого-то внешнего вызывать,
[01:43:45.480 --> 01:43:47.480]  вы должны значение сохранить
[01:43:47.480 --> 01:43:48.480]  и восстановить,
[01:43:48.480 --> 01:43:50.480]  когда оно вам потребуется.
[01:43:50.480 --> 01:43:52.480]  так.
[01:43:52.480 --> 01:43:53.480]  Что?
[01:43:53.480 --> 01:43:56.480]  Я больше не забыл?
[01:43:56.480 --> 01:43:57.480]  Ну, вроде,
[01:43:57.480 --> 01:43:58.480]  про это не говорил вам
[01:43:58.480 --> 01:43:59.480]  в прошлый раз.
[01:43:59.480 --> 01:44:00.480]  А это в каких конвенциях?
[01:44:00.480 --> 01:44:01.480]  Во всех?
[01:44:01.480 --> 01:44:02.480]  Во всегда.
[01:44:02.480 --> 01:44:03.480]  Во всех 30-лубитных
[01:44:03.480 --> 01:44:04.480]  конвенциях
[01:44:04.480 --> 01:44:05.480]  вот такие правила.
[01:44:05.480 --> 01:44:06.480]  Ну, плюс еще
[01:44:06.480 --> 01:44:07.480]  в CDP сохраняется
[01:44:07.480 --> 01:44:08.480]  ESP.
[01:44:08.480 --> 01:44:09.480]  Нет.
[01:44:09.480 --> 01:44:10.480]  ESP
[01:44:10.480 --> 01:44:11.480]  это
[01:44:11.480 --> 01:44:13.480]  по специальным правилам.
[01:44:13.480 --> 01:44:15.480]  Стэкпоинтер
[01:44:15.480 --> 01:44:17.480]  меняется по специальным правилам.
[01:44:20.480 --> 01:44:25.480]  Хотя там, по-моему, была какая-то заморочка
[01:44:25.480 --> 01:44:26.480]  в DCC.
[01:44:26.480 --> 01:44:28.480]  Если функция
[01:44:28.480 --> 01:44:31.480]  вот возвращает большое значение,
[01:44:31.480 --> 01:44:33.480]  в каком-то случае
[01:44:33.480 --> 01:44:35.480]  функция
[01:44:35.480 --> 01:44:37.480]  вот эти четыре байта
[01:44:37.480 --> 01:44:39.480]  под возвращаемое значение
[01:44:39.480 --> 01:44:40.480]  со стэка снимает.
[01:44:40.480 --> 01:44:42.480]  Что-то я такое вспоминаю.
[01:44:42.480 --> 01:44:43.480]  Четко не помню.
[01:44:43.480 --> 01:44:45.480]  Почитайте.
[01:44:45.480 --> 01:44:48.480]  Если вам интересно разобраться.
[01:44:48.480 --> 01:44:51.480]  вот такие тонкости.
[01:44:51.480 --> 01:44:54.480]  Я помню, что такое существовало.
[01:44:54.480 --> 01:44:58.480]  Но, как бы, вывод из всего этого.
[01:44:58.480 --> 01:45:01.480]  Не надо возвращать то, что не есть.
[01:45:01.480 --> 01:45:06.480]  Если вы хотите стыковаться к вашей функции
[01:45:06.480 --> 01:45:13.480]  не только из C+, особенно не только из плюсов,
[01:45:13.480 --> 01:45:16.480]  просто не возвращайтесь к функции
[01:45:16.480 --> 01:45:17.480]  лучше всего.
[01:45:17.480 --> 01:45:20.480]  Если хотите вернуть большое значение,
[01:45:20.480 --> 01:45:22.480]  добавьте явный аргумент,
[01:45:22.480 --> 01:45:25.480]  который будет под возвращаемое значение.
[01:45:25.480 --> 01:45:27.480]  И будет у вас счастье.
[01:45:28.480 --> 01:45:31.480]  Само возвращаемое значение используйте
[01:45:31.480 --> 01:45:33.480]  либо как код возврата,
[01:45:33.480 --> 01:45:35.480]  либо как указатель.
[01:45:35.480 --> 01:45:37.480]  Указатель гарантированно врезает в регистр,
[01:45:37.480 --> 01:45:40.480]  с ним никаких проблем не будет.
[01:45:40.480 --> 01:45:43.480]  А вот возвращать огромные структурки
[01:45:43.480 --> 01:45:44.480]  прямо как структурки,
[01:45:44.480 --> 01:45:47.480]  может это, конечно, не красиво выглядит в кусах,
[01:45:47.480 --> 01:45:50.480]  но стыковаться к этому из любого другого языка
[01:45:50.480 --> 01:45:52.480]  просто ад.
[01:45:52.480 --> 01:45:59.480]  Вот это было второе.
[01:45:59.480 --> 01:46:04.480]  Превращаемое значение к конвенции.
[01:46:04.480 --> 01:46:09.480]  Наверное, про конвенции я вам все сказал.
[01:46:09.480 --> 01:46:13.480]  Более подробно здесь немножко включить.
[01:46:13.480 --> 01:46:17.480]  Ну так, почти все сказал.
[01:46:17.480 --> 01:46:19.480]  Там есть особенности про то,
[01:46:19.480 --> 01:46:22.480]  как передавать числа с плавной щиточкой.
[01:46:22.480 --> 01:46:24.480]  Но раз мы пока не умеем работать с плавной щиточкой,
[01:46:24.480 --> 01:46:27.480]  то я вам пока это не рассказываю.
[01:46:27.480 --> 01:46:30.480]  Мы это отложим до плавной щиточки.
[01:46:30.480 --> 01:46:34.480]  Ну и в трехбитном мире там совсем другие конвенции,
[01:46:34.480 --> 01:46:37.480]  поэтому тоже я туда пока не лезу.
[01:46:37.480 --> 01:46:40.480]  Там еще свои дополнительные фичи будут.
[01:46:40.480 --> 01:46:43.480]  Ну нам этого помогать.
[01:46:43.480 --> 01:46:45.480]  В основном, что вы будете видеть,
[01:46:45.480 --> 01:46:48.480]  это вот хишный runtime cdcl
[01:46:48.480 --> 01:46:52.480]  и под виндой системная функция stzcall.
[01:46:52.480 --> 01:46:55.480]  Вот это вот, это что вы будете видеть,
[01:46:55.480 --> 01:46:58.480]  если вы не сознательный человек,
[01:46:58.480 --> 01:47:00.480]  в винду.
[01:47:00.480 --> 01:47:02.480]  И fastcall вы это можете увидеть,
[01:47:02.480 --> 01:47:04.480]  но что это такое?
[01:47:04.480 --> 01:47:08.480]  Надо разбираться, глядя на конкретный компилятор,
[01:47:08.480 --> 01:47:10.480]  где это случилось.
[01:47:10.480 --> 01:47:14.480]  Поэтому вот стыковать fastcall функции друг к другу,
[01:47:14.480 --> 01:47:16.480]  вот у вас могут быть проблемы.
[01:47:16.480 --> 01:47:18.480]  Не надо так.
[01:47:20.480 --> 01:47:22.480]  У нас на сегодня еще много запланировано?
[01:47:22.480 --> 01:47:25.480]  Так я вообще думаю, наверное, дарилась, как ты уже загрузил,
[01:47:25.480 --> 01:47:27.480]  она заканчивается.
[01:47:27.480 --> 01:47:33.480]  Уже почти две пары, да.
[01:47:33.480 --> 01:47:35.480]  Я просто не знаю, сколько на росте.
[01:47:35.480 --> 01:47:37.480]  Ну и по 5.50 сейчас.
[01:47:37.480 --> 01:47:38.480]  Ладно, я не знаю про описание.
[01:47:38.480 --> 01:47:47.480]  Нет, страничная адресация у нас в конце курса.
[01:47:47.480 --> 01:47:51.480]  Мне казалось, до 6.30, да, кажется, до 6.20.
[01:47:51.480 --> 01:47:53.480]  Просто очень сильный метод.
[01:47:53.480 --> 01:47:55.480]  50 минут еще надо сейчас.
[01:47:55.480 --> 01:47:59.480]  То есть выравнивание данных, оно по-прежнему осмыслено.
[01:47:59.480 --> 01:48:05.480]  То есть если вы можете задешево данные выровнять,
[01:48:05.480 --> 01:48:07.480]  выровнять.
[01:48:07.480 --> 01:48:10.480]  Но если не можете выровнять,
[01:48:10.480 --> 01:48:14.480]  на x86 особенно париться по этому поводу не надо.
[01:48:14.480 --> 01:48:19.480]  Какие-то ваши программные извращенные способы
[01:48:19.480 --> 01:48:23.480]  как-то выровнять данные, скорее всего, будут гораздо дороже,
[01:48:23.480 --> 01:48:25.480]  чем это сделает железо.
[01:48:25.480 --> 01:48:29.480]  Поэтому если можно вот прям почти бесплатно выровнять,
[01:48:29.480 --> 01:48:31.480]  то стоит так сделать.
[01:48:31.480 --> 01:48:35.480]  Если нужно программно мучиться, не стоит так делать.
[01:48:35.480 --> 01:48:39.480]  На x86 железо это сделает лучше, чем вы.
[01:48:39.480 --> 01:48:41.480]  Комментажевые даже комплименты,
[01:48:41.480 --> 01:48:44.480]  когда там в начале пункта, где двигает по
[01:48:44.480 --> 01:48:47.480]  ну какое-то число, что мы будем.
[01:48:47.480 --> 01:48:49.480]  Что-то...
[01:48:49.480 --> 01:48:52.480]  Нет, еще раз, там фактически все выглядит,
[01:48:52.480 --> 01:48:54.480]  конечно, есть кое-что про это,
[01:48:54.480 --> 01:48:56.480]  но мы туда пока не идем.
[01:48:56.480 --> 01:49:00.480]  Потому что пока даже не совсем понятно, зачем она двигается.
[01:49:00.480 --> 01:49:02.480]  Мы еще просто за них смотрели.
[01:49:02.480 --> 01:49:08.480]  Я еще просто беру на вас, мне кажется, что это подгустал.
[01:49:08.480 --> 01:49:10.480]  Да.
[01:49:10.480 --> 01:49:11.480]  Ну, есть такое.
[01:49:11.480 --> 01:49:13.480]  Поэтому давайте я вас пищу.
[01:49:15.480 --> 01:49:17.480]  То есть у нас пока к плану,
[01:49:17.480 --> 01:49:19.480]  первая лабораторная.
[01:49:20.480 --> 01:49:22.480]  Это дизайн?
[01:49:22.480 --> 01:49:24.480]  Ну, пока не зазнаем.
[01:49:24.480 --> 01:49:25.480]  Но...
[01:49:25.480 --> 01:49:26.480]  Дизайн, когда не вылезет.
[01:49:26.480 --> 01:49:27.480]  Но...
[01:49:27.480 --> 01:49:28.480]  Дизайн, когда не вылезет.
[01:49:28.480 --> 01:49:29.480]  Начать через первую.
[01:49:29.480 --> 01:49:30.480]  Просто я понимаю.
