# ðŸ§® FPU / x87 â€” Complete Comprehensive Guide

## 1. History and Architecture

| Generation | Description |
|-------------|--------------|
| **Intel 8086 (1978)** | Had no hardware floating-point support â€” all math was software-emulated. |
| **Intel 8087 (1980)** | The first floating-point coprocessor. Added the `F*` instruction set to the CPU. |
| **80287 / 80387** | Improved IEEE 754 compliance, faster operations, more instructions. |
| **Intel 486DX** | Integrated the FPU directly into the CPU die. |
| **Pentium and later** | FPU became a standard component; later extended by SSE/AVX. |

**Purpose:** The Floating Point Unit (FPU) is a dedicated hardware block that performs arithmetic operations on floating-point numbers â€” addition, multiplication, division, trigonometry, etc.

---

## 2. Architecture and Registers

### Stack Organization
- The FPU is a **stack-based machine** with **8 registers**.
- Registers are named **ST(0)**â€“**ST(7)** (internally **R0â€“R7**).
- **ST(0)** is always the top of the stack.
- Pushing values (e.g., `FLD`) decrements the stack pointer; popping (`FSTP`, `FISTP`) increments it.
- Internally, all values are stored in **80-bit extended precision format**.

### 80-bit Extended Precision Format
| Field | Size (bits) | Description |
|--------|--------------|-------------|
| Sign | 1 | Sign bit |
| Exponent | 15 | Exponent with bias 16383 |
| Mantissa | 64 | Fractional part (includes leading 1) |

**Benefit:** High precision intermediate results reduce rounding errors in complex expressions.

---

## 3. Control and Status Registers

| Register | Description |
|-----------|--------------|
| **Control Word** | Defines rounding mode, precision, and exception masks. |
| **Status Word** | Holds condition flags (Zero, Overflow, NaN, etc.). |
| **Tag Word** | Indicates which stack registers are free or busy. |
| **Instruction/Data Pointers** | Track the last executed FPU instruction and operand. |

**Rounding modes:**
- To nearest even (default)
- Toward zero
- Toward +âˆž
- Toward âˆ’âˆž

**Precision modes:**
- Single (24-bit mantissa)
- Double (53-bit mantissa)
- Extended (64-bit mantissa)

---

## 4. Stack Behavior and NaN Conditions

| Condition | Result |
|------------|---------|
| Reading an empty register | Returns `NaN` |
| Writing to an occupied register | Produces `NaN` |
| Stack overflow (push > 8 values) | Top element becomes invalid |
| Stack underflow (pop from empty) | Undefined / `NaN` |

FPU maintains an **occupancy bitmask** in the Tag Word that tracks register usage.

---

## 5. Supported Data Formats

| Format | Size | Description |
|---------|------|-------------|
| **float** | 32 bits | Single precision (IEEE 754) |
| **double** | 64 bits | Double precision |
| **extended** | 80 bits | FPU internal format |
| **int16 / int32 / int64 (signed)** | 16â€“64 bits | Supported conversions |
| **unsigned int** | â€” | Not supported directly |
| **BCD80** | 80 bits (10 bytes) | Packed decimal format (legacy) |

**Note:** All FPU data transfers go **through memory** â€” there are no direct CPU â†” FPU register moves.  
Example: `EAX â†’ [mem] â†’ FLD [mem]`

---

## 6. Core Instructions

### Load / Store Operations

| Instruction | Description |
|--------------|--------------|
| `FLD` | Load a floating-point value (float/double/extended) |
| `FILD` | Load a signed integer |
| `FBLD` | Load a BCD value |
| `FLDZ`, `FLD1`, `FLDPI` | Push constants 0, 1, Ï€ |
| `FST`, `FSTP` | Store ST(0) to memory (with or without pop) |
| `FIST`, `FISTP` | Store integer result |
| `FBSTP` | Store BCD result |
| `FXCH` | Exchange ST(0) â†” ST(i); executes in 0 cycles |

---

### Arithmetic Operations

| Instruction | Description |
|--------------|--------------|
| `FADD`, `FIADD` | Add (float / integer) |
| `FSUB`, `FSUBR` | Subtract (Aâˆ’B or Bâˆ’A) |
| `FMUL` | Multiply |
| `FDIV`, `FDIVR` | Divide (A/B or B/A) |
| `FPREM`, `FPREM1` | Remainder of ST(0)/ST(1) |
| `FABS` | Absolute value |
| `FCHS` | Change sign |
| `FRNDINT` | Round to integer using current rounding mode |
| `FSQRT` | Square root |
| `FSIN`, `FCOS`, `FSINCOS` | Trigonometric functions |
| `FPTAN`, `FPATAN` | Tangent and arctangent |
| `FXAM` | Examine ST(0) type (NaN, zero, infinity, etc.) |

**Rule:** Arithmetic instructions always involve **ST(0)** as one operand.  
Example: `FADD ST(3), ST(0)` â†’ `ST(3) = ST(3) + ST(0)`

---

### Comparison and Logical Instructions

| Instruction | Description |
|--------------|--------------|
| `FCOM`, `FCOMP`, `FCOMPP` | Compare ST(0) with ST(i), set FPU flags |
| `FCOMI`, `FCOMIP` | Compare and set CPU EFLAGS (for conditional jumps) |
| `FTST` | Compare ST(0) with 0 |
| `FCMOV` | Conditional move from ST(i) to ST(0) based on CPU flags |
| `FNOP` | No operation |

---

### Stack Management

| Instruction | Description |
|--------------|--------------|
| `FINCSTP`, `FDECSTP` | Increment or decrement stack pointer without moving data |
| `FFREE ST(i)` | Mark register as free |
| `FNINIT`, `FNCLEX` | Initialize FPU / clear exceptions |

---

## 7. Exceptions and Masking

| Type | Example | Behavior |
|-------|----------|-----------|
| Division by zero | `1 / 0` | Returns Â±âˆž or raises exception |
| Invalid operation | `sqrt(-1)` | Returns `NaN` |
| Overflow | Too large value | Â±âˆž |
| Underflow | Too small value | Denormal or 0 |
| Inexact result | Rounding occurred | Usually masked |

Exceptions can be masked/unmasked using the Control Word.  
Unmasked exceptions can raise hardware traps or OS signals.

---

## 8. Calling Conventions

| Platform | Argument Passing | Return Value | FPU State Requirement |
|-----------|------------------|--------------|------------------------|
| **32-bit (cdecl/stdcall)** | Arguments on the stack | Result in ST(0) | FPU stack must be empty after return |
| **64-bit (SysV/Windows)** | Arguments via XMM0â€“XMM7 | Result in XMM0 | FPU not used |
| **Kernel / ISRs** | â€” | â€” | FPU usage discouraged unless context saved |

---

## 9. Performance and Optimization

| Factor | Impact |
|---------|---------|
| Extended precision (80-bit) | High accuracy, slower speed |
| int â†” float conversions | Expensive |
| `FXCH` | Executes instantly (0 cycles) |
| FPU memory access | Slower than register-only ops |
| No unsigned int support | Requires software workaround |
| Superseded by SSE/AVX | Modern CPUs use SIMD for FP math |

**Optimization Tips:**
- Avoid unnecessary conversions and memory transfers.
- Track stack depth carefully â€” avoid overflow or leaks.
- Use `FXCH` for register reordering without cost.
- Keep hot loops in registers when possible.

---

## 10. Timing with `RDTSC` and `RDTSCP`

| Instruction | Description |
|--------------|--------------|
| `RDTSC` | Reads the 64-bit Time Stamp Counter (EDX:EAX). |
| `RDTSCP` | Same as RDTSC but includes serialization and core ID (ECX). |

**Purpose:** High-resolution timing and benchmarking.

**Details:**
- The TSC increments at the CPU base frequency.
- Independent of OS and timers.
- Synchronized across cores on modern CPUs.

**Usage Example:**
```asm
rdtscp
shl rdx, 32
or rax, rdx      ; combine EDX:EAX into 64-bit value
```

**Best Practices:**
- Measure intervals â‰¥ 1 ms for accuracy.
- Run on AC power (stable frequency).
- Avoid console output inside timing loops.
- Disable TurboBoost or power scaling for consistency.

---

## 11. Modern Alternatives

| Technology | Replaces FPU | Key Features |
|-------------|---------------|---------------|
| **SSE (Streaming SIMD Extensions)** | Yes | 128-bit registers, faster scalar ops |
| **AVX / AVX2 / AVX-512** | Yes | 256â€“512-bit vectorized operations |
| **FMA (Fused Multiply-Add)** | Partial | Faster combined multiply-add |
| **GPU Floating Units** | Yes | Highly parallel FP computation |

**Conclusion:** x87 remains for backward compatibility and educational use.  
Modern compilers use SSE/AVX for nearly all floating-point math.

---

## 12. Key Takeaways

- FPU is an 8-register stack-based floating-point unit.  
- All operations go through ST(0) and often via memory.  
- Internal precision is 80-bit extended.  
- Exceptions are masked by default.  
- RDTSCP is the preferred method for accurate CPU timing.  
- Modern floating-point workloads use SIMD (SSE/AVX).  
- Understanding x87 helps grasp CPU design and floating-point fundamentals.
