# ğŸ§  Lecture Notes â€” Memory Allocation, x86 Evolution, and 64-bit Architecture

## 1. Stack and Lazy Memory Allocation

### ğŸ§© Key Concepts

| Concept | Description |
|----------|--------------|
| **Stack memory** | Memory reserved for function calls, local variables, and control flow. |
| **Virtual vs. Physical allocation** | The OS **reserves address space**, but physical pages are **allocated on demand**. |
| **Guard page** | A special page at the end of stack space. Accessing it triggers a **page fault** that signals the OS to expand the stack. |
| **Page fault expansion** | When program accesses an address just below the current guard page, OS allocates a new physical page and moves the guard one page lower. |

### âš ï¸ Important Behavior
| Action | Effect |
|---------|---------|
| Access within one page below current stack | OS allocates a new page (normal growth). |
| Jump down too far (e.g., `ESP - 10KB`) | You **skip** the guard page â†’ no page fault â†’ **program crash**. |

### ğŸ§  Rule of Thumb
When manually expanding stack memory (e.g., during recursion or coroutines):
- Touch each page sequentially (read or write one byte per 4 KB step).
- Ensures guard page detection triggers correct allocation.

---

## 2. Transition from 16-bit â†’ 32-bit â†’ 64-bit

### Historical Context

| Era | Architecture | Characteristics | Notes |
|------|---------------|------------------|-------|
| Early x86 | **16-bit** | Segment:offset addressing (complex) | Limited, hard to program |
| 80386 (1985) | **32-bit (IA-32)** | Flat memory, 4 GB address space | Huge simplification |
| AMD64 (2003) | **64-bit extension of x86** | Backward compatible | Standard today |
| Intel Itanium (IA-64)** | Fully new 64-bit ISA | Incompatible with x86 | Commercial failure |

### Why 64-bit?
| Reason | Explanation |
|--------|--------------|
| Address space limit | 32-bit pointer = max 4 GB addressable memory |
| OS reservation | Typically, 2 GB user / 2 GB kernel space |
| Scalability | Needed for large memory systems and modern workloads |

ğŸ§© **Real addressing width**:  
Only **48 bits** used for addresses â†’ pointers still 64-bit (for future expansion).

---

## 3. AMD64 vs. Intel IA-64

| Feature | AMD64 (x86-64) | Itanium (IA-64) |
|----------|----------------|-----------------|
| Compatibility | Fully backward with x86 | None |
| Design | Extension of x86 | Completely new |
| Performance | Efficient, reused existing code | Poor x86 emulation |
| Adoption | Universal (Windows, Linux, macOS) | Discontinued |
| Introduced by | AMD | Intel |
| Later name | x86-64 / x64 | â€” |

ğŸ’¡ **Result:** Intel eventually adopted AMD64.  
The world standardized on **x86-64**, not IA-64.

---

## 4. Patent Cross-Licensing

| Fact | Explanation |
|------|--------------|
| x86 is patent-locked | Both Intel and AMD hold crucial patents. |
| Mutual dependency | If either revoked rights, neither could legally make x86 CPUs. |
| Outcome | Cooperation through cross-licensing â†’ both produce x86-64 CPUs. |

---

## 5. Register Model Evolution

### Register Hierarchy

| 8-bit | 16-bit | 32-bit | 64-bit | Notes |
|--------|---------|---------|---------|-------|
| AL | AX | EAX | RAX | Accumulator |
| BL | BX | EBX | RBX | Base |
| CL | CX | ECX | RCX | Counter |
| DL | DX | EDX | RDX | Data |
| AH, BH, CH, DH | â€” | â€” | â€” | High 8-bit halves of 16-bit regs |
| â€” | BP, SP, SI, DI | EBP, ESP, ESI, EDI | RBP, RSP, RSI, RDI | Base/Stack/Source/Dest pointers |

### 64-bit Extensions
| Feature | Description |
|----------|--------------|
| New GPRs | R8â€“R15 (+subregisters R8D/W/B, etc.) |
| Access rule | Cannot mix AH/BH/CH/DH with new R8Bâ€“R15B due to encoding overlap |
| Zero-extension | Writing to 32-bit subregister (e.g. `EAX`) zeroes upper 32 bits of RAX |
| Partial writes | Writing to 16/8-bit parts does **not** clear upper bits |

---

## 6. Prefixes and Instruction Encoding

| Prefix | Meaning | Applies To |
|---------|----------|------------|
| 0x66 | Operand-size override (switch 16 â†” 32) | Data width |
| 0x67 | Address-size override | Addressing |
| REX | 64-bit extension prefix (0x40â€“0x4F) | Enables R8â€“R15, 64-bit ops |

ğŸ§© Prefixes affect **one instruction only**.  
They change interpretation, not CPU mode.

---

## 7. Addressing in 64-bit Mode

### General Addressing Form
```
[base + index * scale + displacement]
scale = 1, 2, 4, or 8
```

| Element | Description |
|----------|--------------|
| `base` | Any GPR except RSP (special role) |
| `index` | Optional GPR Ã— scale |
| `displacement` | 32-bit signed offset |
| `RIP-relative` | `[RIP + offset32]` allows position-independent code |

### Key Details

| Behavior | Explanation |
|-----------|-------------|
| Constants are 32-bit signed | Except `mov r64, imm64` |
| No 64-bit immediates in general | Only `mov reg64, imm64` and `mov acc, [imm64]` |
| RIP-relative addressing | Preferred for accessing nearby constants or globals |
| Absolute addressing | Disfavored in 64-bit due to relocation complexity |

Example (correct 64-bit label addressing):
```asm
default rel
lea rax, [label]
```

---

## 8. Removed or Deprecated Instructions

| Group | Example | Reason / Notes |
|--------|----------|----------------|
| BCD arithmetic | `AAA`, `AAM`, `DAS` | For binary-coded decimal â€” obsolete |
| Bound checks | `BOUND`, `INTO` | Never used in modern compilers |
| Misc undocumented | `SALC` | Rare, undocumented behavior |
| Push/pop all | `PUSHA`, `POPA` | Replaced by explicit register saves |
| Far jumps/calls | `JMP FAR`, `CALL FAR` | Dropped from long mode |
| System calls | `SYSENTER` / `SYSEXIT` | Intelâ€™s 32-bit fastcall pair â€” replaced by AMDâ€™s |

### System Call Mechanisms
| Command | Source | 32-bit | 64-bit | Purpose |
|----------|----------|---------|---------|----------|
| `int 0x80` | Legacy interrupt | âœ… | ğŸš« | Slow; hardware interrupt |
| `sysenter` / `sysexit` | Intel | âœ… | âš ï¸ (deprecated) | Faster kernel switch |
| `syscall` / `sysret` | AMD | âœ… | âœ… | Universal in 64-bit OSes |

---

## 9. Instruction Behavior Notes

| Topic | Explanation |
|--------|--------------|
| **NOP (0x90)** | Historically `XCHG EAX, EAX`; in 64-bit still works but treated as true NOP. |
| **XOR EAX, EAX** | Shorter and faster than `XOR RAX, RAX`; clears full RAX. |
| **INT3 (0xCC)** | Breakpoint filler for debugging. |
| **UD2** | Explicitly invalid instruction used for â€œunreachableâ€ code. |
| **Padding** | NOP used for alignments, `INT3` for padding between functions. |

---

## 10. Calling Conventions (64-bit)

### ğŸªŸ Windows x64 (fastcall64)

| Aspect | Details |
|--------|----------|
| **Argument registers** | RCX, RDX, R8, R9 *(integers)* or XMM0â€“3 *(floats)* |
| **Mixing** | For mixed types: e.g., int â†’ RCX, float â†’ XMM1 |
| **Return value** | RAX or XMM0 |
| **Callee-saved regs** | RBX, RBP, RSI, RDI, R12â€“R15, XMM6â€“15 |
| **Stack alignment** | 16 bytes (RSP mod 16 = 8 inside functions) |
| **Shadow space** | 32 bytes reserved by caller for calleeâ€™s register args |
| **Varargs** | Shadow space simplifies argument spilling |
| **Stack granularity** | 8 bytes per slot |
| **Symbol names** | No leading underscores in 64-bit mode |

#### ğŸ§© Shadow Space Layout

```
High addresses
---------------------------
arg5+
arg4
[ Shadow Space (32 bytes) ]
Return address
...
Low addresses
```

---

### ğŸ§ System V AMD64 (Linux / macOS / BSD)

| Aspect | Details |
|--------|----------|
| **Arg registers** | RDI, RSI, RDX, RCX, R8, R9 (int/pointers) |
| **Float args** | XMM0â€“XMM7 (floats/doubles) |
| **Return value** | RAX, XMM0â€“1 |
| **Callee-saved** | RBX, RBP, R12â€“R15 |
| **Stack alignment** | 16 bytes before `call` |
| **Red Zone** | 128 bytes below RSP safe for locals (not clobbered) |
| **Varargs** | RAX holds count of XMM registers used |
| **Order** | Int and float registers used independently (not mutually exclusive) |

#### ğŸ§© Red Zone Diagram

```
(High addresses)
â†‘
+---------------------------+
| Return address            |
| Local variables (â‰¤128 B)  | â† Safe "Red Zone"
| (below current RSP)       |
+---------------------------+
â†“
(Low addresses)
```

---

## 11. Stack Alignment Rules

| Context | Requirement | Reason |
|----------|-------------|--------|
| Before `call` | RSP % 16 = 0 | ABI requirement |
| On function entry | RSP % 16 = 8 | Because `call` pushes 8-byte return address |
| Misalignment risk | SIMD (XMM) instructions may crash or slow down |
| Stack adjustment | Usually via `sub rsp, N` / `add rsp, N` |

---

## 12. Function Return and Data Handling

| Type | Returned In | Notes |
|-------|--------------|--------|
| Integer / pointer | RAX | |
| Floating point | XMM0 | |
| Complex / large struct | May use XMM1 or memory pointer | Implementation dependent |
| Large objects | Pointer to caller-allocated space passed as hidden first argument |

---

## 13. System V vs Windows Comparison

| Feature | Windows x64 | System V AMD64 |
|----------|--------------|----------------|
| Int arg regs | RCX, RDX, R8, R9 | RDI, RSI, RDX, RCX, R8, R9 |
| Float arg regs | XMM0â€“3 | XMM0â€“7 |
| Shadow Space | âœ… (32 B fixed) | âŒ |
| Red Zone | âŒ | âœ… (128 B) |
| Varargs mechanism | Shadow spill | RAX = XMM count |
| Callee-saved | RBX, RBP, RSI, RDI, R12â€“R15 | RBX, RBP, R12â€“R15 |
| Stack align | 16 B (RSP mod 16 = 8 inside) | 16 B |
| ABI users | Windows | Linux, macOS, BSD |

---

## 14. Miscellaneous Notes

| Topic | Detail |
|--------|--------|
| **Pointer null zone** | OSes avoid mapping near 0 to catch null pointer errors. |
| **User/kernel address split** | Typically 2 GB user / 2 GB kernel on 32-bit systems. |
| **Stack growth** | Downward; allocations in 4 KB pages. |
| **Compatibility** | 16- and 32-bit modes preserved for legacy code. |
| **Prefix safety** | Unused prefixes on unsupported instructions are ignored. |

---

## 15. Practical Examples

### Writing Zero Efficiently
```asm
xor eax, eax   ; Clears RAX entirely, shorter & faster
```

### 64-bit Constant Move
```asm
mov rax, 0x1122334455667788 ; Only mov supports full 64-bit immediates
```

### RIP-relative Access
```asm
default rel
lea rax, [my_label]
```

### Stack Frame Alignment Example
```asm
sub rsp, 40    ; 32 for shadow space + 8 for alignment
call my_func
add rsp, 40
```

---

## 16. Summary Table â€” 32-bit vs 64-bit

| Feature | 32-bit | 64-bit |
|----------|---------|---------|
| Address space | 4 GB | 16 EB (48 bits used) |
| Pointer size | 4 B | 8 B |
| General registers | 8 | 16 |
| Syscall interface | `sysenter/sysexit` | `syscall/sysret` |
| Max immediate constant | 32-bit | 64-bit only in `mov` |
| Calling conventions | Multiple | Unified per OS |
| Stack alignment | 4 B | 16 B |
| OS split | ~2 GB / 2 GB | OS-defined |
| Guard page | Yes | Yes |
| Red Zone | No | SysV only |
| Shadow Space | No | Windows only |

---


# âœ… End of Lecture Summary

## ğŸ§© Conceptual Overview

The 64-bit x86 world (AMD64 / x86-64) represents **evolution, not revolution**.  
The core ideas of x86 stayed intact â€” the same instruction semantics, the same backward compatibility, and only careful, minimal extensions to avoid breaking billions of lines of existing software.

### 1. Evolution, Not Reinvention
- The **16â†’32-bit jump** was radical â€” new registers, flat addressing, totally new model.  
- The **32â†’64-bit jump** was conservative: AMD extended rather than redesigned x86.  
- This deliberate conservatism preserved compatibility but left behind some legacy inconsistencies.

### 2. AMDâ€™s Strategic Victory
- Intelâ€™s **IA-64 / Itanium** failed because it was incompatible, expensive, and late.  
- AMDâ€™s **AMD64** succeeded by providing:
  - Full backward compatibility with 32-bit x86.
  - A smooth migration path for OSes and applications.
  - Competitive performance (Athlon 64 integrated memory controller â†’ huge speed boost).  
- Intel eventually adopted AMDâ€™s approach; AMD64 became **x86-64**, the global standard.

### 3. Why Only 48 Bits of Addressing?
- Physical and virtual memory implementations lag behind 64-bit theoretical maximum.
- 48-bit addressing is enough for the foreseeable future, and CPUs can be extended later without breaking code.
- The unused high bits must mirror bit 47 (sign-extension), maintaining canonical address form.

### 4. Lazy Memory Allocation in Practice
- Modern OSes allocate **virtual stack regions** lazily, page by page.
- Accessing a guard page expands the stack one page downward.
- If you â€œjumpâ€ too far down the stack, the OS canâ€™t detect it â†’ segmentation fault.
- Practical takeaway: when expanding the stack manually, **touch each page** sequentially (every 4KB).

### 5. Instruction Encoding and Register Nuances
- The same machine code may be interpreted differently depending on mode (16/32/64-bit).
- Prefixes (`0x66`, `0x67`, REX) are the mechanism for extending interpretation.
- The **REX prefix** enables 64-bit operands and extra registers but disables access to old AH/BH/CH/DH â€” a historical encoding quirk.

### 6. Compiler Habits and Micro-optimizations
- Compilers often use 32-bit instructions (`EAX`, `ECX`, etc.) in 64-bit code since writing to a 32-bit subregister automatically clears the upper bits, producing the same effect with smaller code size.
- Example: `xor eax, eax` is preferred over `xor rax, rax` for zeroing a register.
- Legacy encodings like `xchg eax, eax` (NOP) are preserved for backward compatibility even though they have special-cased hardware logic.

### 7. Practical ABI Observations
- **Windows ABI**: designed for simplicity and performance but includes questionable choices (e.g., saving XMM6â€“15).  
  The â€œshadow spaceâ€ is a clever trick to unify fixed and variable arguments efficiently.  
- **System V ABI**: more flexible, cleaner for cross-platform code, supports 8 vector registers for arguments, and adds the **Red Zone** optimization (128 bytes below RSP).

### 8. Memory Layout and Safety Mechanisms
- OSes reserve **low address space** (around 0) to catch null pointer dereferences.  
  Historically, it was possible to map memory at address 0, but compilers assume null = invalid, so this is discouraged.
- **Guard pages** prevent runaway stack expansion and help the OS manage lazy allocation.
- **Red Zone (SysV)** enables leaf functions to skip stack adjustment entirely if they use â‰¤128 bytes of local data.

### 9. Removed Instructions and Historical Cleanup
- The 64-bit mode â€œpurgedâ€ ancient instructions like `AAA`, `AAS`, `AAM`, `DAS`, `BOUND`, and `SALC`.  
  These were vestiges of the 8080/8086 era and had no modern use.
- AMDâ€™s engineers intentionally reused those opcode slots for future expansion.
- Certain instructions (`sysenter`, `sysexit`) were Intelâ€™s 32-bit kernel transitions; replaced by AMDâ€™s more flexible `syscall` / `sysret`, now universal.

### 10. Common Pitfalls
| Mistake | Consequence |
|----------|--------------|
| Forgetting to maintain 16-byte stack alignment | Crashes in SIMD or system calls |
| Skipping shadow space on Windows | Function may corrupt callerâ€™s stack |
| Using AH with R8B | Illegal instruction encoding |
| Jumping beyond guard page | Stack expansion fails â†’ program crash |
| Assuming 64-bit constants in all ops | Most immediates limited to 32 bits |

### 11. Architecture Philosophy
The AMD64 design reflects the philosophy of **continuity with pragmatism**:  
keep the enormous legacy base working while enabling the future.  
Unlike IA-64, which sought architectural â€œpurityâ€, AMDâ€™s extension embraced â€œugly but effectiveâ€ engineering â€” ensuring adoption by practicality.

### 12. Key Takeaways
| Theme | Summary |
|--------|----------|
| Compatibility | 64-bit mode maintains full 32-bit and 16-bit support. |
| Incremental design | Extensions via prefixes, not redefinitions. |
| Performance | Simplified addressing and more registers improve efficiency. |
| OS Collaboration | Memory and ABI designs reflect how kernels and user-space coordinate. |
| Legacy baggage | Old instructions and encodings still influence new behavior. |

### 13. Practical Advice (from lecturer commentary)
- **Understand prefixes and encoding** â€” they explain why some instruction combinations â€œdonâ€™t work.â€  
- **Always check ABI docs** for your platform â€” calling conventions differ subtly.  
- **Never ignore stack alignment**; SIMD code depends on it.  
- **Donâ€™t over-optimize manually** â€” compilers already know which form (`EAX` vs `RAX`) is optimal.  
- **Study historical architecture decisions** â€” they explain modern quirks better than any manual.

### 14. Final Thought
> â€œYouâ€™re lucky you didnâ€™t have to program in the 16-bit world. That was real pain.  
>  32 bits was salvation.  
>  64 bits â€” itâ€™s just maturity.â€

---

**In summary:** the move to 64-bit x86 is a triumph of *engineering continuity*. It cleaned up decades of cruft, expanded addressability, and standardized calling conventions, all without abandoning the foundation of the worldâ€™s most widely used architecture.

