WEBVTT

00:00.000 --> 00:02.700
Да, и где у вас, смотрите, какая ситуация?

00:02.780 --> 00:06.000
Вот у вас есть исполнительный...

00:06.000 --> 00:10.140
Я его буду называть изэшный в любом случае, чтобы просто как-то его называть.

00:13.460 --> 00:15.020
Есть какие-то дайлапки.

00:23.840 --> 00:26.740
У вас есть абсолютно у всех,

00:26.740 --> 00:30.600
может быть, таблица импорта,

00:32.920 --> 00:36.520
их может быть несколько таблиц импорта,

00:36.740 --> 00:38.380
и может быть таблица экспорта.

00:38.880 --> 00:42.520
Таблица экспорта даже может быть у исполняемого файла, но это нетипично.

00:43.360 --> 00:44.880
Нетипично, но не запрещено.

00:44.980 --> 00:48.580
Я видел такие исполняемые файлы, у которых были таблицы экспорта,

00:48.640 --> 00:49.760
они там что-то экспортировали.

00:51.640 --> 00:52.360
Вот.

00:52.640 --> 00:55.700
У этих, то есть это импорт,

00:56.500 --> 00:56.720
импорт,

00:56.740 --> 00:57.200
импорт,

00:57.200 --> 01:00.980
это будет у нас A-DLL,

01:01.120 --> 01:02.160
это будет B-DLL.

01:02.460 --> 01:04.740
Это импорт из A-DLL.

01:06.380 --> 01:08.300
Это импорт из B-DLL.

01:11.020 --> 01:12.520
Соответственно, вот оно

01:12.520 --> 01:14.900
ссылается сюда, сюда,

01:15.260 --> 01:16.740
и здесь есть какие-то

01:17.320 --> 01:18.300
функции,

01:18.620 --> 01:20.880
или там данные, которые мы импортируем.

01:22.860 --> 01:24.740
Здесь есть таблица экспорта.

01:26.740 --> 01:30.560
Экспорта, ну да, ну там, фу, у нас вот здесь.

01:32.900 --> 01:34.320
А здесь у них у нас есть B-A.

01:38.460 --> 01:42.780
Да, здесь у нас обращение к B-A.

01:44.400 --> 01:48.840
Притом, здесь у вас тоже может быть таблица импорта

01:48.840 --> 01:52.840
из B-DLL,

01:52.840 --> 01:56.700
которая импортирует B-A,

01:56.740 --> 01:58.740
ну, тоже обращается сюда.

01:58.740 --> 02:00.740
Вот такая картинка.

02:02.740 --> 02:06.740
То есть, везде есть набор таблиц импорта

02:06.740 --> 02:10.740
и, возможно, таблица экспорта.

02:10.740 --> 02:12.740
Таблица экспорта необязательна,

02:12.740 --> 02:14.740
в принципе, импорт тоже необязателен.

02:14.740 --> 02:17.740
Вы можете сказать, что мы исполняем EFL,

02:17.740 --> 02:19.740
ни от каких библиотек не зависит.

02:22.740 --> 02:25.740
Так тоже можно, хотя это не значит, что

02:25.740 --> 02:27.740
в памяти не будет никаких библиотек.

02:27.740 --> 02:33.740
Потому что под виндоль в старт процесса в юверспейсе

02:33.740 --> 02:36.740
начинается с библиотеки nt-dll-dll,

02:36.740 --> 02:39.740
и зависите вы от нее, не зависите вы от нее,

02:39.740 --> 02:41.740
старт происходит все равно оттуда,

02:41.740 --> 02:46.740
и она уже вызывает точку входа в ваш исполняемый файл.

02:46.740 --> 02:48.740
Поэтому даже если вы говорите,

02:48.740 --> 02:50.740
что вы ни от кого не зависите,

02:50.740 --> 02:53.740
nt-dll-dll вы все равно получите.

02:53.740 --> 02:55.740
Да.

02:55.740 --> 02:58.740
А если в нашем экзешнике, допустим,

02:58.740 --> 03:00.740
будет функция foo,

03:00.740 --> 03:03.740
и в какой-то таблице импорта тоже это будет функция foo,

03:03.740 --> 03:05.740
то это ошибка линкера?

03:05.740 --> 03:07.740
Да.

03:07.740 --> 03:09.740
У тебя оно не слинкуется,

03:09.740 --> 03:11.740
потому что, смотри, откуда берется

03:11.740 --> 03:13.740
вот эта самая таблица импорта?

03:13.740 --> 03:16.740
Таблица импорта берется в результате того,

03:16.740 --> 03:22.740
что ты линкеру даешь специального вида библиотеку,

03:22.740 --> 03:25.740
так называемая библиотека импорта.

03:25.740 --> 03:30.740
Которая содержит не реализацию функций,

03:30.740 --> 03:35.740
а указание, что эта функция реализована в dll-ке

03:35.740 --> 03:37.740
с именем adll.

03:37.740 --> 03:43.740
То есть это для линкера является реализацией символа.

03:43.740 --> 03:49.740
Поэтому если у тебя уже где-то было свое foo,

03:49.740 --> 03:54.740
то линкер не будет пытаться искать это foo.

03:55.740 --> 03:58.740
Если же он по каким-то причинам нашел его,

03:58.740 --> 04:01.740
а потом увидел, что у тебя есть foo,

04:01.740 --> 04:04.740
то это будет mild definition, и оно не слинкуется.

04:08.740 --> 04:11.740
Ну, понятное дело, имеется такое foo, которое глобально видимо.

04:11.740 --> 04:13.740
Если ты какой-то там static foo разведешь,

04:13.740 --> 04:15.740
то об этом никто никогда не узнает,

04:15.740 --> 04:18.740
но то он и static, что его снаружи не видно.

04:18.740 --> 04:20.740
Понятно, да?

04:22.740 --> 04:23.740
Вот.

04:23.740 --> 04:28.740
В чем отличие в линуксе?

04:28.740 --> 04:36.740
В линуксе у вас есть вот такая общая таблица,

04:36.740 --> 04:39.740
что вы там импортируете.

04:39.740 --> 04:44.740
И оно не привязано к какой-то конкретной библиотеке.

04:44.740 --> 04:49.740
Оно импортирует это просто из окружающего пространства.

04:49.740 --> 04:52.740
И правила импорта из окружающего пространства

04:52.740 --> 04:55.740
похожи на работу линкера.

04:57.740 --> 04:59.740
То есть окружающее пространство означает

04:59.740 --> 05:04.740
вначале посмотри на экспорт хз,

05:04.740 --> 05:08.740
потом посмотри на экспорт тех библиотек,

05:08.740 --> 05:13.740
которые указаны в самом хз, в списке библиотек.

05:13.740 --> 05:16.740
Потом посмотри на экспорт тех библиотек,

05:16.740 --> 05:21.740
которые указаны как зависимые в библиотеках 1 уровня.

05:21.740 --> 05:30.380
то есть такой многоуровневый список и в порядке просмотра удачи тебе найти символ с таким именем

05:30.380 --> 05:41.000
найдешь хорошо и найдешь плохо но у меня нет идей где этот символ может находиться может даже во мне

05:41.000 --> 05:47.360
но это не важно то есть даже если у вас вот здесь вот этот символ прям вот в этой же библиотеке

05:47.360 --> 05:56.300
определён это не волнует потому что правило поиска нет сначала в себе а потом в пространстве

05:56.300 --> 06:11.840
а как будто мы запускаем статический линкер соответственно еще раз вся эта картина она

06:11.840 --> 06:15.200
дико медленно

06:17.360 --> 06:27.740
это является достаточной проблемой что по этому поводу изобрели штуку под названием плт

06:27.740 --> 06:44.900
как она шифровывается да это в принципе очень смахивает на те заглушки которые я вам говорил

06:44.900 --> 06:47.300
будут винтой если вы не скажете

06:47.360 --> 06:57.700
длл импорт для функций под линуксом на самом деле тоже обычно у вас вот здесь вот

06:57.700 --> 07:12.780
внутри функции bar как будет вызов функции фу происходить он будет у вас вида кол имя

07:12.780 --> 07:17.300
но это не

07:17.360 --> 07:31.580
так важно смотрите кол имя о чем это говорит о том что это вызов по какому-то константному

07:31.580 --> 07:47.340
адресу это не вызов того не знаю кого чтобы был вызов того не знаю кого вы заблудились вот так по

07:47.360 --> 07:48.360
понятно да

07:48.360 --> 07:59.480
ну тебе понятно понятно не считаешься я про окружающие понятно

07:59.480 --> 08:06.480
соответственно раз мы прикидываемся что динамические библиотеки максимально похожи

08:06.480 --> 08:16.800
на как будто анистетические то вот функция bar она ампулируется вот так ну да она по своему это

08:17.360 --> 08:30.240
даже называется и вот внутри этого плт вас пытается заглушка которая в простом

08:30.240 --> 08:33.320
виде аналогичная потому что происходит под

08:33.320 --> 08:39.760
винду и когда вы не угадали не указали белый то есть там будет происходить джан

08:39.760 --> 08:52.260
на вот вот это фу которая внутри год не только называется может поиск вот ну

08:52.260 --> 08:58.580
здесь нет этих типов которые под линдой такое четкое имя я не уверен как-то там

08:58.580 --> 09:04.800
по-разному пишется назовем его вот так

09:07.520 --> 09:09.520
что

09:09.760 --> 09:20.120
история вот пока без что происходит просто с библиотеками я просто потому

09:20.120 --> 09:27.940
что год он один на сошли или один на один на каждый файл у каждого файла свой

09:27.940 --> 09:31.520
год потому что они в разные места могут

09:31.520 --> 09:39.160
загружаться нет потому что у тебя прямые обращения обращение адрес этот

09:39.160 --> 09:39.520
адрес

09:39.520 --> 09:39.760
фиксируется

09:39.760 --> 09:45.760
То есть значение, которое лежит внутри ГО, оно вправляется загрузчиком.

09:47.140 --> 09:53.760
А вот адрес этого самого ГО, адрес таблички, он фиксированный внутри и МЗшника, и библиотеки.

09:55.980 --> 09:58.800
Так вот, это такая простая история.

09:59.580 --> 10:02.860
Но эта простая история народу под минуту не очень нравилась.

10:03.020 --> 10:08.620
Почему? Потому что, еще раз вспомните размеры вот этих табличек импорта и экспорта.

10:08.620 --> 10:12.840
У вас буквально все экспортируется и все импортируется.

10:13.740 --> 10:21.540
Поэтому, чтобы зарезолвить вот эти все импорты, нужно дофига времени, потому что вам нужно кучу всего резолвить.

10:22.400 --> 10:26.620
И куча из этого, скорее всего, вообще даже не потребуется в время жизни программы,

10:27.740 --> 10:30.700
потому что до этой ветки кода просто не дойдет.

10:32.360 --> 10:36.180
Поэтому народ изобрел следующую фигню.

10:38.620 --> 10:41.820
Здесь происходит вот так вот.

10:43.640 --> 10:51.620
Но вот этот ГОД, он исходно указывает...

10:52.420 --> 10:53.560
Ой, я не знаю, как это назвать.

10:57.560 --> 11:00.560
Я назову это...

11:02.560 --> 11:05.560
ВУЭТ...

11:06.460 --> 11:08.560
ПЭТ...

11:08.620 --> 11:09.620
ЭЛ...

11:09.620 --> 11:10.620
ТЭ...

11:10.620 --> 11:11.620
ДВА.

11:11.620 --> 11:13.620
ПОДПИШИТЕСЬ НА КАНАЛ!

