Detecting language using up to the first 30 seconds. Use `--language` to specify the language
Detected language: Russian
То есть какая-то форма существует, а какой-то формы нет.
То есть народ, который проектировал, они так аккуратненько выбирали варианты,
вот какие практически нужны, какие сделают.
А какие особой необходимости нет, просто ради симметрии систему команд делать не будет.
То есть это такая не полностью симметричная система команд,
а сделанная в режиме сэкономика.
И Кальмомери на самом деле довольно мощно.
А именно, MMX оперирует восемью почти новыми регистрами,
которые называются MM0 по MM7.
И это 64 бит.
64 битные регистры.
Я вам сказал, почти новые.
Кто может догадаться, что это на самом деле не новые регистры?
XAML, XAML, FPU?
Нет, XAML никаких нет.
То есть это старые переименованные регистры?
А что за регистры?
FPU может.
Единственные крупные регистры, которые у нас были,
вообще это расширение каких времен?
Первый Pentium.
Первый Pentium, он был просто Pentium.
У него была еще версия Pentium MMX.
Это Pentium плюс MMX.
Вот тогда так все просто называлось.
Так вот, регистры у первого Pentium были 32-разрядные.
Это был совершенно в дотку 32-битный процессор.
И 8 64-битных регистров Intel показались, ну, как-то жирно.
Жалко столько места на кристалле выделять.
Поэтому вот эти регистры отдали мальтисты регистров FPU.
Регистры FPU, как вы помните, сколько битные?
80-битные.
И эти 80-битные состоят...
закодированы как Extended Precision.
То есть старший битик — знак,
потом 15 битиков — экспоненты,
а потом 64 битика — мальтисты.
Вот эти младшие 64 битика — мальтисты,
их...
теперь можно...
к ним можно обратиться по имени MM.
Но, в отличие от регистров сопроцессора,
здесь у вас прямая анализация.
То есть никакой не стэк, не стэкпоинтер, не пушпоп.
Здесь прямое название.
MM0 — это всегда MM0.
Но, в связи с тем, что это на самом деле те же самые регистры,
когда вы делаете почти любую команду MMX,
все регистры сопроцессора помечаются как занятые.
Поэтому использовать одновременно MMX и FPU крайне затруднительно.
Ну, в том плане, что FPU будет мгновенно проигрывать,
как только вы сделаете что-то на MMX.
И проигрывать даже не столько, что там будет теряться результат,
без необходимости ничего писаться не будет,
но у вас тут же все будет помечено как занятое,
со всеми вытекающими последствиями.
Поэтому флаги занятости FPU MMX не интересуют.
То есть если у вас там уже что-то было на FPU в регистрах,
это никак вам не мешает что-то в одном регистре записать.
Вы даже не узнаете, что там что-то было.
Поэтому MMX вот так доминирует над FPU,
и еще раз вместе их использовать крайне затруднительно.
MM регистры, они не про floating-point?
Еще раз, физически это младшие 64 бита того,
что называлось R0 по R7.
Просто R0 по R7 таких имен не было.
Они вам были доступны в виде стека, как ST0 по ST7.
А здесь у вас прямая адресация, не стек.
То есть младшая часть R0 это MM0.
Младшая часть R7 это MM7.
Понятно?
Да.
Следующее.
MMX это целиком целочисленное расширение.
То есть все команды, которые относятся к MMX,
это все команды по работе с целыми числами.
Не про плавающую точку.
Там будут дальше другие расширения,
там появятся и аналогичные плавающие точки.
Но MMX только целочисленное расширение.
И на самом деле всякое видео, как правило, считается в целых числах.
Более конкретно, фиксированные точки.
Если вы что-то помните из какой-то архитектуры,
фиксированная точка используется весьма широко.
Например, видео обычно считается в фиксированной точке,
потому что фиксированная точка считается со скоростью целых чисел,
что существенно быстрее, чем считать плавающую точку.
А точности плавающей точки для видео не требуется.
Поэтому нужна скорость.
Высокая точность не нужна.
Собираем фиксированную точку разуме.
А если там какая-то суперграфика?
А что за суперграфика?
Суперграфика, она у тебя на каком уровне?
Если ты говоришь про картинку, которую ты создаешь,
чем ты собираешься эту картинку показывать?
Так, к слову.
Упорно.
Упорно, да.
А какая точность?
Вывод данных в монитор.
Ну, там какое-то количество.
Ну, обычно.
8 бит.
8 бит.
8 бит на канал.
Ну, то есть 3 кусочка по 8 бит, это 8-битные данные.
При том, более дешевые мониторы, они даже вообще 6-битные.
Более крутые мониторы 10-битные.
16-битные потенциально существуют.
Но мне кажется, что я слышал про такое, они, например, медицинские,
а во-вторых, они серые.
То есть там 16-бит, но они киевские.
То есть только у тебя, например, серые, а у тебя есть киевские, вот, медицинские.
Вот.
Поэтому больше 16-бит мониторов я никогда не слышал, что существует.
Я никогда не слышал, что существует.
Подавляющее большинство 8 бит.
Даже 10-битные встречаются не очень часто.
Вот.
Поэтому твою супер-пупер графику можешь, конечно, насчитать.
Но кто ее увидит?
Поэтому для промежуточных вычислений большая точность норм.
Даже нужна.
Если у тебя результат 8-битный, то промежуточной точности 16-бит обычно хватает.
То есть у тебя 8 бит запасной точности.
Поэтому нередко всякое видео и подобное считают вот в промежуточной точности фиксированная точка 16-бит,
а результат получается целое число 8 бит.
.
И NMX оптимизирован вот именно такие вычисления.
То есть вычисления с 8-ю, 16-ю битами точности.
Вот этот вот 64-битный регистр, как он может быть инкарпентирован?
Ну, 8-битный регистр.
В принципе, одно число как 64 бита, ну, редко.
Но потенциально можно сказать, что одно число равняет 64.
Другое дело, что никакой арифметики такого размера у вас не будет.
Мало как его можно интерпретировать как одно число 64-битное.
Некоторыми командами его можно интерпретировать как 2 32-битных часа.
Большинство команд умеет его интерпретировать,
как 4 16-битные порции, и тоже многие команды умеют интерпретировать его как 8 8-битных порций.
Надо рисовать картинки? Понятно.
Теперь, что у нас есть за команды? Ну, во-первых, в команде 3 ссылки.
Есть команда movq, которая пересылает весь ваш регистр.
Аргументы, ну, как в команде mov, вы ожидаете, либо регистр-регистр, либо память-регистр, либо регистр-память.
Обратите внимание, что все это возникло в 3-битном процессе.
Поэтому movq регистр какого-то общего назначения,
типа там какой-нибудь rx.
Нельзя сказать, никакого rx-а не было.
И mov это команда точной битности,
поэтому здесь у вас возможны варианты либо mm-mm, либо память-mm, либо mm-память.
Дальше. Есть команда movd,
которая пересылает 32 бита.
Как она работает?
Она возможна только между mm и nmm.
В качестве nmm может быть как кусок памяти, так и 32-битный регистр.
Если вы пишете в память или в обычный регистр,
то вы просто пишете младшие 32 бита mm регистра, куда бы сказать.
Если вы пишете в mm регистр, то вы пишете целиком весь регистр.
В 32-битом младших то, что вы сказали, старшие обнуляются.
В принципе, эту картину вы уже видели в 64-битах, поэтому не новость.
А вот эти mm регистры появились после 64-битных?
Да.
Но ситуация с тем, что вы пишете младшую часть, старшие обнуляются.
Это вам уже известно.
Потом, есть набор команд всякой паковки-распаковки.
Например, есть команды pack, ss, а дальше бывают dv и vb.
Понятно, что я здесь написал?
Это команды pack, ss, dv и pack, ss, vb.
Как оно работает?
Вот, например, возьмем вариант dv, mm1, mm2.
Эта команда берет...
Это mm2.
Это mm1, младший битик, старший, младший, старший.
Интерпретирует входные регистры, как содержащие двады.
В результате этой команды получатся варды.
То есть, в результате.
В результате.
В результате.
В результате.
В результате.
В результате mm1 будет содержать 4 варда.
В результате.
И паковка происходит следующим образом.
При том, эта команда.
вот это уменьшение видности операции производит sine-saturation.
То есть, если у вас значение целиком уменьшалось в новом типе данных,
скажем, что 3, у вас такая стоимость 3.
Если у вас там было 2 миллиарда,
то у вас что превратилось в 2 миллиарда?
То есть, это команда, которая уменьшает диапазон
производя насыщение
и интерпретируя и входные, и результирующие данные
как значения со знаками.
У вас есть команда, которая упаковывает 2 рды в 2 рды
и которая упаковывает 2 рды в байты.
То есть, вы можете поджать 32 бита до 16,
и 16 бит до 8.
Вот таким образом.
Получается, если байты, то будет 8 порций?
Да, у вас будет 8 порций по 8 бит.
Если вы здесь скажете pack ssbb,
в результате получится 8 байтиков со знаком.
Аналогично, но за прострелочек больше.
Притом, не стоит вам мешать указать дважды один и тот же регистр.
То есть, например, pack ssdb, mm1, mm1
тоже вполне себе справедливо.
Без проблем.
Также есть команда pack svb.
Эта команда производит unsigned situation.
Интерпретируя входные данные как слова со знаком,
а в результате у вас получаются байты без знаков.
И на самом деле, уже одна эта команда
дает огромный природ скорости алгоритмам обработки изображений.
Почему?
Потому что.
Смотрите, я вам сказал, как обычно обрабатываются изображения.
Вы поднимаете промежуточную точность, там бит до 16.
Считаете.
Когда вы результат хотите записать в память, что нужно сделать?
Если вы тупо запишите в память, у вас будут проблемы.
Да.
Если в процессе вычисления у вас получилось 256,
то при записи 256 в память у вас будет 0.
То есть у вас сверхяркая точка превратится в черную.
И наоборот, если у вас получилось минус 1,
сверхчерная точка станет 255 белой.
Что полная фигня.
И такого допустить нельзя.
Как этого не допустить?
В конце ставят IF.
IF у нас было больше 255, то 255.
Если было меньше 0, то 0.
Насколько хорошо процессоры ИФА, я думаю, вы в курсе.
Смотри, что у нас в названии.
Нет.
В процессе вычисления у тебя больше точность.
Обычно у тебя 16-битное число и со знаком.
Когда ты результат пишешь, оно превращается обычно в 8-битное число без знака.
Но вот чтобы правильно со знаком 16-битное записать 8-бит,
тебе нужно выполнить вот это насыщение,
которое на высоком уровне выглядит как два IF.
Вот пока СВБ может прийти в минус 1, мы можем от сайта это прочитать?
Нет.
Еще раз.
Оно делает.
Исходные слова интерпретируются.
А слова со знаком?
Тут слова со знаком, а результирующие байты интерпретируются как байты без знака.
То есть на самом деле она делает ровно то, что ты хочешь, когда ты обрабатываешь картинки.
Да, по-моему, без ИФА это делается.
Да, конечно, это делается без ИФА.
Ну, в плане и реализация самой на железке тоже без ИФА.
Конечно.
Конечно.
Если ты без этого пишешь, то ты пишешь это через два ИФА.
Там можно сравнить и делать сайм-экстеншн.
И так сделать сатурацию.
Ну, я буквально, короче, я недавно таким занимался.
Сколько там команд?
Там была реализация одной инструкции, и там был прикол, что она сделана через селект,
чтобы было преобразовать это без селекта.
И я преобразовывал через сравнение на меньшее один битик, и я делал сайм-экстеншн.
И он как раз-таки, типа, понимал, что это сатурация, потому что если это один,
то у нас сайм-экстеншн всегда единицы.
Ну вот к чему это два как слова?
У тебя есть набор команд x86.
Они тебе известны.
Ну да.
Вот вырази свою мысль через существующие команды.
Вот тебе нужно выполнить действие.
Больше 255 заменить на 255.
Меньше 0 заменить на 0.
И потом вот из слова сделать байтинг.
Сайм-экстеншн.
Да, можно так сделать.
Хотя в то время смог z.
Команды не было.
Смог z появился в Pentium Pro.
А Pentium Pro — это параллельная линейка.
То есть там был Pentium, Pentium MMX и Pentium Pro.
Потом Pentium Pro — это было супердорогое удовольствие.
То есть смог z даже был не вариант.
И на смог тоже не сказать, что прям особенно удобно.
Чтобы делать смог, тебе что нужно сделать?
Две проверки, два смога.
И еще эти результаты, с чем ты смогуешь, тоже нужно где-то хранить.
Что это, два регистра или еще хоть два обращения к памяти?
В любом случае плохо.
Притом здесь, возможно, даже лучше сработают ифы.
Потому что если у тебя основная часть картинки не выходит за границы,
ифы, может быть, даже дешевле будут.
Поэтому смог не факт.
Но в любом случае, эта команда не просто делает это действие супербыстро,
буквально за один такт,
она еще делает восемь таких действий за этот один такт.
То есть даже уже одна эта команда позволяет сильно ускорить обработку изображения.
Это вот демонстрирует.
Это демонстрация того, что набор команд создан под конкретную задачу.
Как вы прям обычно хотите, когда делаете какой-то алгоритм.
Вот такая командочка, скорее всего, есть.
Либо можно через небольшое количество команд выразить вашу мысль.
Это вот такое свойство 3D-микса.
Так, что дальше у нас есть интересного?
Распаковка.
Что за команды распаковки?
Это вот такие команды.
Так, С, В, В.
Сейчас я вам напишу.
А, М, К, Х или Л.
И оно может быть...
В, В.
В, Д.
Д, К, Л.
Шесть команд.
Да, обратите внимание, здесь одну букву сэкономили.
Это У, Н, П, К, К.
А, сэкономили.
П, У, Н, П, К.
П, У, Н, П, К.
Х или Л.
У, Н, П, К.
Да.
Я меня еще спрашиваю.
А, конечно.
Да.
А, М, К.
Что значит первая букву П?
П – это префикс большинства команд MMX, как F был префиксом для их полукоманд.
Кроме мобов и еще одной команды, все команды MMX начинаются с П.
А, должно быть, пишут здесь маленькую комплектацию специально?
Что?
Нет, еще раз.
Я вам говорю, что команды и регистры на сервере – регистры независимые.
Поэтому я даже на скейр напишу смесь дикую.
Это не должно вас пугать.
Это регистры независимые.
Вообще исход на сервере был полностью регистры независимый язык.
Но потом пришли к выводу, что метки следует интерпретировать регистры зависимые.
Исходно даже метки были регистры независимые.
Потому что исходно даже не было разницы между большими и маленькими буквами.
Если совсем так набрать, то первые кодировки символов содержали один набор букв,
который обычно рисовался заглавными буквами.
Поэтому, если вы видели всякие старые книжки, например,
такой старый-старый Си или там Портраун, тоже старенький,
вы могли видеть код, который написан весь капсом.
Почему?
Потому что он не капсом написан, а он написан единственным существующим вариантом букв.
И просто не было различения между большим и маленьким буквами.
Так еще раз, да.
Вот такие старинные языки, которые произошли в те древние времена,
они просто в своем рождении не могли гарантировать вам,
что существует разница больших и маленьких букв.
Тяжко было бы голосовать.
Да, там было довольно тяжко.
И всякие диграфы и триграфы все не на ровном месте возникли.
Потому что гарантировать, что у вас существует символ фигурная скобочка, тоже было нельзя.
То есть у вас просто не было такого символа в наборе ваших символов, которые есть у вас.
Как писать программу на C, когда у вас нет символа фигурная скобочка?
Макросы.
А что макросы?
На что ты взялся выразить макросы?
У тебя нет такого символа.
Никак.
На паскальце.
Нет, я понимаю.
В смысле, можно...
Просто нет.
Это больше страдать, чем писать на паскальце.
Так что если вы почитаете про диграфы и триграфы C, вот они как раз возникли как способ написать программу на C,
даже если в вашей системе не хватает важных символов для языка, вдувающих фигурную скобочку.
Ну, ясен, конечно же, это язык принципиально тех же времен.
Поэтому он в регистре независимый.
Поэтому регистр команд не обращайте на это внимания.
Я пишу как получится на доске.
А когда вы пишете, ну уж пишите консистентно.
Везде одинаково.
Обычно сегодня пишут в нижнем регистре.
Ну, потому что так как-то привычно.
Логические программирования тоже, кстати, ключевые слова обычно пишут в нижнем регистре.
Несмотря на то, что это неважно.
Влияние в ручью языков приводит к тому, что по большей части, а сервер сегодня, вы видите, тоже в нижнем регистре.
Возвращаемся к нашим командам.
Что это делает?
Допустим, возьмем форму ПУНФКХВД.
Тоже ММ1, ММ2.
Как она работает?
У нас исходные регистры.
Интерпретируются как ворды.
То есть 4 ворда на входе.
На выходе у нас в некотором смысле 2 ворды.
Как?
Вот так.
I.
H.
Это про то, что мы берем старшие части входных регистров.
Если L, то стрелочки будут из ваших частей.
Теперь.
В каком смысле это распаковка?
В смысле, если у вас, например, в ММ1 содержатся слова без знака.
А в ММ2 лежит нолик.
То это действительно будет конверсия из вордов в дворды.
Понятно?
Если у вас в ММ1 содержатся слова со знаком.
То вам нужно ММ2 заполнить ноликами в тех позициях.
В тех позициях, где число не отрицательное.
И единичками, где отрицательное.
Это сделать не сложно.
И тогда эта команда сделает вам расширение.
Как значение со знаком.
Но вообще на эти команды следует смотреть.
Как на вот такую хитрую перестановку байтика.
То есть не надо прямо относиться к ней.
Эта команда используется только когда вы делаете конверсию из вордов в дворды.
Нет.
На подобные команды следует смотреть.
Эта команда делает вот такую перестановку байтиков в регистр.
И это действие полезно просто само по себе.
Когда вам нужно переставить данные внутри регистров.
А потребность переставить данные возникает весьма часто.
Поэтому если упаковка это более-менее десертная упаковка.
То распаковка это скорее больше перестановка.
Понятно?
Теперь. Что у нас есть из арифметики?
Из арифметики у нас есть обычное сложение.
Вариантов В, В, Д.
Соответственно оно делает что?
Складывает 8 пар байтиков.
Вот так вот.
4 пары слов.
Либо 2 дворда.
Понятно?
Но кто-то кивает, а кто-то...
Оно не кивает.
Ну вот опять-таки.
ММ1.
ММ2.
Что будет происходить?
Вот у тебя, например, Д.
У тебя 2 дворда.
Это ММ1.
ММ2.
Ты делаешь вот так вот сложение.
Вот старшую часть со старшей складываешь.
Пишешь старшую.
Машу из маши.
Пишешь в машу.
Сложение.
Сложение из баку.
Модулятор.
Как?
Обычное сложение.
Кроме обычного сложения.
У вас есть команда.
П.
А.
Д.
С.
В.
В.
И.
П.
А.
Д.
У.
С.
В.
В.
Суторейшн.
Суторейшн.
Да.
Это команды, которые складывают.
И насыщают.
В случае выхода за границы.
Как число со знаком.
С.
Или как число без знака.
У.
С.
Никак не работают складывания.
И обычное сложение тоже никак складывание не работает.
То есть ваш результат.
Это только значение вашего регистра.
Никаких флагов нигде не ставится.
То есть флагами не связаны.
Обратите внимание, что насыщающие варианты существуют только для байтов и слов.
Для двортов действительно нет такой команды.
И вот это нередко.
То есть вот здесь у вас есть две формы.
Здесь только одна форма.
Здесь все формы.
Здесь только вот такие формы.
И для ммх это очень характерно.
Что у вас не все есть формы.
Потому что они нужны.
Ну не особо нужны.
Аналогично есть формы с вычитанием.
Обычная ПСАВВВ насыщающая ПСАВС насыщающая без знака ПСАВС.
Это только с регистрами, да?
Да.
Важное замечание, что в арифметике вы можете указать либо два регистра, либо регистры памяти.
Варианта указать константу нет.
Даже в мове нет константы.
Если вы хотите загрузить какую-то константу, вам придется эту константу разместить в памяти, а потом из памяти ее загружать.
Либо если ваша константа маленькая, 32 бита умещается, можете записать ее в регистр и регистр переслать через мову D.
Но почти ни в каких командах в ммх нет констант.
А там, где есть константы, это константы, управляющие поведением, а не константы как значение.
В смысле, константы в самой команде, которая указывается?
Как часть команды, да.
Какой-то аргумент у команды.
А почему это не моники, а крокодильный аргумент?
Ну, видишь.
На стороне у нас нет.
Нет.
Ты не хочешь это иметь частью мимоники.
Вообще не хочешь.
Но формальный, а точнее аргумент.
Ну, как сказать?
Когда идем, тогда и увидишь.
Вот почему эти бесполезные разговоры.
А у нас еще не было такого.
Дальше у нас есть умножение.
Умножение существует всего три команды.
По му-л-л-в.
По му-х-в.
И замечательная команда.
Ма-дв-д.
Начнем с простого.
Команда по му-л-л-в.
Догадываетесь ли вы, что она делает?
Лижнее, 32, 5, результат, умножение.
Ну, в на конце намекает, что она работает с вардами.
С 16-ю диким значением.
А л намекает на младшую часть результата.
Поэтому эта команда берет ваше значение, как 16-битное число.
Умножает.
И вы получаете в той же позиции младший 16-битный результат.
Вопрос.
Это умножение знаковое или беззнаковое?
Не важно.
Да, правильный ответ не важен.
Младшая часть результата и для знакового, и для беззнакового умножения совпадают.
Поэтому к му-л-л-л-в вы можете относиться к ней и как к беззнаковому умножению, и как к знаковому.
Как хотите.
А вот к му-л-л-л-х-в, которая дает вам старшую часть результата.
Вот старшая часть, она отличается.
И эта команда дает вам умножение с точки зрения знакового умножения.
То есть эта команда интерпретирует ваши слова, как слова со знаком.
И дает вам старшую часть, старшую половинку полного 13-битного умножения.
Если вы хотите получить полное 13-битное умножение, то вам нужно сделать распаковку.
Помните вот ту хитрую перестановку.
Теперь вы можете на нее посмотреть.
Немножко посреди угла.
И она даст вам ровно то, что нужно.
Потому что умножение дает вам вот такие полуприкаты.
Что делает команда, команда dvd?
Как следует из названия, это некая комбинация умножения и сложения.
Комбинация следующего вида.
Входные регистры интерпретируются, как содержащие слова со знаком.
Вы делаете...
Вот так вот.
Умножение.
Притом умножение вы делаете с полной точностью.
То есть получается 32-битный результат.
Потом результаты этих умножений вот так вот опарно вы складываете.
И в результате два получившихся дворда записываете.
У нас h-ая часть включается.
У нас на выходе два дворда получается.
Да, у тебя на выходе два дворда.
Вот еще раз повторю картинку.
Ты умножаешь 4 пары слов.
Но соседние пары после этого складываешь.
Поэтому у тебя получается 2 результата а не 4.
То есть в каталоге умножение полное.
Да.
Полное умножение.
Вот еще раз.
В промежуточном результате у тебя получится 4 дворда.
Которые ты между собой 2 старших и 2 младших сложишь.
И в результате всей команды у тебя получится 2 дворда.
Ну вот нарисовано.
Я не знаю как лучше нарисовать происходящее.
А как 4 там дворда уменьшаются?
Они на аллоне лежат.
Они в процессе вычисления существуют.
Ваш результирующий дискер будет записан на только 2 дворда.
Она пишет по первым командам передания?
Да.
Как обычные команды.
Первый аргумент это куда мы пишем.
И откуда читаем первое значение.
А второй это откуда читаем второе значение.
То есть здесь ничего особенного нет.
То есть здесь ничего особенного нет.
Может переполнение случиться?
А вот подумай.
На самом деле особенность этой команды, что в ней невозможно переполнение.
Если подумать, аккуратно посчитать варианты, то вы увидите, что переполнение в этой команде нигде не может произойти.
То есть такой незаконный вопрос.
На первый взгляд кажется, а как она обрабатывает переполнение?
Ответ его не бывает.
То, что у нас слова со знаком умножаются.
А потом складываются две пары таких результатов.
Приводит к тому, что результат не может переполнится.
И выйти за двор со знаком.
И никаких других умножений нет.
То есть, например, умножить гвардейс или умножить байты.
Таких команд просто нет.
Что вы думаете про деление?
Его нет.
Никакого вам деления.
В качестве деления, что предлагается использовать?
Tick score.
Tick score.
Сдвиги.
Сдвиги у нас есть.
Что за сдвиги у нас есть?
У нас есть сдвиги логические.
P, S, L, L.
V, D, Q.
P, S, R, L.
V, D, Q.
И P, S, R, A.
V, D.
Вот такие формы сдвигов у нас есть.
Для байтов сдвигов нет?
Да.
К сожалению, для байтов и сдвигов нет.
Это довольно больно.
А где может быть?
То есть, ты решил посчитать среднее арифметическое.
Вот.
Вот такие есть сдвиги.
И, видите, арифметически
кварда не существует.
То есть, вы можете, в принципе,
иногда считать регистр 64-битным числом.
Но это будет не очень число.
Это будет просто набор битиков.
Все битики вы можете подвинуть.
Но как только возникает какая-то арифметика,
максимум борт.
То есть, у вас нет команды сложения квардов
или еще чего-нибудь.
Вся арифметика максимум борт.
Вот. Это сдвиги.
Поэтому, если вам нужно уделение,
то деление вы получаете через фиксированную точку
умножение на что-то,
а потом сдвиг как деление на степень борт.
Вот такой деление.
Что у нас есть дальше?
Дальше есть обычные команды битовых,
которые вы ожидаете.
Это
P-and,
P-or,
P-sort.
Что?
P-not, P-next, P-next.
Не особо.
P-xor, как вы можете догадаться,
ваша любимая команда.
Почему?
Да, чтобы обновить регистр.
Никакой MOV0 теперь не пройдет.
А P-sort?
Это удобно.
P-xor — это ваша команда для обновления регистра,
особенно в отсутствие констант.
Из интересного есть еще команда P-and.
P-and.
Было это полезно.
Но это не команда I-next.
Это может показаться.
Вспоминаем архитектуру.
Это I с нотом N.
По английской нотации N стоит не там,
где происходит инверсия.
То есть P-and-next вначале инвертирует один из аргументов,
а потом делает N.
Он инвертирует тот аргумент, который хочется.
По-моему, это первый.
То есть я не четко помню, какой он инвертирует.
Но когда ты пишешь, и эта команда нужна,
он инвертирует ровно тот аргумент, который тебе хочется инвертировать.
У меня это обычно второй.
Ну вот, по-моему, первый.
И мне хочется инвертировать первый.
Посмотрите документацию.
Первый, да?
Первый?
Да.
Вот.
Просто у меня такое встречается,
когда мне нужно эндить с нотой какого-то значения.
А можно его заранее нотнуть и тогда уже снимать?
Нет, заранее нотить нечего.
Нет, я не про это.
Я про то, что если нужно, то со вторым нотом.
Ну что, не понял?
Не надо.
Все равно непонятно.
Обратите внимание на эту команду.
Весьма полезная команда.
И еще...
Эксченж есть?
Нет.
Если ты хочешь что-то эксченжить, то либо через третий регистр,
что обычно делают,
ну, либо ты можешь превращаться с любимой версией через несколько сорок.
Но обычно такой необходимости нет.
Зачем тебе эксченжить регистры?
Просто ты, начиная с этого момента, переименовываешь...
Регистр очень большой НОП.
НОП?
Ну, как бы, от того, что ты делаешь его на MMX лучше не станет.
То есть ты, конечно, можешь делать НОП Q регистр, запятая регистр.
Но это тоже не будет НОП.
Потому что оно тебе весь этот процессор порушит.
То есть как бы НОП на MMX сделать проблемно.
Любой чик на MMX
убивает тебя с процессора.
Поэтому оно не будет НОП.
Почему на MMX делать?
Зачем?
Вот я говорю, что...
Непонятно зачем.
И даже если и есть зачем, то оно не очень получится.
Поэтому идея сделать НОП на MMX неосмысленна.
Так.
Так, вопрос.
НОП большого размера по сравнению с местными НОПами лучше тем, что...
Он всего одна команда?
Да.
Меньше тратит декодера.
Если у тебя там в равнине, скажем, на 16 байтиков,
и тебе нужно вставить 15 байтиков,
то НОПы, конечно, легкая команда.
Но все-таки 15 НОПов не такая уж и легкая команда.
15 команд, которые нужно исполнить.
Поэтому существуют сейчас специальные многобайтные формы НОПов.
Это специальные обкоды,
по которым гарантируется,
что они исполняются как НОП.
И если вы попросите ваш ассемблер
командой align
выровнять вам следующий адрес
до кратности, чего вы там просили,
например, скажите align 16,
то вам ассемблер воткнет,
ну, как он там считает,
оптимальную комбинацию НОПов.
И там правило, как его НОПы втыкают,
оно немножко отличалось со временем.
Но оно можно использовать действительно на байтные НОПы.
То есть действительно на байтные НОПы.
То есть какие они там байтов доходят, не помню,
на 8-ми, 8-ми.
То есть такие довольно жирненькие,
чтобы буквально парочке НОПов можно было занять 15 байтиков.
А в равнину больше, чем на 16,
обычно не требуется.
Ну, не очень критично.
Ну, не код.
Вообще не код.
Продолжаем.
Что у нас есть еще из команд?
У нас есть команды сравнения.
Команды сравнения.
У нас есть две.
P, K, M, P, E, Q.
B, V, D.
И P, K, M, P, G, T.
Так, E, Q, E, D.
К...
А, да, E, Q ты описал.
E, Q.
E, Q.
E, Q.
B, B, D.
Как эти команды работают?
Как я вам уже спойлерил,
никаких флагов никто никуда не ставит.
Поэтому что значит сравнение?
Сравнение пишет результат туда же.
Первый аргумент.
И такого же размера, как и ваши входные данные.
Результат следующий.
Если условие команды не выполнено,
то в результате вы получите в этой порции нолик.
То есть сравнение происходит независимо по байтикам,
по вардам или под вардам.
Условия не выполнены, не равны,
значит нолик в этой позиции.
Если условие выполнено,
то вы получаете минус один.
Минус один это все единички.
На самом деле использование минус один в качестве true
в языках программирования встречается.
Например, в Basic true это минус один.
И честно говоря, это лучше и удобнее, чем один.
Вот в C постулировали, что true это один.
Ну, бывает.
С этим уже ничего не сделать.
Но технически удобнее на самом деле,
когда true минус один.
И здесь true как раз минус один, true все единички.
Обратитесь на это внимание.
Eq это сравнение на равенство.
gt это строго больше,
притом строго больше, как числа со знаком.
Значение интерпретируется как число со знаком.
Если первый аргумент строго больше второго,
то в этой позиции ставятся все единички,
иначе в этой позиции все нольки.
И у нас осталась одна единственная команда ММХ
до полного набора.
Это команда E-ММС.
Кто догадается, что делает эта команда?
Говорит, что ЭКПУ не занят.
Эта команда помечает все регистры ЭКПУ как свободные.
Потому что любая другая команда ММХ помечает все как занятое,
а по конвенции вызова не забываем,
ЭКПУ в конце функции должен быть свободен,
если вы не возвращаетесь.
И результат на вершине,
остальное свободно,
если вы возвращаете результат через ЭКПУ.
Поэтому, если вы пишете на ММХ,
не забывайте в конце вашей функции
ставить ЕММС.
Если вы этого не сделаете,
вы испортите жизнь тому,
кто использует ЭКПУ.
Потому что у него полезут наны,
так как он будет пытаться читать,
стэк занят,
поэтому стэк будет заполняться нанами.
Эта команда относительно легкая,
но не надо вставить ее в цикл.
То есть это команда для окончания функции,
которую использует ЭММС.
Если вы не уверены,
что внешняя функция не использует тоже ЭММС,
если у вас ММХ функция вызывает ММХ функцию,
то конечно вы во внутренней функции
может не ставите ЕММС,
внешняя тут же займет ЭКПУ снова.
Но если вы возвращаетесь куда-то в окружающий мир,
то вот здесь ЕММС нужен.
Понятно?
Ну и давайте что-нибудь напишем,
как я уже сказал, это полный набор команд.
Давайте, например, напишем следующее.
Есть у нас два массивчика А и В,
и я хочу построить третий массивчик С,
который содержит по элементной максимум.
Притом входные массивчики,
для простоты,
это будут байты со знаком.
То есть у вас есть функция,
которая принимает три указателя.
А, В, С.
И принимает N,
размер этих массивов в элементах,
элементы массивов,
байты со знаком.
Вот сразу вы начинаете чувствовать,
здесь как-то быть можете.
В реальности нет этого.
И в реальности одно из основных страданий
написания кода на СИН
это обработка краешков.
Вам нужно написать не просто основной алгоритм в середине,
а еще и правильно обработать края,
размер которых может быть какой угодно.
Почему те же самые картинки
народ любит постулировать,
что ширина должна быть кратной четырем,
и всякое такое.
Возможно, вы слышали.
Потому что это сильно снижает
количество специальных случаев,
которые вам нужно рассмотреть.
Если вы знаете, что ширина картинки
кратна четырем,
вот не надо рассматривать,
а что если там нечетное количество фиксивов.
А если там три поможет быть четыре,
и всякое такое.
То есть здесь как бы простой вариант.
Да, считайте, что n кратно восьмидесяти.
Хотите посложнее,
считайте, что n произвольное значение.
Ну и сразу почувствуйте рисунок.
Смотрите, что у меня.
Ну что, еще раз нам осталось.
Нужно найти, заполнить массив С,
по элементным максимум значениям а и b.
То есть С нулевое должно быть максимумом
из а нулевого и b нулевого.
Да, функция принимает три указателя
на а на b на С и размер трех элементов.
Ну и карта тоже самая.
Простое задание.
Размер красного свинья.
Сложное задание.
Размер произвольного.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
Что у вас 32, что 64 будет влиять только на конвенцию и, как называется, ваше диск.
Вашу, может быть, спорт будет активно.
Так что здесь совсем не зависит.
Спасибо.
Спасибо.
Спасибо.
Спасибо.
Спасибо.
Спасибо.
Спасибо.
Спасибо.
Спасибо.
Спасибо.
Спасибо.
Спасибо.
Спасибо.
Спасибо.
Спасибо.
Спасибо.
Спасибо.
Спасибо.
Спасибо.
Спасибо.
Спасибо.
Спасибо.
Спасибо.
Спасибо.
Спасибо.
Спасибо.
Спасибо.
Спасибо.
Спасибо.
Ребята, здравствуйте.
Здесь надо подыгрывать.
Проверить надо?
Нет, проверить, потому что до этого не было.
А, ну тогда тоже подыгрывать надо.
Проверить надо.
Проверить надо.
У нас же по байтам одно было.
Да, тоже самое.
Нет, я имею в виду по байтам первым.
Я же сказал, что в нулевой элемент результата нужно положить максимум из нулевых элементов a и b.
Я понял.
Нужно быть Stephen-ly.
Что такое?
Ну, по-моему,law-till.
Лоловцам в submitting.
Нужно?
Чего?
Чего имtiт!!!!!
Не, я statewide, говорил.
Как local, я из западных стран.
Скажите, investigating?
Да.
Нет, шо?
А там waste level, не факт.
Н administrated by zombies burning us.
cruelty.
Нужно было для этого.
Продолжение следует...
Продолжение следует...
Продолжение следует...
Продолжение следует...
Продолжение следует...
Продолжение следует...
Продолжение следует...
Продолжение следует...
Продолжение следует...
Продолжение следует...
Продолжение следует...
Продолжение следует...
Продолжение следует...
Detecting language using up to the first 30 seconds. Use `--language` to specify the language
Detected language: Russian
Сочистим информацию.
И мы сейчас рассмотрим, что там добавили.
Там добавили команды
b, a, b, b, b.
Это команды, которые интерпретируют входные данные,
как байты или слова без знака,
считают среднее арифметическое с округлением вверх.
То есть они считают a плюс b плюс 1
и поделить на 2 с округлением вниз.
Понятно?
Из забавного.
Первые команды, которые делают ровно это действие,
сделали аймдешники в своем 3D-нау.
Но там это были команды,
которые имели другой код.
То есть интелы сделали команды,
которые делают то же самое,
но имеют другой код.
И немножко другую мимонию.
Аймдешные команды назывались
p, a, u, g, u.
Или s, помню.
p, v, u.
У, b, v.
Потому что это беззнаковые числа.
Вот такая история.
То есть интелы сделали,
делали коды с номер 1.
И завезли команды, делающие то же самое,
но с другим несовместимым кодом.
Потом.
Что добавили?
Добавили команды...
Которые считают минимум и максимум одной командочкой.
Вот то, что вы сейчас сделали, стало можно посчитать одной командой.
Притом есть варианты unsigned байты и signed слова.
v и sv.
Но, как вы видели,
не то, чтобы это было прям полезно.
Это было хорошо.
Максимум, да.
v можно было бы посчитать за две.
За одну, по-моему.
Ну, это вопрос.
На самом деле, в чём ещё важный вопрос.
Когда мы говорим про всякие новые команды,
в том числе про всякие signed команды,
здесь есть одно важное но.
Команда новая, модная.
А как быстро она выполняется.
И нередко вот такие вот команды, которые мы делали,
мы делали.
Такие новые модные команды выполнялись со скоростью,
как предыдущий эквивалентный пол.
То есть вы можете это выразить за одну команду вместо двух,
но работать за ними будет столько же.
Иногда даже медленнее.
Поэтому использовать прям с ходу самые модные команды
народ не очень горел желанием.
Во-первых,
они должны поддерживаться железом.
То есть у пользователя должно быть достаточно новое железо.
А во-вторых, прямо то железо, в котором добавили эти команды,
нередко эти команды исполняло довольно посредственно.
И оно не было прям таким сильным улучшением
относительно нескольких старых команд.
Современные процессоры, конечно, все эти штуки уже отточили,
и они работают шустренько.
Ну, вот такой исторический концепт.
От того, что добавили какую-то модную команду,
еще вообще не означало,
что ее имеет смысл использовать сразу же.
А размер практически куда?
Это менее важно для того, как она работает,
и существенно менее важно, чем совместимость.
Потому что все вот эти симптер-ширения,
которые сейчас распадятся в большом количестве,
к чему приводят?
Потому что либо вам нужно в программе написать бейнслайн,
что вот старее этого железа мыть не умеем.
Что больно.
Либо написать несколько версий своего.
Для такого уровня железа, для такого уровня у железа,
и сишний вариант, чтобы оно комбинировалось в листе.
У меня есть хороший авторизатор.
Нет.
Почему?
Особенно в те времена.
Компиляторы на это были совсем не способны.
Угу.
Даже сегодня они не очень на это способны.
Как тебе?
Заглядание.
Так что решение было написать несколько версий такого кода,
которые в рантайме выбирают.
Это больно, потому что вам нужно вот поддерживать
несколько версий одного и того же алгоритма.
В N раз больше экипажей.
В N раз больше тестировать.
Ну, все понимаем.
Вот.
Что еще добавили?
Добавили командочки по экстрав, по инсрав.
Команды, которые позволяют вам взять слово из памяти.
Шестнадцать пяти.
И запихать в произвольную позицию вашего ML-регистра,
если это инсрав.
Или взять произвольное слово из ML-регистра и запихать,
вытащить его в память.
Вот это как раз команды, которые имеют, кроме куда, откуда,
еще аргумент, какой номер.
Здесь константочка.
Как я уже сказал, эту константочку бессмысленно запустить.
Кто команды, тот больше.
По экстраву ноль, по экстраву один, по экстраву два команды.
Ну, тогда это может быть аргумент по констанции.
Да, но это аргумент, это константа в ринге компиляции.
Да.
Поэтому оно, конечно, константа.
Ну, вот.
Ну, да.
Дополнительный пример.
И эти команды исходно работали фантастически.
Настолько фантастически, что запускать целиком весь регистр памяти,
оттуда вытащить 16 бит и запихать их куда надо,
работало быстрее, чем одна команда экстраву.
Сейчас она работает с нормальной скоростью.
То есть сейчас можно пользоваться.
А вот когда она только появилась, она работала просто ужасно.
Это была бесполезнейшая команда, потому что по скорости непонятно,
зачем такое может захотеть сделать.
Еще раз, сейчас, но сейчас работает хорошо.
Так, экстраву.
Что еще до счастья нам не попало?
П.
М.
Х.
У.
В.
Старшее умножение для чисел без знаков.
Старшее умножение для чисел без знаков.
Младшая часть, она универсальная,
а вот старшее было только для знаковых чисел.
Теперь у вас есть и без знаков.
Дальше есть очень полезная команда.
М.
Н.
С.
К.
В.
С.
Р.
У.
Р.
В.
Р.
Л.
О.
Д.
О.
М.
Р.
С.
Р.
С.
Р.
Р.
О.
С.
У.
С.
Р.
Р.
С.
У.
В.
Р.
С.
В.
биток каждого байта и упаковать эти битки плотно в восьмибитное число.
Остальную часть регистрации назначения внуки.
То есть, фактически, вы берете такую выжимку старших битиков, знаковых битиков, для каждого байта.
Понятно?
А где это может использоваться?
Сюда, по-моему.
По-моему.
Как считалось.
А где это может использоваться?
Мо-маска по-байтовой.
Так.
Что есть еще?
Дальше есть суперполезные команды.
Что это за команды надо рисовать?
Это команды битера, ВСТ, СРСР,
Восьмибитная константа.
Работает следующий номер.
Вот у вас есть destination.
Это набор из четырех слов.
Какое значение кладется в эти слова?
Вот сюда кладется одно из четырех слов.
Source.
Регистрация.
В соответствии с...
Регистрация.
Регистрация.
Регистрация.
Регистрация.
Регистрация.
Младшие два битика, константы, используются в качестве индекса
вот в этих четырех...
В этих четырех...
В массе.
В массе.
из четырёх значений.
Поняли, не поняли?
Смотрите, вот у вас
восьмибитные константы.
Берём два младших битика.
Два младших битика
образуют число в каком диапазоне?
От нуля до трёх.
Вот этот номер
это номер слова
в source register,
которое запишется
в нулевую часть
destination register.
Следующие два битика дают
номер в обходном
регистре, который запишется сюда.
Например, если вы
подадите константу ноль, что будет?
Первое
раскопируется во все четыре
значения.
В битике один, ноль, три, два,
пять, четыре, семь, шесть.
Это номера битиков.
Это дико удобная команда,
которая позволяет тебе, например,
размножить значения.
Одно слово
сразу во все четыре.
Оно позволяет тебе
произвольным образом
переставить
слова.
Когда ты хочешь что-то
посчитать на сим,
перестановка значений
это частая потребность
и это довольно много
страданий.
Эта команда позволяет тебе
произвольным образом переставить
практически со стоимостью
загрузки из одного регистра в другой.
Супер команда.
Да.
Ты должен выразить, какую
перестановку ты хочешь.
Какую удобнее написать.
Ты можешь использовать константу,
а двоичное число.
Ты можешь использовать двоичные
константы на секторе.
Не совсем.
Распаковка, она берет аргументы
из двух списков.
А эта команда
берет
индексацию
внутри одного регистра.
То есть ты не можешь
выразить распаковку этой команды.
Распаковки
больше в одну данную.
Так.
И
еще из вычислительных
команд
туда добавили команду
subw.
Вот это, наверное,
такой первый яркий
случай добавления команды
ради конкретного
алгоритма. Что эта команда
делает? Эта команда
вычисляет по
байтовую разницу
байт без знака
математические
результаты берет по модулю
а потом эти
разницы по модулю
суммируют между собой.
И в результате
получается одно
16 битное
число без знака
которое записывается
в вашу часть регистра
а остальная часть регистра обновляется.
Что мне можно сказать?
Зачем нужно действие
найти
сумму
разности по байтово
для байт без знака?
Для какого алгоритма
это?
Вот для каждого
байтика вот так попарно
находится разница
математическое
значение разницы
берется по модулю
а потом эти
модули между собой суммируются
в единое значение.
То есть это немножко
похоже на
Д.
Только там оно делалось
умножение и суммировалось
только вот один раз.
А здесь считается разница
модуль разницы
и происходит полная сумма
до одного значения.
Какой-то расстояние
вот
Ну вот еще раз, что за задача
ради которой мы создадим
специфические команды?
То есть явно же
это не для чего-то
бесполезно.
ПТГ?
ПТГ?
Ну не знаю, что-то вроде
листового
подсчета
...
...
...
...
Эта команда
суперполезная при кодировании
видео.
Потому что один из
шагов кодирования
видео заключается
в оценке движения.
Вы
оцениваете перемещение
объекта и
вычисляете дельту
как
переместить
плюс вычесть.
Если вы просто найдете разницу
между кадрами, тогда
небольшое перемещение объекта
даст вам кучу-кучу
информации, которая
вот состоит из
куска старого объекта и
куска нового объекта. Поэтому просто вычесть
кадры друг из друга плохая идея.
Если же вы
скажете, что объект
переместился на 3 пикселя
вот по этому вектору,
и найдете
разницу кадров
после вот такого
смещения объекта,
у вас, если только объекта
и, естественно, больше ничего не произошло,
будет почти кадр
состоящий из ролика,
который прекрасно сожмется.
Поэтому оценка движения
это важный этап
сжатия видео.
И одна из метрик,
которая говорит о том,
что похож текущий
элемент на
другой элемент,
это как раз сумма
абсолютных разностей.
То есть движение ищется
в таком большом случае,
как вы берете блок,
например, 8х8,
и считаете
сумму абсолютных разностей
этого блока в одной картинке
и этого блока в другой картинке.
И считаете некоторые окрестности
второй картинки
эту разницу.
Вот где в окрестностях
сумма абсолютных разностей минимальна,
вот это перемещение
вы принимаете
за перемещение объекта.
То есть это алгоритм
оценки движения.
Всяких метрик похожести
много,
и вот одна из простейших метрик
это как раз сумма
абсолютных разностей.
И вот ради нее прям добавили
такую командочку,
которая сильно ускоряет
данный ажиотаж.
Конечно более хитрые метрики
она не ускоряет,
но там как бы
и по скорости она будет
все медленнее.
То есть это было сделано для того,
что если вы хотите считать
изжатие видео,
то в простом случае
у вас есть удобная команда,
которая позволяет ускорить
и приблизиться, может быть,
в дальнейшем подобные команды,
прямо вот видно,
что рассчитанные на комплектный алгоритм
продолжат появляться.
Например, тоже я вам
говорил,
там в одном из расширений
появится команда CRC32,
которая считает
весь алгоритм CRC32
одной командочкой.
И рассчитана она на что?
Да, на C,
потому что вариантов CRC32
есть несколько,
считается тот вариант,
который принят в сетевых протоколах,
например, какой-нибудь там ZIP.
Он использует
метрическую операцию CRC32,
но он использует другую форму,
не ту, которая уже есть
в процессе.
То есть это было рассчитано
не на ускорение каких-то алгоритмов
изжатия популярного ZIP,
а на сетевые технологии.
Вот.
А литератические команды на этом все.
Но есть еще некоторые команды
соотчисленные.
В принципе, их можно найти
соотчисленными.
Точнее, это команды перемещения,
которые добавили.
Во-первых, добавили команду
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
данных и знаете что он в кэш все равно не влезет поэтому если вы пишете данные этой команды она
пишет меню и кэш и ваш кэш может кэшировать что-то полезное эта команда может дать существенное
ускорение если ваша ситуация ровно такая вы обрабатываете большой объем данных так что
повторного обращения к ним будет не скоро кэш кончится раньше чем вы повторно обратитесь но
из опасности как бы кэш это со временем наступит поэтому то что во времена Intium 3 кэши умещались
сегодня в кэш легко может и влезть поэтому эту командочку использовать можно но осторожно то есть
реалистично оцениваете
насколько действительно в кэш оно не влезет может оно просто сегодня влезет а потом влезет
но даже сегодня есть весьма специфичный кристалл с 10 гигабайтами L2 памяти кэша
нет L2 нет что с этим пока что
это там под именно подчисления с нейронками делается специфичный кристалл
ой ну там совершенно не так
ну да
нет мы хорошо про x86 же не общего назначения
нет у нас вообще x86
так
и так это команда пишет именую кэш соответственно если вы запишите эти данные,
а потом прочтете что можно сказать
вы можете прочесть
данные вот здесь, вот сейчас там 들어 у нас killing gallery и там установkus это хорошо
их из кэша в старую версию. Поэтому, если вы пользуетесь этой командой, после того, как вы там все записали,
нужно поставить специальную команду
Spence. Spence — это барьер по записи, которая, в частности, синхронизирует кэш вот с той системой записи минуя кэш.
Поэтому правильный вариант использования — если вы пишете через моб NTQ,
то после обработки ваших данных,
вы ставите Spence перед тем, как вернуться, и начать эти данные обрабатывать повторно.
Spence синхронизирует то, через что эта команда пишет, и кэш под системой.
Чтобы они пришли к единому дню.
— То есть был кэш, который с этим вообще как-то связан, а он не был?
— Если ты допишешь через моб NTQ, а потом прочитаешь обычной командой,
у тебя есть все шансы прочесть так.
Это два значения.
Если ты поставишь Spence, оно гарантирует, что теперь кэш и оперативка подсинхронены между собой.
— Сколько это будет зайти?
— Нет.
Она делает что-то более индивидуальное, но все равно в цикле станет феминал.
То есть это дешевая команда вне цикла и дорогая внутри цикла.
— Как вы с этим относитесь?
— Такой вопрос.
— Почему просто моб NTQ не инвалидирует кэш, если это операция?
— Потому что это долго.
В смысле, для команды побыстрее записать память.
Поэтому она вообще лимнует всю кэш-систему и с ней не разговаривает.
Дальше есть команда, которая существует.
Ее ни разу не было.
У нее два аргумента — это MM-регистры и есть неявный аргумент — это регистры EDI.
То есть в команде не написано, но используется.
Что эта команда делает?
Эта команда пишет свой, по-моему, первый аргумент — память — по адресу EDI, но пишет выборочно.
Пишутся только те бантики, для которых во втором аргументе в старшем битике стоит единичка в этой позиции.
То есть это возможность записать память по маске.
Где вы какие-то бантики пишете, а какие-то не пишете.
— Если он наличит, то он читает их, потом меняет то, что мы хотим записать,
— Да, это можно рассматривать таким образом.
Как прочесть, потом смешать и записать результаты.
И мне кажется, она тоже, по-моему, темпорария.
Я не учил коммуникацию читать.
Еще раз, я ни разу ее не помню.
Не знаю, что существует.
Но мне такое действие никогда не было.
— Пацан напишет, что он для тех, где нулево, просто скипает.
— Да, все оставляет старое значение.
А где единички, обновляет тем значением, которое он назовет.
Вот такой странный диск.
И есть у нас еще один набор команд.
Если мы тоже все рисуем, то набор команд называется такой вот.
И существует полный ремонт.
t0, t1, t2, mta.
У нее один аргумент — адрес памяти.
Идет на константу.
Просто по правилам, как вы можете писать и рисовать.
Что эта команда делает?
Ну, на самом деле, это опять у Intel подгорело.
AMD-шники сделали прикольные команды в своем 3D Now.
prefetch и prefetchv.
prefetch — это команда, которая говорит,
я собираюсь скоро читать по вот этому адресу.
Кэш, закэшируй ко мне к расчленению вокруг.
То есть это команда, которая логически, но более того,
она даже не падает, если вы выдадите невалидный адрес памяти,
или на который у вас нет права.
Логически — это чистый нод,
который передает подсказку химик к кэш-подсистеме.
Кэш-подсистема имеет полное право зайти на вашу подсказку
и не делать никакой подгрузки.
Но обычно она так и делает.
И эта команда позволяет, вот если вы заранее поставите,
то есть перед самой операцией загрузки памяти,
бессмысленно эту команду ставить.
Ее имеет смысл поставить за несколько итераций цикла,
чтобы из памяти данные успели подключиться к тому моменту,
когда вы до них дошли.
Так вот prefetch была команда,
и prefetch .
prefetch эта команда говорит,
что я собираюсь писать по этому адресу.
Поэтому следует загрузить кэш-линию в режиме modify.
Помните про такую реальность?
Вот команда говорит, что я собираюсь писать по этому адресу,
поэтому сделай rfo из памяти.
rfo .
Понятные, простые, супер эффективные команды.
Конечно, Intel не могли поддержать эти понятные, простые команды,
поэтому вместо этого они разразились четырьмя командами,
конечно, с другим кодом и совершенно другой описанной методикой поведения.
prefetch ,
prefetch ,
prefetch ,
которые постулируются как
подгрузить данные во все уровни кэша,
во все уровни кэша, кроме первого,
во все уровни кэша, кроме первого и второго,
и подгрузить данные в кэш для нон-темпоральных данных.
Что с этим значит?
Практически, когда я с ними экспериментировал,
самой полезной была команда последняя,
которая Intel.
Вот.
Но, честно говоря, это хаос.
И из забавного,
сейчас 3DNOW, как расширение,
оно, можно сказать, полностью сдохнуло,
потому что оно полностью было покрыто
новыми, более мощными расширениями,
которые поддерживает и Intel, и AMD,
и из оригинального 3DNOW сейчас осталось ровно две команды,
prefetch и prefetch ,
которые вынесли в отдельный флаг процессора,
и даже новые Intel-ские процессоры их поддерживают.
То есть, вот, современные AMD-шные процессоры,
они уже 3DNOW не поддерживают.
В какой-то момент они выбросили его,
сказали, ну, это старое расширение,
и вообще, он его тоже не супер широко использовал,
потому что только AMD-шные Intel-цы отказались его поддерживать.
Но вот с этого расширения, как ни странно,
выжило две команды.
Это вот команда prefetch,
которые современные Intel-ские процессоры,
относительно недавно,
их поддержали вместо вот этой ереси с T0, T1 и NTA.
Это про prefetch.
И это, то, что я вам сейчас рассказал,
это было такое небольшое численное расширение,
которое входило в SSE.
А по большому счету SSE это совсем про другое.
SSE это новое большое расширение,
которое добавляет вам 8 новых регистров.
Вот не та фигня, которая была обновлена,
а настоящие новые регистры.
И насколько Intel-у подгорело,
тоже видно, потому на что они расщедривались.
Они расщедривались на 8 новых регистров
под названием XMM 0x7,
которые аж 128-ти.
То есть нам было жалко сделать 8 64-битных,
а здесь они сделали 8 128-битных.
Как у них от 3D науку подгорело.
Вот.
Из интересного.
XMM-ов потом стало больше.
Когда потом?
В 64-битном мире.
То есть, если вы работаете из 64-битного режима,
то вам доступно XMM 0x15.
Это связано не с процессором,
а с битностью кода.
То есть AMD шутки в своем 64-битном расширении
и расширили эти XMM-регистры.
Понятно?
То есть сколько вам доступно XMM-ов
зависит от битности вашего кода.
В 32-битном коде 8,
в 64-битном 16.
Что из себя представляли эти XMM-регистры
с точки зрения SSE?
Они интерпретировались строго одним образом,
как 4 клоуна.
И были соответствующие команды,
которые позволяли вам в плавающей почке
считать сложение, вычитание,
умножение, деление, корень квадратный.
Ну, разве что тригонометры нет.
Его не ставить и возить.
Но так очень круто
по 4 клоуна за раз.
До того времени это прям было очень шумно.
То есть основная часть SSE это вот это.
Что было дальше?
Дальше у AMD-шников был отклончик процессора.
И у него было расширение 3DNOW Pro.
Pro заключалось в том,
что они добавили еще парочку 3DNOW-команд.
То есть довольно забавных команд.
Например, команда, которая делает
для одной пары числа сложение,
а для соседнего числа вычитание.
Кто догадается, зачем это нужно?
То есть.
Одну пару чисел складывает,
а следующую вычитает.
Для аудио.
Ну, а...
Конкретно для того, чтобы смотреть
C, N, F каналы и разность каналов.
Нет.
То есть для аудио в принципе да,
но не в этом смысле.
Можно это подальше подпустить.
Ну, а почему?
Это то, что вы хотите сделать,
когда считаете комплексные умножения.
Вам нужно там одни числа складывать,
а другие вычитать, потому что у вас получилось
i в квадрате мимо единицы.
И вот это вот сложение, то есть вычитание,
оно, на самом деле, прям очень подлинно работает.
То есть, если вы делаете аналогичную команду на SSE,
надо было извращаться,
вам нужно было иметь маску,
где там есть в некоторых местах единички,
ксорить там,
чтобы применять знак и прочие извращения.
Поэтому некоторые алгоритмы на 3DNOW,
как ни странно, на 3DNOW.to,
работали быстрее, чем намного более выгодные на SSE,
потому что там были подходящие команды.
Но со временем, конечно, до Intel дошло,
и в SSE 3 они таки добавили команду,
которая делает попеременное сложение вычитаний.
Только во времена SSE 3 Intel полностью покрыли возможности
довольно уже старинного 3DNOW Pro своим расширением.
Какие годы?
Не знаю, в Википедии.
Вот.
То есть вот этот самый окончик,
он имел 3DNOW Pro,
и в 3DNOW Pro входило что?
Вот всё вот это.
То есть они поддержали целочисленную часть MMX
буквально сразу же,
а вот основную часть SSE с задержкой.
Поэтому вы можете встретить слова
MMX
EXT.
MMX EXT
это вот тот кусок SSE,
который является расширением MMX,
и который AMD процессоры начали уметь раньше,
чем начали уметь полное SSE.
Поэтому если вы в каком-то сексе увидите этот флажок,
это вот про это.
Что можно сказать про SSE?
SSE, как я уже сказал,
оперируют строго вот так.
И из особенностей команды SSE выглядят следующим образом,
ну кроме нагрузок,
они выглядят вот так.
ADD PS
или ADD SS.
Где PS,
это называемый векторный вариант команды,
а SS — скалярный вариант.
Скалярный вариант команды
делает операцию только с младшим флотом,
а остальные три сохраняют.
Detecting language using up to the first 30 seconds. Use `--language` to specify the language
Detected language: Russian
То есть какая-то форма существует, а какой-то формы нет.
То есть народ, который проектировал, они так аккуратненько выбирали варианты,
вот какие практически нужны, какие сделают.
А какие особой необходимости нет, просто ради симметрии систему команд делать не будет.
То есть это такая не полностью симметричная система команд,
а сделанная в режиме сэкономика.
И Кальмомери на самом деле довольно мощно.
А именно, MMX оперирует восемью почти новыми регистрами,
которые называются MM0 по MM7.
И это 64 бит.
64 битные регистры.
Я вам сказал, почти новые.
Кто может догадаться, что это на самом деле не новые регистры?
XAML, XAML, FPU?
Нет, XAML никаких нет.
То есть это старые переименованные регистры?
А что за регистры?
FPU может.
Единственные крупные регистры, которые у нас были,
вообще это расширение каких времен?
Первый Pentium.
Первый Pentium, он был просто Pentium.
У него была еще версия Pentium MMX.
Это Pentium плюс MMX.
Вот тогда так все просто называлось.
Так вот, регистры у первого Pentium были 32-разрядные.
Это был совершенно в дотку 32-битный процессор.
И 8 64-битных регистров Intel показались, ну, как-то жирно.
Жалко столько места на кристалле выделять.
Поэтому вот эти регистры отдали мальтисты регистров FPU.
Регистры FPU, как вы помните, сколько битные?
80-битные.
И эти 80-битные состоят...
закодированы как Extended Precision.
То есть старший битик — знак,
потом 15 битиков — экспоненты,
а потом 64 битика — мальтисты.
Вот эти младшие 64 битика — мальтисты,
их...
теперь можно...
к ним можно обратиться по имени MM.
Но, в отличие от регистров сопроцессора,
здесь у вас прямая анализация.
То есть никакой не стэк, не стэкпоинтер, не пушпоп.
Здесь прямое название.
MM0 — это всегда MM0.
Но, в связи с тем, что это на самом деле те же самые регистры,
когда вы делаете почти любую команду MMX,
все регистры сопроцессора помечаются как занятые.
Поэтому использовать одновременно MMX и FPU крайне затруднительно.
Ну, в том плане, что FPU будет мгновенно проигрывать,
как только вы сделаете что-то на MMX.
И проигрывать даже не столько, что там будет теряться результат,
без необходимости ничего писаться не будет,
но у вас тут же все будет помечено как занятое,
со всеми вытекающими последствиями.
Поэтому флаги занятости FPU MMX не интересуют.
То есть если у вас там уже что-то было на FPU в регистрах,
это никак вам не мешает что-то в одном регистре записать.
Вы даже не узнаете, что там что-то было.
Поэтому MMX вот так доминирует над FPU,
и еще раз вместе их использовать крайне затруднительно.
MM регистры, они не про floating-point?
Еще раз, физически это младшие 64 бита того,
что называлось R0 по R7.
Просто R0 по R7 таких имен не было.
Они вам были доступны в виде стека, как ST0 по ST7.
А здесь у вас прямая адресация, не стек.
То есть младшая часть R0 это MM0.
Младшая часть R7 это MM7.
Понятно?
Да.
Следующее.
MMX это целиком целочисленное расширение.
То есть все команды, которые относятся к MMX,
это все команды по работе с целыми числами.
Не про плавающую точку.
Там будут дальше другие расширения,
там появятся и аналогичные плавающие точки.
Но MMX только целочисленное расширение.
И на самом деле всякое видео, как правило, считается в целых числах.
Более конкретно, фиксированные точки.
Если вы что-то помните из какой-то архитектуры,
фиксированная точка используется весьма широко.
Например, видео обычно считается в фиксированной точке,
потому что фиксированная точка считается со скоростью целых чисел,
что существенно быстрее, чем считать плавающую точку.
А точности плавающей точки для видео не требуется.
Поэтому нужна скорость.
Высокая точность не нужна.
Собираем фиксированную точку разуме.
А если там какая-то суперграфика?
А что за суперграфика?
Суперграфика, она у тебя на каком уровне?
Если ты говоришь про картинку, которую ты создаешь,
чем ты собираешься эту картинку показывать?
Так, к слову.
Упорно.
Упорно, да.
А какая точность?
Вывод данных в монитор.
Ну, там какое-то количество.
Ну, обычно.
8 бит.
8 бит.
8 бит на канал.
Ну, то есть 3 кусочка по 8 бит, это 8-битные данные.
При том, более дешевые мониторы, они даже вообще 6-битные.
Более крутые мониторы 10-битные.
16-битные потенциально существуют.
Но мне кажется, что я слышал про такое, они, например, медицинские,
а во-вторых, они серые.
То есть там 16-бит, но они киевские.
То есть только у тебя, например, серые, а у тебя есть киевские, вот, медицинские.
Вот.
Поэтому больше 16-бит мониторов я никогда не слышал, что существует.
Я никогда не слышал, что существует.
Подавляющее большинство 8 бит.
Даже 10-битные встречаются не очень часто.
Вот.
Поэтому твою супер-пупер графику можешь, конечно, насчитать.
Но кто ее увидит?
Поэтому для промежуточных вычислений большая точность норм.
Даже нужна.
Если у тебя результат 8-битный, то промежуточной точности 16-бит обычно хватает.
То есть у тебя 8 бит запасной точности.
Поэтому нередко всякое видео и подобное считают вот в промежуточной точности фиксированная точка 16-бит,
а результат получается целое число 8 бит.
.
И NMX оптимизирован вот именно такие вычисления.
То есть вычисления с 8-ю, 16-ю битами точности.
Вот этот вот 64-битный регистр, как он может быть инкарпентирован?
Ну, 8-битный регистр.
В принципе, одно число как 64 бита, ну, редко.
Но потенциально можно сказать, что одно число равняет 64.
Другое дело, что никакой арифметики такого размера у вас не будет.
Мало как его можно интерпретировать как одно число 64-битное.
Некоторыми командами его можно интерпретировать как 2 32-битных часа.
Большинство команд умеет его интерпретировать,
как 4 16-битные порции, и тоже многие команды умеют интерпретировать его как 8 8-битных порций.
Надо рисовать картинки? Понятно.
Теперь, что у нас есть за команды? Ну, во-первых, в команде 3 ссылки.
Есть команда movq, которая пересылает весь ваш регистр.
Аргументы, ну, как в команде mov, вы ожидаете, либо регистр-регистр, либо память-регистр, либо регистр-память.
Обратите внимание, что все это возникло в 3-битном процессе.
Поэтому movq регистр какого-то общего назначения,
типа там какой-нибудь rx.
Нельзя сказать, никакого rx-а не было.
И mov это команда точной битности,
поэтому здесь у вас возможны варианты либо mm-mm, либо память-mm, либо mm-память.
Дальше. Есть команда movd,
которая пересылает 32 бита.
Как она работает?
Она возможна только между mm и nmm.
В качестве nmm может быть как кусок памяти, так и 32-битный регистр.
Если вы пишете в память или в обычный регистр,
то вы просто пишете младшие 32 бита mm регистра, куда бы сказать.
Если вы пишете в mm регистр, то вы пишете целиком весь регистр.
В 32-битом младших то, что вы сказали, старшие обнуляются.
В принципе, эту картину вы уже видели в 64-битах, поэтому не новость.
А вот эти mm регистры появились после 64-битных?
Да.
Но ситуация с тем, что вы пишете младшую часть, старшие обнуляются.
Это вам уже известно.
Потом, есть набор команд всякой паковки-распаковки.
Например, есть команды pack, ss, а дальше бывают dv и vb.
Понятно, что я здесь написал?
Это команды pack, ss, dv и pack, ss, vb.
Как оно работает?
Вот, например, возьмем вариант dv, mm1, mm2.
Эта команда берет...
Это mm2.
Это mm1, младший битик, старший, младший, старший.
Интерпретирует входные регистры, как содержащие двады.
В результате этой команды получатся варды.
То есть, в результате.
В результате.
В результате.
В результате.
В результате.
В результате mm1 будет содержать 4 варда.
В результате.
И паковка происходит следующим образом.
При том, эта команда.
вот это уменьшение видности операции производит sine-saturation.
То есть, если у вас значение целиком уменьшалось в новом типе данных,
скажем, что 3, у вас такая стоимость 3.
Если у вас там было 2 миллиарда,
то у вас что превратилось в 2 миллиарда?
То есть, это команда, которая уменьшает диапазон
производя насыщение
и интерпретируя и входные, и результирующие данные
как значения со знаками.
У вас есть команда, которая упаковывает 2 рды в 2 рды
и которая упаковывает 2 рды в байты.
То есть, вы можете поджать 32 бита до 16,
и 16 бит до 8.
Вот таким образом.
Получается, если байты, то будет 8 порций?
Да, у вас будет 8 порций по 8 бит.
Если вы здесь скажете pack ssbb,
в результате получится 8 байтиков со знаком.
Аналогично, но за прострелочек больше.
Притом, не стоит вам мешать указать дважды один и тот же регистр.
То есть, например, pack ssdb, mm1, mm1
тоже вполне себе справедливо.
Без проблем.
Также есть команда pack svb.
Эта команда производит unsigned situation.
Интерпретируя входные данные как слова со знаком,
а в результате у вас получаются байты без знаков.
И на самом деле, уже одна эта команда
дает огромный природ скорости алгоритмам обработки изображений.
Почему?
Потому что.
Смотрите, я вам сказал, как обычно обрабатываются изображения.
Вы поднимаете промежуточную точность, там бит до 16.
Считаете.
Когда вы результат хотите записать в память, что нужно сделать?
Если вы тупо запишите в память, у вас будут проблемы.
Да.
Если в процессе вычисления у вас получилось 256,
то при записи 256 в память у вас будет 0.
То есть у вас сверхяркая точка превратится в черную.
И наоборот, если у вас получилось минус 1,
сверхчерная точка станет 255 белой.
Что полная фигня.
И такого допустить нельзя.
Как этого не допустить?
В конце ставят IF.
IF у нас было больше 255, то 255.
Если было меньше 0, то 0.
Насколько хорошо процессоры ИФА, я думаю, вы в курсе.
Смотри, что у нас в названии.
Нет.
В процессе вычисления у тебя больше точность.
Обычно у тебя 16-битное число и со знаком.
Когда ты результат пишешь, оно превращается обычно в 8-битное число без знака.
Но вот чтобы правильно со знаком 16-битное записать 8-бит,
тебе нужно выполнить вот это насыщение,
которое на высоком уровне выглядит как два IF.
Вот пока СВБ может прийти в минус 1, мы можем от сайта это прочитать?
Нет.
Еще раз.
Оно делает.
Исходные слова интерпретируются.
А слова со знаком?
Тут слова со знаком, а результирующие байты интерпретируются как байты без знака.
То есть на самом деле она делает ровно то, что ты хочешь, когда ты обрабатываешь картинки.
Да, по-моему, без ИФА это делается.
Да, конечно, это делается без ИФА.
Ну, в плане и реализация самой на железке тоже без ИФА.
Конечно.
Конечно.
Если ты без этого пишешь, то ты пишешь это через два ИФА.
Там можно сравнить и делать сайм-экстеншн.
И так сделать сатурацию.
Ну, я буквально, короче, я недавно таким занимался.
Сколько там команд?
Там была реализация одной инструкции, и там был прикол, что она сделана через селект,
чтобы было преобразовать это без селекта.
И я преобразовывал через сравнение на меньшее один битик, и я делал сайм-экстеншн.
И он как раз-таки, типа, понимал, что это сатурация, потому что если это один,
то у нас сайм-экстеншн всегда единицы.
Ну вот к чему это два как слова?
У тебя есть набор команд x86.
Они тебе известны.
Ну да.
Вот вырази свою мысль через существующие команды.
Вот тебе нужно выполнить действие.
Больше 255 заменить на 255.
Меньше 0 заменить на 0.
И потом вот из слова сделать байтинг.
Сайм-экстеншн.
Да, можно так сделать.
Хотя в то время смог z.
Команды не было.
Смог z появился в Pentium Pro.
А Pentium Pro — это параллельная линейка.
То есть там был Pentium, Pentium MMX и Pentium Pro.
Потом Pentium Pro — это было супердорогое удовольствие.
То есть смог z даже был не вариант.
И на смог тоже не сказать, что прям особенно удобно.
Чтобы делать смог, тебе что нужно сделать?
Две проверки, два смога.
И еще эти результаты, с чем ты смогуешь, тоже нужно где-то хранить.
Что это, два регистра или еще хоть два обращения к памяти?
В любом случае плохо.
Притом здесь, возможно, даже лучше сработают ифы.
Потому что если у тебя основная часть картинки не выходит за границы,
ифы, может быть, даже дешевле будут.
Поэтому смог не факт.
Но в любом случае, эта команда не просто делает это действие супербыстро,
буквально за один такт,
она еще делает восемь таких действий за этот один такт.
То есть даже уже одна эта команда позволяет сильно ускорить обработку изображения.
Это вот демонстрирует.
Это демонстрация того, что набор команд создан под конкретную задачу.
Как вы прям обычно хотите, когда делаете какой-то алгоритм.
Вот такая командочка, скорее всего, есть.
Либо можно через небольшое количество команд выразить вашу мысль.
Это вот такое свойство 3D-микса.
Так, что дальше у нас есть интересного?
Распаковка.
Что за команды распаковки?
Это вот такие команды.
Так, С, В, В.
Сейчас я вам напишу.
А, М, К, Х или Л.
И оно может быть...
В, В.
В, Д.
Д, К, Л.
Шесть команд.
Да, обратите внимание, здесь одну букву сэкономили.
Это У, Н, П, К, К.
А, сэкономили.
П, У, Н, П, К.
П, У, Н, П, К.
Х или Л.
У, Н, П, К.
Да.
Я меня еще спрашиваю.
А, конечно.
Да.
А, М, К.
Что значит первая букву П?
П – это префикс большинства команд MMX, как F был префиксом для их полукоманд.
Кроме мобов и еще одной команды, все команды MMX начинаются с П.
А, должно быть, пишут здесь маленькую комплектацию специально?
Что?
Нет, еще раз.
Я вам говорю, что команды и регистры на сервере – регистры независимые.
Поэтому я даже на скейр напишу смесь дикую.
Это не должно вас пугать.
Это регистры независимые.
Вообще исход на сервере был полностью регистры независимый язык.
Но потом пришли к выводу, что метки следует интерпретировать регистры зависимые.
Исходно даже метки были регистры независимые.
Потому что исходно даже не было разницы между большими и маленькими буквами.
Если совсем так набрать, то первые кодировки символов содержали один набор букв,
который обычно рисовался заглавными буквами.
Поэтому, если вы видели всякие старые книжки, например,
такой старый-старый Си или там Портраун, тоже старенький,
вы могли видеть код, который написан весь капсом.
Почему?
Потому что он не капсом написан, а он написан единственным существующим вариантом букв.
И просто не было различения между большим и маленьким буквами.
Так еще раз, да.
Вот такие старинные языки, которые произошли в те древние времена,
они просто в своем рождении не могли гарантировать вам,
что существует разница больших и маленьких букв.
Тяжко было бы голосовать.
Да, там было довольно тяжко.
И всякие диграфы и триграфы все не на ровном месте возникли.
Потому что гарантировать, что у вас существует символ фигурная скобочка, тоже было нельзя.
То есть у вас просто не было такого символа в наборе ваших символов, которые есть у вас.
Как писать программу на C, когда у вас нет символа фигурная скобочка?
Макросы.
А что макросы?
На что ты взялся выразить макросы?
У тебя нет такого символа.
Никак.
На паскальце.
Нет, я понимаю.
В смысле, можно...
Просто нет.
Это больше страдать, чем писать на паскальце.
Так что если вы почитаете про диграфы и триграфы C, вот они как раз возникли как способ написать программу на C,
даже если в вашей системе не хватает важных символов для языка, вдувающих фигурную скобочку.
Ну, ясен, конечно же, это язык принципиально тех же времен.
Поэтому он в регистре независимый.
Поэтому регистр команд не обращайте на это внимания.
Я пишу как получится на доске.
А когда вы пишете, ну уж пишите консистентно.
Везде одинаково.
Обычно сегодня пишут в нижнем регистре.
Ну, потому что так как-то привычно.
Логические программирования тоже, кстати, ключевые слова обычно пишут в нижнем регистре.
Несмотря на то, что это неважно.
Влияние в ручью языков приводит к тому, что по большей части, а сервер сегодня, вы видите, тоже в нижнем регистре.
Возвращаемся к нашим командам.
Что это делает?
Допустим, возьмем форму ПУНФКХВД.
Тоже ММ1, ММ2.
Как она работает?
У нас исходные регистры.
Интерпретируются как ворды.
То есть 4 ворда на входе.
На выходе у нас в некотором смысле 2 ворды.
Как?
Вот так.
I.
H.
Это про то, что мы берем старшие части входных регистров.
Если L, то стрелочки будут из ваших частей.
Теперь.
В каком смысле это распаковка?
В смысле, если у вас, например, в ММ1 содержатся слова без знака.
А в ММ2 лежит нолик.
То это действительно будет конверсия из вордов в дворды.
Понятно?
Если у вас в ММ1 содержатся слова со знаком.
То вам нужно ММ2 заполнить ноликами в тех позициях.
В тех позициях, где число не отрицательное.
И единичками, где отрицательное.
Это сделать не сложно.
И тогда эта команда сделает вам расширение.
Как значение со знаком.
Но вообще на эти команды следует смотреть.
Как на вот такую хитрую перестановку байтика.
То есть не надо прямо относиться к ней.
Эта команда используется только когда вы делаете конверсию из вордов в дворды.
Нет.
На подобные команды следует смотреть.
Эта команда делает вот такую перестановку байтиков в регистр.
И это действие полезно просто само по себе.
Когда вам нужно переставить данные внутри регистров.
А потребность переставить данные возникает весьма часто.
Поэтому если упаковка это более-менее десертная упаковка.
То распаковка это скорее больше перестановка.
Понятно?
Теперь. Что у нас есть из арифметики?
Из арифметики у нас есть обычное сложение.
Вариантов В, В, Д.
Соответственно оно делает что?
Складывает 8 пар байтиков.
Вот так вот.
4 пары слов.
Либо 2 дворда.
Понятно?
Но кто-то кивает, а кто-то...
Оно не кивает.
Ну вот опять-таки.
ММ1.
ММ2.
Что будет происходить?
Вот у тебя, например, Д.
У тебя 2 дворда.
Это ММ1.
ММ2.
Ты делаешь вот так вот сложение.
Вот старшую часть со старшей складываешь.
Пишешь старшую.
Машу из маши.
Пишешь в машу.
Сложение.
Сложение из баку.
Модулятор.
Как?
Обычное сложение.
Кроме обычного сложения.
У вас есть команда.
П.
А.
Д.
С.
В.
В.
И.
П.
А.
Д.
У.
С.
В.
В.
Суторейшн.
Суторейшн.
Да.
Это команды, которые складывают.
И насыщают.
В случае выхода за границы.
Как число со знаком.
С.
Или как число без знака.
У.
С.
Никак не работают складывания.
И обычное сложение тоже никак складывание не работает.
То есть ваш результат.
Это только значение вашего регистра.
Никаких флагов нигде не ставится.
То есть флагами не связаны.
Обратите внимание, что насыщающие варианты существуют только для байтов и слов.
Для двортов действительно нет такой команды.
И вот это нередко.
То есть вот здесь у вас есть две формы.
Здесь только одна форма.
Здесь все формы.
Здесь только вот такие формы.
И для ммх это очень характерно.
Что у вас не все есть формы.
Потому что они нужны.
Ну не особо нужны.
Аналогично есть формы с вычитанием.
Обычная ПСАВВВ насыщающая ПСАВС насыщающая без знака ПСАВС.
Это только с регистрами, да?
Да.
Важное замечание, что в арифметике вы можете указать либо два регистра, либо регистры памяти.
Варианта указать константу нет.
Даже в мове нет константы.
Если вы хотите загрузить какую-то константу, вам придется эту константу разместить в памяти, а потом из памяти ее загружать.
Либо если ваша константа маленькая, 32 бита умещается, можете записать ее в регистр и регистр переслать через мову D.
Но почти ни в каких командах в ммх нет констант.
А там, где есть константы, это константы, управляющие поведением, а не константы как значение.
В смысле, константы в самой команде, которая указывается?
Как часть команды, да.
Какой-то аргумент у команды.
А почему это не моники, а крокодильный аргумент?
Ну, видишь.
На стороне у нас нет.
Нет.
Ты не хочешь это иметь частью мимоники.
Вообще не хочешь.
Но формальный, а точнее аргумент.
Ну, как сказать?
Когда идем, тогда и увидишь.
Вот почему эти бесполезные разговоры.
А у нас еще не было такого.
Дальше у нас есть умножение.
Умножение существует всего три команды.
По му-л-л-в.
По му-х-в.
И замечательная команда.
Ма-дв-д.
Начнем с простого.
Команда по му-л-л-в.
Догадываетесь ли вы, что она делает?
Лижнее, 32, 5, результат, умножение.
Ну, в на конце намекает, что она работает с вардами.
С 16-ю диким значением.
А л намекает на младшую часть результата.
Поэтому эта команда берет ваше значение, как 16-битное число.
Умножает.
И вы получаете в той же позиции младший 16-битный результат.
Вопрос.
Это умножение знаковое или беззнаковое?
Не важно.
Да, правильный ответ не важен.
Младшая часть результата и для знакового, и для беззнакового умножения совпадают.
Поэтому к му-л-л-л-в вы можете относиться к ней и как к беззнаковому умножению, и как к знаковому.
Как хотите.
А вот к му-л-л-л-х-в, которая дает вам старшую часть результата.
Вот старшая часть, она отличается.
И эта команда дает вам умножение с точки зрения знакового умножения.
То есть эта команда интерпретирует ваши слова, как слова со знаком.
И дает вам старшую часть, старшую половинку полного 13-битного умножения.
Если вы хотите получить полное 13-битное умножение, то вам нужно сделать распаковку.
Помните вот ту хитрую перестановку.
Теперь вы можете на нее посмотреть.
Немножко посреди угла.
И она даст вам ровно то, что нужно.
Потому что умножение дает вам вот такие полуприкаты.
Что делает команда, команда dvd?
Как следует из названия, это некая комбинация умножения и сложения.
Комбинация следующего вида.
Входные регистры интерпретируются, как содержащие слова со знаком.
Вы делаете...
Вот так вот.
Умножение.
Притом умножение вы делаете с полной точностью.
То есть получается 32-битный результат.
Потом результаты этих умножений вот так вот опарно вы складываете.
И в результате два получившихся дворда записываете.
У нас h-ая часть включается.
У нас на выходе два дворда получается.
Да, у тебя на выходе два дворда.
Вот еще раз повторю картинку.
Ты умножаешь 4 пары слов.
Но соседние пары после этого складываешь.
Поэтому у тебя получается 2 результата а не 4.
То есть в каталоге умножение полное.
Да.
Полное умножение.
Вот еще раз.
В промежуточном результате у тебя получится 4 дворда.
Которые ты между собой 2 старших и 2 младших сложишь.
И в результате всей команды у тебя получится 2 дворда.
Ну вот нарисовано.
Я не знаю как лучше нарисовать происходящее.
А как 4 там дворда уменьшаются?
Они на аллоне лежат.
Они в процессе вычисления существуют.
Ваш результирующий дискер будет записан на только 2 дворда.
Она пишет по первым командам передания?
Да.
Как обычные команды.
Первый аргумент это куда мы пишем.
И откуда читаем первое значение.
А второй это откуда читаем второе значение.
То есть здесь ничего особенного нет.
То есть здесь ничего особенного нет.
Может переполнение случиться?
А вот подумай.
На самом деле особенность этой команды, что в ней невозможно переполнение.
Если подумать, аккуратно посчитать варианты, то вы увидите, что переполнение в этой команде нигде не может произойти.
То есть такой незаконный вопрос.
На первый взгляд кажется, а как она обрабатывает переполнение?
Ответ его не бывает.
То, что у нас слова со знаком умножаются.
А потом складываются две пары таких результатов.
Приводит к тому, что результат не может переполнится.
И выйти за двор со знаком.
И никаких других умножений нет.
То есть, например, умножить гвардейс или умножить байты.
Таких команд просто нет.
Что вы думаете про деление?
Его нет.
Никакого вам деления.
В качестве деления, что предлагается использовать?
Tick score.
Tick score.
Сдвиги.
Сдвиги у нас есть.
Что за сдвиги у нас есть?
У нас есть сдвиги логические.
P, S, L, L.
V, D, Q.
P, S, R, L.
V, D, Q.
И P, S, R, A.
V, D.
Вот такие формы сдвигов у нас есть.
Для байтов сдвигов нет?
Да.
К сожалению, для байтов и сдвигов нет.
Это довольно больно.
А где может быть?
То есть, ты решил посчитать среднее арифметическое.
Вот.
Вот такие есть сдвиги.
И, видите, арифметически
кварда не существует.
То есть, вы можете, в принципе,
иногда считать регистр 64-битным числом.
Но это будет не очень число.
Это будет просто набор битиков.
Все битики вы можете подвинуть.
Но как только возникает какая-то арифметика,
максимум борт.
То есть, у вас нет команды сложения квардов
или еще чего-нибудь.
Вся арифметика максимум борт.
Вот. Это сдвиги.
Поэтому, если вам нужно уделение,
то деление вы получаете через фиксированную точку
умножение на что-то,
а потом сдвиг как деление на степень борт.
Вот такой деление.
Что у нас есть дальше?
Дальше есть обычные команды битовых,
которые вы ожидаете.
Это
P-and,
P-or,
P-sort.
Что?
P-not, P-next, P-next.
Не особо.
P-xor, как вы можете догадаться,
ваша любимая команда.
Почему?
Да, чтобы обновить регистр.
Никакой MOV0 теперь не пройдет.
А P-sort?
Это удобно.
P-xor — это ваша команда для обновления регистра,
особенно в отсутствие констант.
Из интересного есть еще команда P-and.
P-and.
Было это полезно.
Но это не команда I-next.
Это может показаться.
Вспоминаем архитектуру.
Это I с нотом N.
По английской нотации N стоит не там,
где происходит инверсия.
То есть P-and-next вначале инвертирует один из аргументов,
а потом делает N.
Он инвертирует тот аргумент, который хочется.
По-моему, это первый.
То есть я не четко помню, какой он инвертирует.
Но когда ты пишешь, и эта команда нужна,
он инвертирует ровно тот аргумент, который тебе хочется инвертировать.
У меня это обычно второй.
Ну вот, по-моему, первый.
И мне хочется инвертировать первый.
Посмотрите документацию.
Первый, да?
Первый?
Да.
Вот.
Просто у меня такое встречается,
когда мне нужно эндить с нотой какого-то значения.
А можно его заранее нотнуть и тогда уже снимать?
Нет, заранее нотить нечего.
Нет, я не про это.
Я про то, что если нужно, то со вторым нотом.
Ну что, не понял?
Не надо.
Все равно непонятно.
Обратите внимание на эту команду.
Весьма полезная команда.
И еще...
Эксченж есть?
Нет.
Если ты хочешь что-то эксченжить, то либо через третий регистр,
что обычно делают,
ну, либо ты можешь превращаться с любимой версией через несколько сорок.
Но обычно такой необходимости нет.
Зачем тебе эксченжить регистры?
Просто ты, начиная с этого момента, переименовываешь...
Регистр очень большой НОП.
НОП?
Ну, как бы, от того, что ты делаешь его на MMX лучше не станет.
То есть ты, конечно, можешь делать НОП Q регистр, запятая регистр.
Но это тоже не будет НОП.
Потому что оно тебе весь этот процессор порушит.
То есть как бы НОП на MMX сделать проблемно.
Любой чик на MMX
убивает тебя с процессора.
Поэтому оно не будет НОП.
Почему на MMX делать?
Зачем?
Вот я говорю, что...
Непонятно зачем.
И даже если и есть зачем, то оно не очень получится.
Поэтому идея сделать НОП на MMX неосмысленна.
Так.
Так, вопрос.
НОП большого размера по сравнению с местными НОПами лучше тем, что...
Он всего одна команда?
Да.
Меньше тратит декодера.
Если у тебя там в равнине, скажем, на 16 байтиков,
и тебе нужно вставить 15 байтиков,
то НОПы, конечно, легкая команда.
Но все-таки 15 НОПов не такая уж и легкая команда.
15 команд, которые нужно исполнить.
Поэтому существуют сейчас специальные многобайтные формы НОПов.
Это специальные обкоды,
по которым гарантируется,
что они исполняются как НОП.
И если вы попросите ваш ассемблер
командой align
выровнять вам следующий адрес
до кратности, чего вы там просили,
например, скажите align 16,
то вам ассемблер воткнет,
ну, как он там считает,
оптимальную комбинацию НОПов.
И там правило, как его НОПы втыкают,
оно немножко отличалось со временем.
Но оно можно использовать действительно на байтные НОПы.
То есть действительно на байтные НОПы.
То есть какие они там байтов доходят, не помню,
на 8-ми, 8-ми.
То есть такие довольно жирненькие,
чтобы буквально парочке НОПов можно было занять 15 байтиков.
А в равнину больше, чем на 16,
обычно не требуется.
Ну, не очень критично.
Ну, не код.
Вообще не код.
Продолжаем.
Что у нас есть еще из команд?
У нас есть команды сравнения.
Команды сравнения.
У нас есть две.
P, K, M, P, E, Q.
B, V, D.
И P, K, M, P, G, T.
Так, E, Q, E, D.
К...
А, да, E, Q ты описал.
E, Q.
E, Q.
E, Q.
B, B, D.
Как эти команды работают?
Как я вам уже спойлерил,
никаких флагов никто никуда не ставит.
Поэтому что значит сравнение?
Сравнение пишет результат туда же.
Первый аргумент.
И такого же размера, как и ваши входные данные.
Результат следующий.
Если условие команды не выполнено,
то в результате вы получите в этой порции нолик.
То есть сравнение происходит независимо по байтикам,
по вардам или под вардам.
Условия не выполнены, не равны,
значит нолик в этой позиции.
Если условие выполнено,
то вы получаете минус один.
Минус один это все единички.
На самом деле использование минус один в качестве true
в языках программирования встречается.
Например, в Basic true это минус один.
И честно говоря, это лучше и удобнее, чем один.
Вот в C постулировали, что true это один.
Ну, бывает.
С этим уже ничего не сделать.
Но технически удобнее на самом деле,
когда true минус один.
И здесь true как раз минус один, true все единички.
Обратитесь на это внимание.
Eq это сравнение на равенство.
gt это строго больше,
притом строго больше, как числа со знаком.
Значение интерпретируется как число со знаком.
Если первый аргумент строго больше второго,
то в этой позиции ставятся все единички,
иначе в этой позиции все нольки.
И у нас осталась одна единственная команда ММХ
до полного набора.
Это команда E-ММС.
Кто догадается, что делает эта команда?
Говорит, что ЭКПУ не занят.
Эта команда помечает все регистры ЭКПУ как свободные.
Потому что любая другая команда ММХ помечает все как занятое,
а по конвенции вызова не забываем,
ЭКПУ в конце функции должен быть свободен,
если вы не возвращаетесь.
И результат на вершине,
остальное свободно,
если вы возвращаете результат через ЭКПУ.
Поэтому, если вы пишете на ММХ,
не забывайте в конце вашей функции
ставить ЕММС.
Если вы этого не сделаете,
вы испортите жизнь тому,
кто использует ЭКПУ.
Потому что у него полезут наны,
так как он будет пытаться читать,
стэк занят,
поэтому стэк будет заполняться нанами.
Эта команда относительно легкая,
но не надо вставить ее в цикл.
То есть это команда для окончания функции,
которую использует ЭММС.
Если вы не уверены,
что внешняя функция не использует тоже ЭММС,
если у вас ММХ функция вызывает ММХ функцию,
то конечно вы во внутренней функции
может не ставите ЕММС,
внешняя тут же займет ЭКПУ снова.
Но если вы возвращаетесь куда-то в окружающий мир,
то вот здесь ЕММС нужен.
Понятно?
Ну и давайте что-нибудь напишем,
как я уже сказал, это полный набор команд.
Давайте, например, напишем следующее.
Есть у нас два массивчика А и В,
и я хочу построить третий массивчик С,
который содержит по элементной максимум.
Притом входные массивчики,
для простоты,
это будут байты со знаком.
То есть у вас есть функция,
которая принимает три указателя.
А, В, С.
И принимает N,
размер этих массивов в элементах,
элементы массивов,
байты со знаком.
Вот сразу вы начинаете чувствовать,
здесь как-то быть можете.
В реальности нет этого.
И в реальности одно из основных страданий
написания кода на СИН
это обработка краешков.
Вам нужно написать не просто основной алгоритм в середине,
а еще и правильно обработать края,
размер которых может быть какой угодно.
Почему те же самые картинки
народ любит постулировать,
что ширина должна быть кратной четырем,
и всякое такое.
Возможно, вы слышали.
Потому что это сильно снижает
количество специальных случаев,
которые вам нужно рассмотреть.
Если вы знаете, что ширина картинки
кратна четырем,
вот не надо рассматривать,
а что если там нечетное количество фиксивов.
А если там три поможет быть четыре,
и всякое такое.
То есть здесь как бы простой вариант.
Да, считайте, что n кратно восьмидесяти.
Хотите посложнее,
считайте, что n произвольное значение.
Ну и сразу почувствуйте рисунок.
Смотрите, что у меня.
Ну что, еще раз нам осталось.
Нужно найти, заполнить массив С,
по элементным максимум значениям а и b.
То есть С нулевое должно быть максимумом
из а нулевого и b нулевого.
Да, функция принимает три указателя
на а на b на С и размер трех элементов.
Ну и карта тоже самая.
Простое задание.
Размер красного свинья.
Сложное задание.
Размер произвольного.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
Что у вас 32, что 64 будет влиять только на конвенцию и, как называется, ваше диск.
Вашу, может быть, спорт будет активно.
Так что здесь совсем не зависит.
Спасибо.
Спасибо.
Спасибо.
Спасибо.
Спасибо.
Спасибо.
Спасибо.
Спасибо.
Спасибо.
Спасибо.
Спасибо.
Спасибо.
Спасибо.
Спасибо.
Спасибо.
Спасибо.
Спасибо.
Спасибо.
Спасибо.
Спасибо.
Спасибо.
Спасибо.
Спасибо.
Спасибо.
Спасибо.
Спасибо.
Спасибо.
Спасибо.
Спасибо.
Ребята, здравствуйте.
Здесь надо подыгрывать.
Проверить надо?
Нет, проверить, потому что до этого не было.
А, ну тогда тоже подыгрывать надо.
Проверить надо.
Проверить надо.
У нас же по байтам одно было.
Да, тоже самое.
Нет, я имею в виду по байтам первым.
Я же сказал, что в нулевой элемент результата нужно положить максимум из нулевых элементов a и b.
Я понял.
Нужно быть Stephen-ly.
Что такое?
Ну, по-моему,law-till.
Лоловцам в submitting.
Нужно?
Чего?
Чего имtiт!!!!!
Не, я statewide, говорил.
Как local, я из западных стран.
Скажите, investigating?
Да.
Нет, шо?
А там waste level, не факт.
Н administrated by zombies burning us.
cruelty.
Нужно было для этого.
Продолжение следует...
Продолжение следует...
Продолжение следует...
Продолжение следует...
Продолжение следует...
Продолжение следует...
Продолжение следует...
Продолжение следует...
Продолжение следует...
Продолжение следует...
Продолжение следует...
Продолжение следует...
Продолжение следует...
