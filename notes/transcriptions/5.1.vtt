WEBVTT

00:00.000 --> 00:27.360
Динамическая библиотека была реализована следующим образом, что во время запуска вашей программы, вот эти вот связи имя символа с положением, они просматриваются в вашем коде и в динамических библиотеках так, как будто у вас происходит линковка.

00:27.360 --> 00:39.520
То есть динамические библиотеки, скажем, вот вы вызываете принт, и вы сказали, что вы компилируетесь с C-шной библиотекой, динамически с ней связываете.

00:40.380 --> 00:47.360
То есть это не вкомпилируется в вас, а вы получаете зависимость от стандартной библиотеки в виде библиотеки.

00:49.360 --> 00:51.740
То, что называется SO-shared object.

00:51.740 --> 00:56.580
Так вот, этот принт, он просматривается.

00:57.360 --> 00:58.400
Снаружи.

00:59.720 --> 01:03.180
И просматривается очень похоже на линковку.

01:04.140 --> 01:09.500
Под виндой я говорил, есть понятие таблица импорта, таблица экспорта.

01:10.080 --> 01:19.280
И скомпилированный файлик, он какой-нибудь там принт, он берет ровно из конкретной дейлелки.

01:20.000 --> 01:26.540
Сказано, что вот у нас есть символ print, он берется из этой дейлелки.

01:27.360 --> 01:29.840
В линуксе принципиально не так.

01:30.660 --> 01:39.020
Там сказано, что ваш исполняемый файл, он хочет вот такую библиотеку и вот такую библиотеку.

01:39.480 --> 01:40.180
Просто хочет.

01:42.020 --> 01:43.620
Не сказано, что он от них хочет.

01:44.100 --> 01:45.680
Просто хочет такую библиотеку.

01:46.400 --> 01:53.140
А потом, когда возникает потребность найти принт, запускается просмотр в режиме.

01:53.140 --> 01:56.720
Вначале посмотрим, а нет ли реализации принта.

01:57.360 --> 01:58.580
Нашим же экзешники.

01:59.880 --> 02:01.300
А вдруг есть?

02:02.620 --> 02:04.680
Если есть, тогда его и возьмем.

02:04.900 --> 02:05.800
Во время исполнения?

02:06.060 --> 02:07.980
Да, во время исполнения.

02:09.340 --> 02:13.920
Для простоты давай считаем во время загрузки твоего.

02:14.620 --> 02:20.780
На самом деле нам чуть хитрее, но для начала, чтобы во время того, когда твой файл загружается на исполнение,

02:20.780 --> 02:26.700
происходит вот такая связь символных имен и фактического положения.

02:28.180 --> 02:37.960
То есть просматриваются вначале ваш исполняемый файл, потом просматриваются библиотеки в некотором порядке.

02:38.260 --> 02:42.400
В порядке во-первых, вот как они указаны, Tier 1.

02:42.540 --> 02:43.980
В зависимости .

02:43.980 --> 02:49.600
Потом, эти динамические библиотеки, они же могут тоже требовать какие-то библиотеки.

02:50.300 --> 02:55.220
Вот эти библиотеки, которые они требуют, они добавляются в список потом.

02:55.520 --> 02:56.620
То есть, этот список такой that means, there is five biblios.

02:56.620 --> 03:07.980
список такой сложный, это мультисписок. У вас список, состоящий из списков, копии символы

03:07.980 --> 03:17.000
экспортируются в каждой библиотеке. И эти списки, они просматриваются как линкер в определенном

03:17.000 --> 03:25.580
порядке. То есть, чтобы найти какой-то символ, вы обязаны просматривать списки в определенном

03:25.580 --> 03:32.480
порядке. Системный загрузчик не может посмотреть на все ваши динамические библиотеки,

03:32.840 --> 03:41.960
составить из них список, что там оно в целом имеет, и в этом списке искать. Так нельзя. Потому что,

03:42.180 --> 03:51.460
если у вас какой-то символ экспортируется из нескольких библиотек, то это неопределенный. Нужно

03:51.460 --> 03:55.460
выбрать его в той библиотеке, которая окажется...

03:55.580 --> 04:06.760
Это заключается в первой, вот в этом списке «верхнего оружия». Это заморочка номер один. То есть, вот это вот динамическое

04:06.760 --> 04:22.380
связывание, оно супердорогое. Потому что, вам нужно просмотреть кучу неупорядоченных списков. И что самое фиговое, это то, что вот эти вот

04:22.380 --> 04:25.320
динамические связи

04:25.580 --> 04:33.880
Они по умолчанию работают для всех глобально видимых имен.

04:34.720 --> 04:44.760
Другими словами, у вас все функции и переменные, которые видны снаружи вашего файла,

04:44.820 --> 04:50.980
то есть которые не станут, они все одновременно экспортируются и импортируются.

04:50.980 --> 05:00.980
То есть, если у вас есть какая-то функция в файлике, которая вызывает другую функцию в этом файлике,

05:01.800 --> 05:12.080
и они не статик, то модель Linux не уверена, а нужно ли действительно эту функцию вызывать.

05:13.460 --> 05:16.980
Потому что если у вас все это происходит в динамической библиотеке,

05:16.980 --> 05:20.960
и вот эта вторая функция, которую вы вызываете,

05:20.980 --> 05:25.980
то в данном случае, пусть с таким же именем функция оказалась в исполняемом файле.

05:27.620 --> 05:33.460
Это означает, что вы должны вызвать не свою функцию, которая в этом же файлике,

05:34.080 --> 05:37.980
а функцию с таким же именем, которая в экзешнике.

05:40.040 --> 05:42.840
То есть, если в библиотеке будет функция как бы Foo,

05:43.160 --> 05:45.620
то в нашем файле это будет именно она.

05:45.700 --> 05:48.080
То есть у тебя там есть Foo и Var в библиотеке,

05:48.700 --> 05:50.880
вот у тебя Var вызывает Foo.

05:50.980 --> 05:54.400
Оно описано в одном C-файлике.

05:55.360 --> 05:59.660
Но функция Foo также случилась в исполняемом файлике.

06:00.260 --> 06:04.200
И твоя библиотека должна вызвать функцию не свою Foo,

06:04.640 --> 06:07.280
а вот ту, которая в исполняемом файлике.

06:07.680 --> 06:10.800
В таком случае, как поиск, то есть он выглядит при моменте загрузки.

06:10.800 --> 06:11.200
Вот именно.

06:11.380 --> 06:15.840
Вот оно рассматривает на каждый глобальный символ,

06:16.420 --> 06:17.880
рассматривает, где он.

06:18.180 --> 06:20.880
Начиная с исполняемого файлика.

06:20.980 --> 06:24.120
И дальше вот в том порядке, в котором я описал.

06:24.800 --> 06:26.220
Как вы можете догадаться,

06:26.540 --> 06:29.980
это просто на корню убивает кучу всяких оптимизаций.

06:32.840 --> 06:33.540
А если LTO?

06:34.560 --> 06:36.860
Даже LTO здесь не очень помогает.

06:37.900 --> 06:41.840
Фанаты Линукса рекомендуют посыпать все статиками.

06:42.420 --> 06:44.200
Типа, если сказать статик,

06:44.540 --> 06:46.560
тогда эта функция снаружи не видна,

06:46.980 --> 06:50.300
поэтому она через всю вот эту вот артскую систему не проходит.

06:50.980 --> 06:52.980
Ну, с одной стороны, это правда,

06:52.980 --> 06:55.480
с другой стороны, они не забывают кое-что добавить.

06:55.980 --> 06:59.980
Что нужно не просто все функции, которые снаружи не нужны,

06:59.980 --> 07:01.480
называть статик.

07:01.480 --> 07:05.480
Вы еще должны всю свою программу написать в одном файле.

07:06.480 --> 07:07.980
Так, честно говоря.

07:08.740 --> 07:12.740
Потому что, если вы пишете программу больше, чем в одном файле,

07:14.740 --> 07:16.740
то статик вам не поможет.

07:16.740 --> 07:19.740
Потому что вы должны видеть свои функции из другого файла.

07:19.740 --> 07:20.740
И вся вот эта вот...

07:20.740 --> 07:23.740
ересь с поиском непонятной какой функции,

07:23.740 --> 07:25.740
она не исключается.

07:26.740 --> 07:27.740
Слышишь, вопрос?

07:27.740 --> 07:28.740
Можно починить флагом 1 гигант?

07:28.740 --> 07:29.740
Флаг 1.

07:29.740 --> 07:31.740
У нас, ну, опять же, две функции.

07:31.740 --> 07:33.740
Также Foo и Bar.

07:33.740 --> 07:35.740
Bar вызывает Foo, который статик.

07:35.740 --> 07:36.740
В этот раз, то есть, она уже...

07:36.740 --> 07:37.740
Ну, у нас передана также функция Foo, которая...

07:37.740 --> 07:39.740
Да, раз она статик,

07:39.740 --> 07:41.740
то компилятор понимает,

07:41.740 --> 07:43.740
что у тебя вот эта функция.

07:44.740 --> 07:45.740
То есть, еще раз.

07:46.740 --> 07:49.740
Все экспортируются и все импортируются,

07:50.740 --> 07:53.740
только функции, которые имеют внешнюю видимость.

07:54.740 --> 07:56.740
Если функции снаружи не видно,

07:56.740 --> 07:59.740
то она не импортируется, не экспортируется.

07:59.740 --> 08:02.740
Вот поэтому компилятор видит, что вот это она,

08:02.740 --> 08:05.740
поэтому я могу прямо превратить имя

08:05.740 --> 08:08.740
в адрес на этапе компиляции.

08:09.740 --> 08:11.740
Но вот неприятный момент,

08:11.740 --> 08:13.740
что такой классический вариант,

08:13.740 --> 08:15.740
что все глобальные функции,

08:16.740 --> 08:19.740
они все экспортируются и все импортируются.

08:20.740 --> 08:23.740
То есть, когда они импортируются,

08:23.740 --> 08:25.740
это очень медленно,

08:25.740 --> 08:27.740
а когда они экспортируются,

08:27.740 --> 08:30.740
у вас получаются огромные таблицы экспорта.

08:30.740 --> 08:32.740
То есть, вот эти вот списки,

08:32.740 --> 08:33.740
где нужно искать,

08:33.740 --> 08:35.740
они еще суперогромные.

08:36.740 --> 08:38.740
Потому что у вас все функции,

08:38.740 --> 08:40.740
которые имеют глобальную видимость,

08:40.740 --> 08:41.740
которые не статик,

08:41.740 --> 08:43.740
они все там дружно торчат.

08:45.740 --> 08:47.740
Вот такая вот фигня.

08:50.740 --> 08:53.740
Замечание скорее по поводу множественных определений.

08:53.740 --> 08:57.740
На самом деле сейчас линкеры по дефолту падают,

08:57.740 --> 09:00.740
если у тебя множественное определение.

09:00.740 --> 09:02.740
Нет, нет, нет.

09:02.740 --> 09:03.740
Еще раз.

09:03.740 --> 09:04.740
Зависит от того,

09:04.740 --> 09:07.740
как возникло это множественное определение.

09:07.740 --> 09:10.740
Библиотеки, ну то есть библиотеки,

09:10.740 --> 09:14.740
они состоят из набора объектных файлов,

09:15.740 --> 09:18.740
которые получили в результате компиляции.

09:18.740 --> 09:19.740
И как с этим?

09:19.740 --> 09:20.740
Погоди.

09:20.740 --> 09:22.740
Вот как я вам описал,

09:22.740 --> 09:28.740
что линкер, он просматривает библиотеку,

09:28.740 --> 09:30.740
но не целиком библиотеку,

09:30.740 --> 09:33.740
а он перебирает объектные файлы.

09:34.740 --> 09:38.740
Соответственно, если какой-то объектный файл,

09:38.740 --> 09:40.740
вот он случился,

09:40.740 --> 09:42.740
что он описывает какой-то символ,

09:42.740 --> 09:44.740
который нужен линкеру,

09:45.740 --> 09:47.740
то этот объектный файл,

09:47.740 --> 09:49.740
он добавляется к списку объектных файлов.

09:49.740 --> 09:52.740
То есть все символы,

09:52.740 --> 09:53.740
которые он резолвит,

09:53.740 --> 09:55.740
они резолвятся.

09:55.740 --> 09:57.740
А какие ему нужны,

09:57.740 --> 10:00.740
они добавляются в список на то,

10:00.740 --> 10:02.740
что их нужно резолвить.

10:02.740 --> 10:05.740
И если в результате такого добавления

10:05.740 --> 10:09.740
ваш объектный файл будет определять

10:09.740 --> 10:10.740
какой-то символ,

10:10.740 --> 10:11.740
то есть...

10:11.740 --> 10:18.740
...

10:18.740 --> 10:21.740
Если ваш объектный файл будет определять

10:21.740 --> 10:22.740
какой-то символ,

10:22.740 --> 10:25.740
который уже определен где-то в другом файле,

10:26.740 --> 10:30.740
то это в классической модели ошибка линковки.

10:30.740 --> 10:32.740
У вас есть несколько символов

10:32.740 --> 10:34.740
с одинаковым именем.

10:35.740 --> 10:36.740
Поэтому,

10:36.740 --> 10:40.740
если у вас какой-то объектный файл

10:40.740 --> 10:42.740
в библиотеке,

10:42.740 --> 10:43.740
в другой библиотеке,

10:43.740 --> 10:45.740
в этой же библиотеке,

10:45.740 --> 10:48.740
определяет символ с таким же именем,

10:50.740 --> 10:52.740
но больше ни за чем не нужен,

10:52.740 --> 10:54.740
то это не будет ошибкой линковки.

10:56.740 --> 10:59.740
То есть объектные файлы из библиотеки,

10:59.740 --> 11:03.740
они не все добавляются в рассмотрение.

11:03.740 --> 11:05.740
Они перебираются,

11:05.740 --> 11:07.740
и если этот файлик полезен,

11:07.740 --> 11:08.740
то он включается.

11:08.740 --> 11:09.740
Если он не полезен,

11:09.740 --> 11:11.740
он не добавляется.

11:14.740 --> 11:16.740
Понятно, не понятно?

11:17.740 --> 11:19.740
То есть такая небольшая особенность,

11:19.740 --> 11:20.740
что вот,

11:21.740 --> 11:24.740
если вы запихаете объектные файлы в библиотеку,

11:24.740 --> 11:26.740
будет не то же самое,

11:26.740 --> 11:29.740
что это просто перечислить все в командной строчке.

11:29.740 --> 11:31.740
Потому что в командной строчке

11:31.740 --> 11:34.740
они все форсированно добавляются в программу.

11:34.740 --> 11:37.740
И если у вас там случается multiple definition,

11:37.740 --> 11:38.740
то это ошибка.

11:39.740 --> 11:42.740
Если же у вас в библиотеке оказывается,

11:42.740 --> 11:46.740
что несколько файликов описывают один и тот же символ,

11:46.740 --> 11:52.740
но необходимости взять их нету,

11:52.740 --> 11:55.740
то это не будет ошибкой.

11:55.740 --> 11:57.740
Это точно не необходимость взять?

11:57.740 --> 11:58.740
Ну еще раз.

11:58.740 --> 12:01.740
Линкед рассматривает библиотеку ради чего?

12:01.740 --> 12:03.740
Ради того, чтобы зарезовывать какие-то символы,

12:03.740 --> 12:05.740
которые не зарезованы.

12:05.740 --> 12:06.740
Ну да.

12:06.740 --> 12:08.740
Поэтому если этот объектный файл,

12:08.740 --> 12:10.740
ничего из этого не определяет,

12:10.740 --> 12:12.740
то он скипается.

12:15.740 --> 12:18.740
То есть если он не описывает никакой символ,

12:18.740 --> 12:20.740
который линкеру нужен,

12:20.740 --> 12:22.740
то он пропускается.

12:22.740 --> 12:25.740
Он добавляется в рассмотрение линкером,

12:25.740 --> 12:27.740
только если он описывает что-то,

12:27.740 --> 12:29.740
что линкеру нужно.

12:30.740 --> 12:33.740
Ничего не описывает, пропускается.

12:34.740 --> 12:36.740
Речь идет именно про

12:36.740 --> 12:39.740
файлы .d и .a файл.

12:39.740 --> 12:41.740
Да.

12:41.740 --> 12:45.740
Если указать минус стрель двоеточие файл .o,

12:45.740 --> 12:47.740
он будет форсирован.

12:47.740 --> 12:50.740
l двоеточие...

12:50.740 --> 12:53.740
Без понятия, что будет из стрел двоеточия.

12:53.740 --> 12:56.740
Если вы скормите объектные файлы

12:56.740 --> 12:59.740
вот просто именами,

12:59.740 --> 13:01.740
без всяких l,

13:01.740 --> 13:04.740
то оно форсировано и добавляет все.

13:04.740 --> 13:05.740
Про l не знаем.

13:05.740 --> 13:08.740
Получается, что .a это архив объектов,

13:08.740 --> 13:10.740
и они друг о друге не знают.

13:10.740 --> 13:11.740
Еще раз.

13:11.740 --> 13:14.740
Они обрабатываются не совсем так,

13:14.740 --> 13:16.740
как обрабатываются,

13:16.740 --> 13:18.740
если вы эти объектные файлы

13:18.740 --> 13:20.740
укажете явно линкеру или компилятору.

13:20.740 --> 13:23.740
Я думаю, что про multiple definition error нет,

13:23.740 --> 13:25.740
потому что, когда мы делаем архив,

13:25.740 --> 13:27.740
мы просто перечисляем объектники,

13:27.740 --> 13:29.740
и они друг о друге ничего не знают.

13:29.740 --> 13:31.740
Нет, не то, что они не знают.

13:31.740 --> 13:33.740
Они не используются.

13:33.740 --> 13:34.740
То есть,

13:34.740 --> 13:36.740
все объектные файлы,

13:36.740 --> 13:38.740
которые явно указаны компилятору или линкеру,

13:38.740 --> 13:41.740
они все используются.

13:41.740 --> 13:44.740
А я про момент создания архива.

13:44.740 --> 13:47.740
На создание архива не происходит линковки.

13:47.740 --> 13:48.740
Ну да, да, да.

13:48.740 --> 13:50.740
Нет, я говорю, что компиляция

13:50.740 --> 13:53.740
и указание объектных файлов явно,

13:53.740 --> 13:55.740
и указание их в виде набора в библиотеке

13:55.740 --> 13:57.740
работают не одинаково.

13:57.740 --> 13:58.740
Ну да, да.

13:58.740 --> 14:01.740
И вот всякие вот эти особенности поведения,

14:01.740 --> 14:02.740
они

14:02.740 --> 14:05.740
попытались под Linux максимально

14:05.740 --> 14:09.740
повторить для динамических библиотек.

14:09.740 --> 14:13.740
Хотя, честно говоря, особой необходимости в этом не было.

14:13.740 --> 14:16.740
Почему динамические библиотеки должны вести себя

14:16.740 --> 14:19.740
со всеми прибамбасами статических библиотек?

14:19.740 --> 14:21.740
Не совсем понятно.

14:21.740 --> 14:23.740
Ну, в общем, мы имеем, что имеем.

14:23.740 --> 14:29.740
И вот вся эта конструкция с импортами и экспортами,

14:29.740 --> 14:31.740
честно говоря, выглядит очень паршиво.

14:32.740 --> 14:34.740
Потому что, еще раз,

14:34.740 --> 14:37.740
она очень медленно работает,

14:37.740 --> 14:40.740
потому что ищется чертово знает где,

14:40.740 --> 14:42.740
чертово знает что.

14:42.740 --> 14:45.740
И, во-вторых,

14:45.740 --> 14:49.740
у вас очень получаются большие, жирные,

14:49.740 --> 14:53.740
исполняемые файлы и библиотеки,

14:53.740 --> 14:57.740
потому что у вас куча всего экспортируется,

14:57.740 --> 15:01.740
что вы, может, совершенно не хотели экспортировать.

15:02.740 --> 15:04.740
Так еще раз.

15:04.740 --> 15:07.740
Статик – это заправка.

15:07.740 --> 15:13.740
Честно говоря, ты хочешь не просто написать статик,

15:13.740 --> 15:15.740
а все написать в один файл.

15:15.740 --> 15:16.740
Ну да.

15:16.740 --> 15:18.740
Ну это фигня.

15:18.740 --> 15:19.740
Ну фигня.

15:19.740 --> 15:20.740
Ну а что делать?

15:20.740 --> 15:21.740
Ну вот не делать так.

15:21.740 --> 15:23.740
Там есть какие-то еще атрибуты, да?

15:23.740 --> 15:24.740
Да.

15:24.740 --> 15:27.740
Это вот такая исходная модель, которая была.

15:27.740 --> 15:30.740
Всякие изменения, которые там произошли, похожи.

15:30.740 --> 15:32.740
Но пока вот база происходящая.

15:32.740 --> 15:34.740
Как флажок, мне кажется, есть какая-то компиляция,

15:34.740 --> 15:35.740
которая говорит?

15:35.740 --> 15:38.740
Ну вот там куча всяких флажков по этому поводу.

15:38.740 --> 15:41.740
Потому что оно явно подгорает у народа,

15:41.740 --> 15:43.740
как оно предлагает,

15:43.740 --> 15:45.740
и по этому поводу есть разные флажки,

15:45.740 --> 15:47.740
как сделать, чтобы оно менее подгорано,

15:47.740 --> 15:49.740
но работало не совсем так,

15:49.740 --> 15:52.740
и начинаются дальше хулевары,

15:52.740 --> 15:54.740
что там делать, что не делать.

15:54.740 --> 15:56.740
А действительно ли вот именно этого?

15:56.740 --> 15:59.740
Ну на компиляцию разве не оптимизация больше влияет?

15:59.740 --> 16:00.740
То есть это не так дороже?

16:00.740 --> 16:01.740
Еще раз.

16:01.740 --> 16:03.740
Это супер бьет по оптимизации.

16:03.740 --> 16:04.740
Не-не-не.

16:04.740 --> 16:06.740
Я думаю, что в целом вот

16:06.740 --> 16:08.740
само влияние оптимизации уже того, что у нас есть,

16:08.740 --> 16:10.740
оно будет дольше, чем вот это.

16:10.740 --> 16:11.740
Разве нет?

16:11.740 --> 16:12.740
Ничего не понимаю.

16:12.740 --> 16:13.740
Так еще раз.

16:13.740 --> 16:15.740
Мы говорим, когда моя программа уже скомпилирована,

16:15.740 --> 16:17.740
и она запускается,

16:17.740 --> 16:22.740
она в рантайме как бы в некотором смысле докомпилируется.

16:22.740 --> 16:23.740
Так это вы про динамические,

16:23.740 --> 16:25.740
мы сейчас про статические еще говорили.

16:25.740 --> 16:27.740
А динамические работают как статические?

16:27.740 --> 16:28.740
Да.

16:29.740 --> 16:32.740
Что вот эта вот вся фигня с их сложным поведением,

16:32.740 --> 16:37.740
это было унаследовано от статических библиотек.

16:37.740 --> 16:40.740
То есть это сложное поведение,

16:40.740 --> 16:42.740
это попытка повторить того,

16:42.740 --> 16:50.740
как работают статические библиотеки на этапе линковки.

16:50.740 --> 16:52.740
Вот эти все странные списки,

16:52.740 --> 16:55.740
порядок просмотров и все вот это вот,

16:55.740 --> 16:58.740
это все проистекает от статических библиотек.

16:59.740 --> 17:06.740
И вот про что.

17:06.740 --> 17:07.740
Так а что за рантайм?

17:07.740 --> 17:08.740
Мне говорят рантайм.

17:08.740 --> 17:09.740
Какой рантайм?

17:09.740 --> 17:10.740
Так рантайм, да.

17:10.740 --> 17:12.740
Когда программа загружается,

17:12.740 --> 17:15.740
вот эта связь, когда...

17:15.740 --> 17:17.740
Это компайл тайм, это линковка.

17:17.740 --> 17:18.740
Да нет, это не компайл тайм.

17:18.740 --> 17:20.740
Так говори статические библиотеки.

17:20.740 --> 17:21.740
Динамические работают так же.

17:21.740 --> 17:23.740
Так нет, ну знаешь про статические еще говорить?

17:23.740 --> 17:24.740
Ну?

17:24.740 --> 17:27.740
Это же не в рантайме, это в компайл тайме линковка.

17:27.740 --> 17:28.740
Она все равно не до линковка.

17:28.740 --> 17:34.740
Вот у тебя есть вызов функции какой-то по имени,

17:34.740 --> 17:36.740
которая не статик функция.

17:36.740 --> 17:37.740
Так.

17:37.740 --> 17:40.740
Вот этот вызов по имени,

17:40.740 --> 17:42.740
кого он вызывает,

17:42.740 --> 17:45.740
оно, к сожалению,

17:45.740 --> 17:48.740
не компайл тайм.

17:48.740 --> 17:50.740
Мне кажется, что...

17:50.740 --> 17:51.740
Потому что...

17:51.740 --> 17:52.740
Это с пиком будет.

17:52.740 --> 17:53.740
Нет.

17:53.740 --> 17:55.740
Еще раз, сама идея,

17:55.740 --> 17:58.740
что вот это куда мы вызываем,

17:58.740 --> 18:03.740
это нужно завизовывать по вот этим правилам.

18:03.740 --> 18:05.740
Вот эти правила работают,

18:05.740 --> 18:07.740
когда программу загружают,

18:07.740 --> 18:09.740
то есть это рантайм.

18:09.740 --> 18:12.740
Сейчас, программа это...

18:12.740 --> 18:13.740
Целиком все.

18:13.740 --> 18:15.740
И сам исполняемый файл,

18:15.740 --> 18:19.740
и библиотеки, которые там она использует.

18:19.740 --> 18:22.740
Вот весь этот код, он собирается,

18:22.740 --> 18:24.740
по большому счету,

18:24.740 --> 18:26.740
в рантайме.

18:28.740 --> 18:31.740
Ну, вот я приводил пример.

18:31.740 --> 18:33.740
Я не понимаю, почему в рантайме.

18:33.740 --> 18:35.740
Вот у вас исполняемый файл.

18:35.740 --> 18:38.740
Вот здесь случилась функция фу.

18:38.740 --> 18:40.740
Да.

18:40.740 --> 18:45.740
Этот файл использует какую-то динамическую библиотеку.

18:45.740 --> 18:46.740
Так мы же про статический говорим.

18:46.740 --> 18:48.740
Почему мы про динамическую будем говорить?

18:48.740 --> 18:53.740
Потому что динамические работают как статические.

18:53.740 --> 18:54.740
Еще раз.

18:54.740 --> 18:56.740
Я тебе третий раз повторяю эту фразу.

18:56.740 --> 18:57.740
Хорошо.

18:57.740 --> 18:58.740
Слева.

18:58.740 --> 19:00.740
Оно еще получается недокомпилированным.

19:00.740 --> 19:01.740
Подожди.

19:01.740 --> 19:02.740
Вот справа.

19:02.740 --> 19:04.740
Вот здесь у нас SO.

19:04.740 --> 19:06.740
Я понимаю.

19:06.740 --> 19:11.740
Вот здесь у нас есть функция var,

19:11.740 --> 19:15.740
которая пытается вызвать функцию фу.

19:15.740 --> 19:16.740
Это я понял.

19:16.740 --> 19:18.740
Он вызовет вот эту фу слева.

19:18.740 --> 19:19.740
Это понятно.

19:19.740 --> 19:21.740
Что понятно-то?

19:21.740 --> 19:22.740
Я к тому, что...

19:22.740 --> 19:23.740
Погоди.

19:23.740 --> 19:24.740
Ничего понятного не понятно.

19:24.740 --> 19:26.740
Если у нас нет зависимости от SO,

19:26.740 --> 19:27.740
то это не SO.

19:27.740 --> 19:28.740
Да нет SO.

19:28.740 --> 19:29.740
Я говорю, смотрим на SO-файл.

19:29.740 --> 19:30.740
Вот ты SO-файл компилируешь.

19:30.740 --> 19:31.740
Ты его линкуешь.

19:31.740 --> 19:32.740
Да.

19:32.740 --> 19:33.740
И линковка не полная.

19:33.740 --> 19:34.740
Ну, он долинкует фронтально.

19:34.740 --> 19:35.740
А я о чем говорю?

19:35.740 --> 19:36.740
Я говорю про то, что...

19:36.740 --> 19:37.740
Вот подождите.

19:37.740 --> 19:38.740
Я говорю про статические библиотеки.

19:38.740 --> 19:39.740
Я говорю не про динамические.

19:39.740 --> 19:40.740
И что?

19:40.740 --> 19:41.740
Вот.

19:41.740 --> 19:42.740
То же самое.

19:42.740 --> 19:43.740
У нас у тебя точно скачка.

19:43.740 --> 19:44.740
У нас скачник.

19:44.740 --> 19:45.740
Да.

19:45.740 --> 19:46.740
Исполняемый файл.

19:46.740 --> 19:47.740
Скачник.

19:47.740 --> 19:48.740
Скачник.

19:48.740 --> 19:49.740
Скачник.

19:49.740 --> 19:50.740
Скачник.

19:50.740 --> 19:51.740
Скачник.

19:51.740 --> 19:52.740
И что?

19:52.740 --> 19:53.740
Вот.

19:53.740 --> 19:54.740
То же самое.

19:54.740 --> 19:55.740
У нас у тебя точно скачка.

19:55.740 --> 19:56.740
У нас скачник.

19:56.740 --> 19:57.740
Да.

19:57.740 --> 19:58.740
Исполняемый файл.

19:58.740 --> 19:59.740
Получится.

19:59.740 --> 20:00.740
Вот.

20:00.740 --> 20:01.740
Уже все будет хорошо.

20:01.740 --> 20:02.740
Почему?

20:02.740 --> 20:03.740
Вот ты линкуешь SO-шник.

20:03.740 --> 20:06.740
Ты SO-шник линкуешь со статической библиотекой.

20:06.740 --> 20:07.740
Вот у тебя...

20:07.740 --> 20:08.740
Фу!

20:08.740 --> 20:13.740
Находится в статической библиотеке при линковке

20:13.740 --> 20:14.740
этого SO-шника.

20:14.740 --> 20:15.740
Так мы...

20:15.740 --> 20:16.740
Чего ты не можешь понять?

20:16.740 --> 20:19.740
Я говорю про то, что если мы будем компилировать

20:19.740 --> 20:20.740
исполняемый файл...

20:20.740 --> 20:21.740
Вот ты компилируешь вот этот файл.

20:21.740 --> 20:22.740
Исполняемый.

20:22.740 --> 20:23.740
У него есть мейн.

20:23.740 --> 20:24.740
И старт.

20:24.740 --> 20:25.740
У него нет мейна.

20:25.740 --> 20:26.740
Но это может быть.

20:26.740 --> 20:27.740
Но это не обязательно.

20:27.740 --> 20:28.740
И старт тоже может быть.

20:28.740 --> 20:29.740
А точка входа...

20:29.740 --> 20:30.740
Как у SO может быть точка входа?

20:30.740 --> 20:31.740
Может быть.

20:31.740 --> 20:32.740
Ты можешь запустить...

20:32.740 --> 20:33.740
Который вот этот динамический нагрузчик.

20:33.740 --> 20:34.740
Его можно запустить как исполняемый файл.

20:34.740 --> 20:35.740
Но мы не будем туда лезть.

20:35.740 --> 20:36.740
В общем, вот ты эту штуку линкуешь.

20:36.740 --> 20:37.740
Вот это статическая библиотека.

20:37.740 --> 20:38.740
А она с опиком или без?

20:38.740 --> 20:39.740
Ну, как...

20:39.740 --> 20:40.740
Как хочешь.

20:40.740 --> 20:41.740
Линк.

20:41.740 --> 20:42.740
Линк.

20:42.740 --> 20:43.740
Линк.

20:43.740 --> 20:44.740
Линк.

20:44.740 --> 20:45.740
Линк.

20:45.740 --> 20:46.740
Линк.

20:46.740 --> 20:47.740
Это не влияет.

20:47.740 --> 20:59.460
Пик или не пик, на то, что я говорю, никак не влияет.

20:59.460 --> 21:03.220
Вот у тебя есть функция функции статической библиотеки.

21:03.220 --> 21:11.140
Она якобы вкопивается в этот файл.

21:11.140 --> 21:16.700
Но связь вот такая отсутствует.

21:16.700 --> 21:43.560
На самом деле, у вас вот здесь вот есть этакая таблица импорта, которая здесь называется got, global object table, которая содержит, не знаю, как вам сказать, ну, давайте вот так вот напишу.

21:43.560 --> 22:13.540
Адреса, да.

22:13.540 --> 22:13.560
Адрес функции. Но вот этот адрес, он вправляется в момент загрузки этой динамической библиотеки. То есть на самом деле, кого вызывает вот здесь вот функция bar, она не знает. И от того, что вы скомпилили все эти функции, вы не знаете, что происходит.

22:13.560 --> 22:43.540
Адрес функции. Но вот этот адрес функции, он вправляется в момент загрузки этой динамической библиотеки. То есть на самом деле, кого вызывает вот здесь вот эта динамическая библиотека.

22:43.540 --> 23:13.520
Адрес функции. Но вот этот адрес функции, он вправляется в момент загрузки этой динамической библиотеки. То есть на самом деле, кого вызывает вот эта динамическая библиотека.

23:13.520 --> 23:43.500
Адрес функции. Но вот этот адрес функции, он вправляется в момент загрузки этой динамической библиотеки. То есть на самом деле, кого вызывает вот эта динамическая библиотека.

23:43.500 --> 24:13.480
Адрес функции. Но вот этот адрес функции, он вправляется в момент загрузки этой динамической библиотеки. То есть на самом деле, кого вызывает вот эта динамическая библиотека.

24:13.500 --> 24:43.480
Адрес функции. Но вот этот адрес функции, он вправляется в момент загрузки этой динамической библиотеки. То есть на самом деле, кого вызывает вот эта динамическая библиотека.

24:43.500 --> 25:13.480
Адрес функции. Но вот этот адрес функции, он вправляется в момент загрузки этой динамической библиотеки. То есть на самом деле, кого вызывает вот эта динамическая библиотека.

25:13.500 --> 25:43.480
Адрес функции. Но вот этот адрес функции, он вправляется в момент загрузки этой динамической библиотеки. То есть на самом деле, кого вызывает вот эта динамическая библиотека.

25:43.500 --> 26:13.480
Адрес функции. Но вот этот адрес функции, он вправляется в момент загрузки этой динамической библиотеки. То есть на самом деле, кого вызывает вот эта динамическая библиотека.

26:13.500 --> 26:43.480
Адрес функции. Но вот этот адрес функции, он вправляется в момент загрузки этой динамической библиотеки. То есть на самом деле, кого вызывает вот эта динамическая библиотека.

26:43.500 --> 27:13.480
Адрес функции. Но вот этот адрес функции, он вправляется в момент загрузки этой динамической библиотеки. То есть на самом деле, кого вызывает вот эта динамическая библиотека.

27:13.500 --> 27:43.480
Адрес функции. Но вот этот адрес функции, он вправляется в момент загрузки этой библиотеки. То есть на самом деле, кого вызывает вот эта динамическая библиотека.

27:43.500 --> 28:13.480
Адрес функции. Но вот этот адрес функции, он вправляется в момент загрузки этой динамической библиотеки. То есть на самом деле, кого вызывает вот эта динамическая библиотека.

