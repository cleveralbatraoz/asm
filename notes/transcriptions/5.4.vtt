WEBVTT

00:00.000 --> 00:03.920
...может перевести эту таблицу в режим read-only.

00:06.200 --> 00:14.980
То есть по таким модным представлениям, ну, лагает на старте и лагает.

00:15.960 --> 00:17.760
Типа security требует.

00:17.760 --> 00:35.520
И потенциально, потенциально можно сказать компилятору, чтобы он копировал вызовы, вот эти вот вызовы, как не вот так вот, на переходник,

00:39.480 --> 00:45.940
а на, что у нас там, full, get, вот.

00:46.940 --> 00:47.740
Чтобы вот.

00:47.760 --> 00:49.080
Вот так компилировал.

00:49.780 --> 00:51.840
По принципу, как у DLL-импорт работает.

00:53.060 --> 00:54.680
Только здесь есть проблема.

00:56.280 --> 01:03.420
Если вы скажете такой ключик, то компилятор будет генерировать все вызовы функций вот таким образом.

01:04.520 --> 01:11.500
Потому что он понятия не имеет, эта функция, она импортируется снаружи или не импортируется.

01:12.340 --> 01:17.500
То есть по линуксам просто нет такого флага, который говорит...

01:17.760 --> 01:20.780
И эта функция будет импортироваться.

01:21.780 --> 01:23.900
Эта функция будет экспортироваться.

01:26.120 --> 01:31.780
Поэтому если вы переводите компилятор в этот режим, то он как всем функциям обращается там.

01:32.800 --> 01:34.000
Ну, что конечно фигня.

01:34.520 --> 01:36.520
Потому что у вас происходит индиекция.

01:36.820 --> 01:42.060
Индиекция это означает, что суперскаляры удачи предсказать, куда вы там обращаетесь.

01:42.380 --> 01:45.940
Им приходится заниматься предсказанием на абсолютно ровном месте.

01:46.160 --> 01:47.620
Потому что все ваши местные функции.

01:47.760 --> 01:49.760
будут ходить сквозь эту интеллекту.

01:51.760 --> 01:54.760
Вот, поэтому, ну, такой ключик существует,

01:54.760 --> 01:58.760
но, как я понимаю, народом пользоваться не любят,

01:58.760 --> 02:03.760
то есть обычно здесь будет фу, эт, плт,

02:03.760 --> 02:07.760
и дальше будет вот такая штука сквозь год.

02:10.760 --> 02:14.760
Это такая общая картина вещей, да.

02:14.760 --> 02:17.760
Вся эта история, она только про функции.

02:17.760 --> 02:22.760
И абсолютно то же самое происходит с глобальными данными.

02:22.760 --> 02:28.760
То есть глобальные данные, они потенциально могут быть переопределены,

02:28.760 --> 02:31.760
только там заморочка еще больше,

02:31.760 --> 02:33.760
потому что там есть специальные режимы,

02:33.760 --> 02:40.760
которые говорят, что типа я хочу скопировать эту глобальную переменную к себе

02:40.760 --> 02:44.760
и иметь в своем модуле копию этой переменной,

02:44.760 --> 02:47.760
которая определена в каком-то другом модуле.

02:48.760 --> 02:51.760
Я вам даже не расскажу полностью происходящее,

02:51.760 --> 02:54.760
то есть там отдельная убийственная система про данные,

02:54.760 --> 02:56.760
которая сложнее, чем функции.

02:56.760 --> 02:59.760
То есть в плане просто один раз скопировал, дальше они независимые?

02:59.760 --> 03:00.760
Да.

03:01.760 --> 03:03.760
Или зависимые.

03:03.760 --> 03:06.760
Или удача разобраться, что там происходит.

03:06.760 --> 03:08.760
То есть с данными все еще хуже, чем с функциями.

03:08.760 --> 03:10.760
С функциями относительно просто.

03:11.760 --> 03:13.760
Почему не сделали ключ?

03:13.760 --> 03:16.760
Ну у нас же обычно функция будет просто call что-то,

03:16.760 --> 03:18.760
а тут типа call собака.

03:18.760 --> 03:21.760
Ну не сделаешь, что типа вот собака call this,

03:21.760 --> 03:24.760
меняем на собака got и скобочки ставим по памяти.

03:24.760 --> 03:26.760
Ты не можешь ставить скобочки, это разные команды,

03:26.760 --> 03:28.760
они даже разный размер в байтах имеют.

03:31.760 --> 03:33.760
То есть компилятор должен скомпилировать

03:33.760 --> 03:36.760
такую форму команды или такую форму команды?

03:38.760 --> 03:41.760
Конечно, кое-что можно было бы поменять.

03:41.760 --> 03:42.760
Например, скомпилировать...

03:43.760 --> 03:46.760
То есть команду, которая занимает большее количество байтиков,

03:46.760 --> 03:52.760
а потом в рантайме, скажем, ее вправить на нужную форму,

03:52.760 --> 03:54.760
а лишние байтики забить нобами.

03:55.760 --> 03:58.760
Потенциально так можно, но так никто не делает

03:58.760 --> 04:02.760
в связи со второй проблемой, о которой я вам попозже расскажу.

04:04.760 --> 04:05.760
Вот.

04:07.760 --> 04:08.760
Да.

04:08.760 --> 04:11.760
Теперь как эту картину сделать менее убогой?

04:11.760 --> 04:15.760
Смотрите. Во-первых, посмотрим на наш исполняемый файл.

04:15.760 --> 04:22.760
Так как исполняемый файл находится в этой таблице поиска всегда на первом месте,

04:22.760 --> 04:28.760
тогда те символы, которые исполняемый файл экспортирует,

04:28.760 --> 04:31.760
их нет необходимости импортировать,

04:31.760 --> 04:36.760
потому что компилятор понимает, что все равно это будет на первом месте,

04:36.760 --> 04:40.760
поэтому свои собственные символы исполняемый файл

04:40.760 --> 04:43.760
может вызывать напрямую без год.

04:46.760 --> 04:49.760
То есть логически оно работает через год,

04:49.760 --> 04:55.760
но так как при резолвинге оно все равно окажется на самом первом месте,

04:55.760 --> 04:59.760
то можно этот этап поскипать

04:59.760 --> 05:03.760
и эквивалентно просто поставить прямой вызов.

05:04.760 --> 05:07.760
Но это справедливо только для исполняемого файла,

05:07.760 --> 05:10.760
для тех функций, которые он же создал,

05:10.760 --> 05:12.760
потому что он сам реализует.

05:12.760 --> 05:16.760
То есть динамической библиотеки не судьба.

05:16.760 --> 05:19.760
Но статическая тоже.

05:19.760 --> 05:22.760
Так статическая она и не проблема.

05:22.760 --> 05:25.760
Она не исполняемый файл.

05:25.760 --> 05:28.760
Но там тоже нельзя.

05:28.760 --> 05:31.760
Что статическая библиотека это полуфабрикат,

05:31.760 --> 05:34.760
который не претендует к неисполняемости.

05:34.760 --> 05:36.760
Ну хорошо.

05:36.760 --> 05:38.760
Ура.

05:38.760 --> 05:41.760
Что еще можно сказать?

05:41.760 --> 05:43.760
Можно сказать,

05:43.760 --> 05:45.760
магическое заклинание,

05:45.760 --> 05:47.760
по-моему оно звучит как

05:47.760 --> 05:53.760
минус б символик

05:53.760 --> 05:56.760
это заклинание Винкелла,

05:56.760 --> 05:58.760
про то,

05:58.760 --> 06:02.760
что когда вы динамическую библиотеку линкуете,

06:02.760 --> 06:06.760
какие символы можно зарезолвить,

06:06.760 --> 06:09.760
их надо зарезолвить.

06:09.760 --> 06:17.760
То есть если у вас функция фу реализована внутри вашей же динамической библиотеки,

06:17.760 --> 06:20.760
вот не будем ее гнать сквозь год,

06:20.760 --> 06:23.760
а напрямую зарезолвим.

06:23.760 --> 06:27.760
Это уже начинает смахивать на виндовые библиотеки.

06:27.760 --> 06:29.760
Но не совсем.

06:29.760 --> 06:34.760
И в частности кто-то от этого конечно же ломается.

06:34.760 --> 06:35.760
Потому что кто-то конечно же от этого ломается.

06:35.760 --> 06:37.760
Кто-то конечно же ожидает

06:37.760 --> 06:39.760
вот это классическое поведение

06:39.760 --> 06:42.760
с тем, что символ чертово знает где находится.

06:42.760 --> 06:43.760
Но,

06:43.760 --> 06:45.760
попытаться стоит.

06:45.760 --> 06:47.760
То есть если вы пытаетесь сделать

06:47.760 --> 06:49.760
что-то более-менее

06:49.760 --> 06:52.760
хорошо работающее по скорости под Винуксом,

06:52.760 --> 06:55.760
и вот вы пытаетесь сделать динамическую библиотеку,

06:55.760 --> 06:58.760
вот попытаетесь в этом режиме ее скомперировать,

06:58.760 --> 07:00.760
если повезет,

07:00.760 --> 07:02.760
ваша жизнь станет лучше.

07:02.760 --> 07:04.760
Что вы имеете в виду по зарезолвлению?

07:04.760 --> 07:06.760
То есть оно не будет сквозь год

07:06.760 --> 07:08.760
гнать символы определенные

07:08.760 --> 07:10.760
внутри этой библиотеки,

07:10.760 --> 07:12.760
то есть будет работать подобно,

07:12.760 --> 07:14.760
как собран исполняемый файл,

07:14.760 --> 07:15.760
как экзешник.

07:15.760 --> 07:17.760
Через ПЛП, понимаете?

07:17.760 --> 07:18.760
Не будет.

07:18.760 --> 07:19.760
А как?

07:19.760 --> 07:24.760
То есть оно будет компилировать подобно экзешнику.

07:24.760 --> 07:25.760
Те символы, которые есть,

07:25.760 --> 07:29.760
зарезовывать внутри себя напрямую.

07:29.760 --> 07:32.760
Но мы же не можем вызвать напрямую фу.

07:32.760 --> 07:33.760
Почему?

07:33.760 --> 07:34.760
Потому что мы еще не знаем,

07:34.760 --> 07:35.760
куда мы загрузимся.

07:35.760 --> 07:36.760
Еще раз,

07:36.760 --> 07:37.760
вот этот,

07:37.760 --> 07:38.760
вот этот ключик говорит,

07:38.760 --> 07:39.760
делай так.

07:39.760 --> 07:41.760
Так если мы загрузимся куда-то непонятное,

07:41.760 --> 07:43.760
то все сломается.

07:43.760 --> 07:44.760
Почему сломается?

07:44.760 --> 07:45.760
Ну вот смотрите.

07:45.760 --> 07:47.760
У тебя вот этот колл,

07:47.760 --> 07:50.760
он у тебя будет обращаться вот сюда.

07:50.760 --> 07:51.760
Что у тебя сломается?

07:51.760 --> 07:52.760
Через ПЛТ.

07:52.760 --> 07:53.760
Да не через ПЛТ,

07:53.760 --> 07:54.760
напрямую.

07:54.760 --> 07:55.760
То есть будет просто колл фунт.

07:55.760 --> 07:56.760
Да.

07:56.760 --> 07:57.760
Как ты делаешь колл статическую функцию?

07:57.760 --> 07:59.760
То есть колл и какой-то адрес.

07:59.760 --> 08:01.760
Как ты вызываешь статическую функцию?

08:01.760 --> 08:04.760
Если просто в исполняемом,

08:04.760 --> 08:06.760
то я знаю адрес.

08:06.760 --> 08:08.760
А в библиотеке?

08:08.760 --> 08:09.760
Не знаю.

08:09.760 --> 08:10.760
Почему ты не знаешь?

08:10.760 --> 08:11.760
Потому что неизвестно,

08:11.760 --> 08:14.760
куда мы подгрузимся.

08:14.760 --> 08:16.760
Ну относительный адрес ты знаешь?

08:16.760 --> 08:18.760
Относительно знаю.

08:18.760 --> 08:20.760
Как команда колл компилится?

08:20.760 --> 08:21.760
Ну хорошо относительно.

08:21.760 --> 08:25.760
Если бы ты ходил на предыдущие лекции,

08:25.760 --> 08:28.760
то был бы в курсе,

08:28.760 --> 08:30.760
что команда колл

08:30.760 --> 08:32.760
вот этот адрес,

08:32.760 --> 08:34.760
ты пишешь абсолютный,

08:34.760 --> 08:36.760
то есть на ассендере

08:36.760 --> 08:38.760
оно выглядит как абсолютный адрес.

08:38.760 --> 08:41.760
Но компилируется это

08:41.760 --> 08:43.760
в относительный адрес.

08:43.760 --> 08:47.760
Поэтому вот это обращение,

08:47.760 --> 08:49.760
это обращение,

08:49.760 --> 08:50.760
которое не ломается

08:50.760 --> 08:52.760
ни при каких перемещениях.

08:52.760 --> 08:56.760
Как и статик функции,

08:56.760 --> 08:59.760
ни через какой ПЛТ они не проходят.

08:59.760 --> 09:01.760
Это прямой вызов.

09:01.760 --> 09:05.760
И оно компилит вот обычные функции,

09:05.760 --> 09:07.760
как бы если бы они были статик.

09:07.760 --> 09:08.760
То есть это,

09:08.760 --> 09:09.760
еще раз,

09:09.760 --> 09:10.760
похоже на то,

09:10.760 --> 09:11.760
что происходит под виндой.

09:11.760 --> 09:12.760
Только кусок того,

09:12.760 --> 09:16.760
что происходит под виндой.

09:16.760 --> 09:17.760
Еще раз,

09:17.760 --> 09:19.760
это имеет смысл подумать

09:19.760 --> 09:20.760
и попробовать,

09:20.760 --> 09:21.760
когда вы пытаетесь построить

09:21.760 --> 09:22.760
динамическую библиотеку,

09:22.760 --> 09:25.760
чтобы она вела себя непудно.

09:25.760 --> 09:28.760
Как продолжить и помочь

09:28.760 --> 09:31.760
динамической библиотеке быть неуродской.

09:31.760 --> 09:33.760
На самом деле вот этот дефолт,

09:33.760 --> 09:36.760
что у вас все экспортируется,

09:36.760 --> 09:37.760
как я уже сказал,

09:37.760 --> 09:39.760
это дефолт.

09:39.760 --> 09:41.760
И его в современном мире

09:41.760 --> 09:45.760
можно не только как-то повлиять на него,

09:45.760 --> 09:47.760
его можно поменять.

09:47.760 --> 09:49.760
Можно сказать,

09:49.760 --> 09:52.760
ой, я не помню этот ключик линкера,

09:52.760 --> 09:55.760
что он там называется,

09:55.760 --> 09:57.760
BCBT,

09:58.760 --> 10:03.760
дефолт фрисибилити как-то,

10:03.760 --> 10:05.760
родной химблей.

10:09.760 --> 10:11.760
Примерно так.

10:11.760 --> 10:13.760
F-фрисибилити,

10:13.760 --> 10:15.760
F-фрисибилити,

10:15.760 --> 10:17.760
F-фрисибилити равно химблей.

10:17.760 --> 10:19.760
Это вы начинаете быть

10:19.760 --> 10:21.760
очень похожими на винду

10:21.760 --> 10:22.760
в плане того,

10:22.760 --> 10:24.760
что теперь у вас по дефолту

10:24.760 --> 10:26.760
ничего не экспортируется.

10:26.760 --> 10:28.760
И что,

10:28.760 --> 10:30.760
чтобы что-то заэкспортировалось,

10:30.760 --> 10:33.760
вам нужно сказать у функции

10:33.760 --> 10:35.760
два подчеркивания,

10:35.760 --> 10:36.760
атрибут,

10:36.760 --> 10:37.760
два подчеркивания,

10:37.760 --> 10:39.760
висибилити,

10:39.760 --> 10:41.760
дефолт.

10:41.760 --> 10:42.760
Дефолт,

10:42.760 --> 10:43.760
это, в смысле,

10:43.760 --> 10:44.760
вот этот старый дефолт,

10:44.760 --> 10:46.760
который все экспортирует.

10:46.760 --> 10:47.760
То есть,

10:47.760 --> 10:49.760
как вот вы говорили под виндой,

10:49.760 --> 10:50.760
например,

10:50.760 --> 10:52.760
деклспект длэкспорт,

10:52.760 --> 10:55.760
вот прям аналогичное заклинание

10:55.760 --> 10:57.760
вы теперь можете сказать по функции,

10:58.760 --> 11:00.760
и только она экспортируется,

11:00.760 --> 11:03.760
а все остальное не будет экспортироваться.

11:03.760 --> 11:06.760
Ну и крупные проекты, конечно,

11:06.760 --> 11:08.760
пытаются так делать,

11:08.760 --> 11:10.760
но тот же самый LLVM,

11:10.760 --> 11:13.760
они двигаются в эту сторону,

11:13.760 --> 11:15.760
но тяжко,

11:15.760 --> 11:17.760
потому что нужно посмотреть

11:17.760 --> 11:19.760
на все, что там у них происходит,

11:19.760 --> 11:22.760
то есть они пытаются сделать вариант

11:22.760 --> 11:26.760
в виде динамической библиотеки LLVM,

11:26.760 --> 11:31.760
и для этого нужно хорошо разобраться с тем,

11:31.760 --> 11:33.760
кого нужно экспортировать,

11:33.760 --> 11:35.760
и кого не нужно.

11:35.760 --> 11:37.760
Сейчас у них там все просто торчит наружу,

11:37.760 --> 11:39.760
как обычно под Unix,

11:39.760 --> 11:41.760
и происходит некий полный хаос,

11:41.760 --> 11:43.760
так что оно там работает,

11:43.760 --> 11:45.760
под виндой ни черта не работает.

11:45.760 --> 11:47.760
Поэтому, чтобы оно заработало под виндой,

11:47.760 --> 11:51.760
и чтобы оно гораздо быстрее работало под Linux,

11:51.760 --> 11:54.760
вот нужно аккуратненько расставить висибилити,

11:54.760 --> 11:56.760
но когда вы пишете,

11:56.760 --> 11:58.760
это не большая проблема,

11:58.760 --> 12:00.760
вы думаете, что вы пишете,

12:00.760 --> 12:02.760
а когда у вас есть огромный набор кода,

12:02.760 --> 12:04.760
то там догадаться, куда поставить,

12:04.760 --> 12:06.760
куда не поставить,

12:06.760 --> 12:08.760
вот это вообще нетривиальное занятие.

12:08.760 --> 12:10.760
Я вот знаю, что они в эту сторону

12:10.760 --> 12:12.760
так хотят двигаться,

12:12.760 --> 12:14.760
но пока не дошли.

12:14.760 --> 12:15.760
Такой вопрос.

12:15.760 --> 12:17.760
Ему надо установить ровно в тех же местах,

12:17.760 --> 12:19.760
что и DecalSphere?

12:19.760 --> 12:20.760
Что от LLExpert?

12:20.760 --> 12:21.760
Да.

12:21.760 --> 12:22.760
Ну, почти.

12:22.760 --> 12:23.760
На самом деле для LLExpert

12:23.760 --> 12:25.760
это только один из вариантов,

12:25.760 --> 12:27.760
как можно экспортировать функцию под виндой.

12:27.760 --> 12:29.760
Это если ты хочешь описывать

12:29.760 --> 12:32.760
экспортированность в исходном коде.

12:32.760 --> 12:34.760
Но под виндой функцию можно экспортировать

12:34.760 --> 12:36.760
и в других местах.

12:36.760 --> 12:38.760
Например, можно указать линкеру

12:38.760 --> 12:40.760
так называемых тех файлов,

12:40.760 --> 12:42.760
где просто перечислить список функций,

12:42.760 --> 12:44.760
которые ты хочешь экспортировать.

12:44.760 --> 12:46.760
Вот аналога этого я что-то не знаю

12:46.760 --> 12:48.760
с подвинуксом.

12:48.760 --> 12:50.760
То есть они наконец-то дошли

12:50.760 --> 12:52.760
до аналога LLExpert,

12:52.760 --> 12:55.760
но до дел файлов не дошли.

12:59.760 --> 13:01.760
Эта штука позволяет вам,

13:01.760 --> 13:03.760
чтобы у вас все не торчало наружу,

13:03.760 --> 13:05.760
сейчас я думаю,

13:05.760 --> 13:07.760
вы хотите такое сказать

13:07.760 --> 13:09.760
вашему исполняемому файлу.

13:09.760 --> 13:11.760
Потому что как часто вы хотите

13:11.760 --> 13:13.760
из вашего исполняемого файла

13:13.760 --> 13:15.760
что-то поэкспортировать

13:15.760 --> 13:17.760
в библиотеки, которые от вас зависят.

13:17.760 --> 13:19.760
От которых вы зависите.

13:19.760 --> 13:21.760
Никогда.

13:22.760 --> 13:24.760
Поэтому эта штука имеет

13:24.760 --> 13:26.760
средства для вашего исполняемого

13:26.760 --> 13:28.760
файла писать всегда.

13:30.760 --> 13:32.760
Это была

13:32.760 --> 13:34.760
проблема номер один.

13:38.760 --> 13:40.760
Ну, сейчас как бы некоторые заплатки,

13:40.760 --> 13:42.760
но основные проблемы

13:42.760 --> 13:44.760
оно не очень вечер.

13:44.760 --> 13:46.760
В частности, вот этот импорт

13:46.760 --> 13:48.760
от окружающего пространства

13:48.760 --> 13:50.760
с подвинуксом я не вижу, чтобы пытались

13:50.760 --> 13:52.760
под другими юниксподобными системами.

13:52.760 --> 13:54.760
Я читал, что делали систему,

13:54.760 --> 13:56.760
похожую на Винду.

13:56.760 --> 13:58.760
То есть, чтобы там импорт был

13:58.760 --> 14:00.760
из конкретной библиотеки.

14:00.760 --> 14:02.760
Кстати говоря,

14:02.760 --> 14:04.760
он даже под МакКоси что-то такое.

14:04.760 --> 14:06.760
Но я не уверен.

14:06.760 --> 14:08.760
Под МакКоси я вообще мало что знаю.

14:08.760 --> 14:10.760
Что-то я читал, что они что-то пытались,

14:10.760 --> 14:12.760
но насколько работает,

14:12.760 --> 14:14.760
не работает, вообще не будем брать.

14:14.760 --> 14:16.760
Такой вопрос.

14:16.760 --> 14:18.760
Мы можем

14:18.760 --> 14:20.760
сами в очереди

14:20.760 --> 14:22.760
править код,

14:22.760 --> 14:24.760
если мы скажем,

14:24.760 --> 14:26.760
что нам не нужен динамический интерпретатор,

14:26.760 --> 14:28.760
мы через dialog

14:28.760 --> 14:30.760
можем все открывать и все сделать.

14:30.760 --> 14:32.760
Это по-другому.

14:32.760 --> 14:34.760
Смотрите, это вот

14:34.760 --> 14:36.760
то, что мы сейчас рассматриваем.

14:36.760 --> 14:38.760
Это так называемая

14:38.760 --> 14:40.760
динамическая линковка.

14:40.760 --> 14:42.760
То есть, у вас получается

14:42.760 --> 14:44.760
файл, который

14:44.760 --> 14:46.760
зависит от динамической

14:46.760 --> 14:48.760
библиотеки, потому что

14:48.760 --> 14:50.760
какие-то функции

14:50.760 --> 14:52.760
у вас их нет.

14:52.760 --> 14:54.760
Код на них рассчитывает,

14:54.760 --> 14:56.760
но у вас этих функций нет.

14:58.760 --> 15:00.760
И поэтому вам необходима

15:00.760 --> 15:02.760
эта самая внешняя библиотека.

15:02.760 --> 15:04.760
А еще бывает

15:04.760 --> 15:06.760
так называемая динамическая

15:06.760 --> 15:08.760
загрузка.

15:08.760 --> 15:10.760
Что такое динамическая

15:10.760 --> 15:12.760
загрузка? Когда ваш

15:12.760 --> 15:14.760
файл явно от динамической

15:14.760 --> 15:16.760
библиотеки не зависит.

15:16.760 --> 15:18.760
Но вы

15:18.760 --> 15:20.760
вызываете специальную

15:20.760 --> 15:22.760
системную функцию

15:22.760 --> 15:24.760
«Я хочу загрузить данную

15:24.760 --> 15:26.760
динамическую библиотеку».

15:26.760 --> 15:28.760
И получаете

15:28.760 --> 15:30.760
в ответ хендл

15:30.760 --> 15:32.760
идентификатор. Ну, примерно,

15:32.760 --> 15:34.760
как вы fopen вызываете

15:34.760 --> 15:36.760
и получаете хендл

15:36.760 --> 15:38.760
открытого файла. Также вы получаете

15:38.760 --> 15:40.760
хендл загруженной библиотеки

15:40.760 --> 15:42.760
или, ну, что

15:42.760 --> 15:44.760
ни черта не загрузилось, почему-то

15:44.760 --> 15:46.760
я не нашел какой библиотеки,

15:46.760 --> 15:48.760
говорит вам системный загрузчик.

15:48.760 --> 15:50.760
И потом, имея этот хендл,

15:50.760 --> 15:52.760
вы

15:52.760 --> 15:54.760
можете другой системной

15:54.760 --> 15:56.760
функции попросить

15:56.760 --> 15:58.760
«Отдай-ка мне

15:58.760 --> 16:00.760
адрес

16:00.760 --> 16:02.760
вот этого экспортируемого

16:02.760 --> 16:04.760
символа». Например,

16:04.760 --> 16:06.760
там функции «фу».

16:06.760 --> 16:08.760
И

16:08.760 --> 16:10.760
таким образом вы можете получить

16:10.760 --> 16:12.760
вот адрес функции

16:12.760 --> 16:14.760
«фу» внутри этой библиотеки,

16:14.760 --> 16:16.760
которую вы сохраните

16:16.760 --> 16:18.760
в указателе на функцию

16:18.760 --> 16:20.760
например, «си».

16:20.760 --> 16:22.760
И сквозь этот

16:22.760 --> 16:24.760
указатель на функцию

16:24.760 --> 16:26.760
сможете вызывать.

16:26.760 --> 16:28.760
Ну, то есть полностью

16:28.760 --> 16:30.760
ручками.

16:30.760 --> 16:32.760
И полностью аналогично

16:32.760 --> 16:34.760
оно работает и под виндой, и, я думаю,

16:34.760 --> 16:36.760
и под другими операционными системами.

16:36.760 --> 16:38.760
Но только вот какие функции вы

16:38.760 --> 16:40.760
вызываете, это системно-зависимая вещь.

16:40.760 --> 16:42.760
То есть вы уже здесь

16:42.760 --> 16:44.760
должны знать

16:44.760 --> 16:46.760
такую операционную систему,

16:46.760 --> 16:48.760
какие у нее функции,

16:48.760 --> 16:50.760
какие у этих функций аргументы,

16:50.760 --> 16:52.760
чтобы правильно вызвать.

16:52.760 --> 16:54.760
Но в целом этот процесс

16:54.760 --> 16:56.760
ну, вот он

16:56.760 --> 16:58.760
каких-то особых сложностей не несет.

17:00.760 --> 17:02.760
Еще есть одна вещь под виндой,

17:02.760 --> 17:04.760
я вам про нее не рассказывал.

17:04.760 --> 17:06.760
Есть так называемый

17:06.760 --> 17:08.760
отложенный импорт.

17:10.760 --> 17:12.760
Это немножко похоже

17:12.760 --> 17:14.760
вот на ту картину, которая

17:14.760 --> 17:16.760
была вот с PLT2.

17:16.760 --> 17:18.760
По линуксам.

17:18.760 --> 17:20.760
Но чуть про другое.

17:20.760 --> 17:22.760
А именно оно тоже резолвит

17:22.760 --> 17:24.760
эти импорты только

17:24.760 --> 17:26.760
в момент вызова.

17:26.760 --> 17:28.760
Но в отличие от линукса

17:28.760 --> 17:30.760
оно для

17:30.760 --> 17:32.760
старта исполняемого файла

17:32.760 --> 17:34.760
не требует этой

17:34.760 --> 17:36.760
библиотеки.

17:36.760 --> 17:38.760
То есть у вас эта библиотека,

17:38.760 --> 17:40.760
про которую сказано, что здесь

17:40.760 --> 17:42.760
идет импорт отложен.

17:42.760 --> 17:44.760
И ее системный загрузчик даже не пытается

17:44.760 --> 17:46.760
загрузить на старте вашего

17:46.760 --> 17:48.760
файла.

17:48.760 --> 17:50.760
И вполне

17:50.760 --> 17:52.760
все будет работать,

17:52.760 --> 17:54.760
даже если этой библиотеки нет,

17:54.760 --> 17:56.760
пока вы не вызовете

17:56.760 --> 17:58.760
функцию оттуда.

18:00.760 --> 18:02.760
А если вы вызовете функцию оттуда,

18:02.760 --> 18:04.760
тогда вызывается

18:04.760 --> 18:06.760
специальный резолвер.

18:06.760 --> 18:08.760
Вот здесь у нас были только переходники

18:08.760 --> 18:10.760
на резолвер.

18:10.760 --> 18:12.760
Там тоже есть некие стандартные переходники,

18:12.760 --> 18:14.760
но вы их можете переопределить.

18:14.760 --> 18:16.760
И если стандартный

18:16.760 --> 18:18.760
резолвер видит, что в библиотеке

18:18.760 --> 18:20.760
нет,

18:20.760 --> 18:22.760
тогда что он будет делать?

18:22.760 --> 18:24.760
Убьет

18:24.760 --> 18:26.760
ваш процесс,

18:26.760 --> 18:28.760
потому что вернуться он не может.

18:28.760 --> 18:30.760
Вы вызвали функцию,

18:30.760 --> 18:32.760
а функции оказалось, что нет.

18:32.760 --> 18:34.760
Но если вы написали свой резолвер,

18:34.760 --> 18:36.760
тогда что вы напишете,

18:36.760 --> 18:38.760
то и будет.

18:38.760 --> 18:40.760
Отложенная загрузка

18:40.760 --> 18:42.760
не требует, чтобы библиотека

18:42.760 --> 18:44.760
была,

18:44.760 --> 18:46.760
но если с нее по-самому

18:46.760 --> 18:48.760
не откажется,

18:48.760 --> 18:50.760
вы выстрелите себе

18:50.760 --> 18:52.760
куда-нибудь в процессе работы.

18:52.760 --> 18:54.760
Про

18:54.760 --> 18:56.760
отложенную загрузку

18:56.760 --> 18:58.760
вы ранее не говорили,

18:58.760 --> 19:00.760
что нужно получить кендл.

19:00.760 --> 19:02.760
Нет, отложенная загрузка

19:02.760 --> 19:04.760
это линковка.

19:06.760 --> 19:08.760
Как обычно

19:08.760 --> 19:10.760
у тебя есть библиотеки импорта и так далее,

19:10.760 --> 19:12.760
для твоей программы

19:12.760 --> 19:14.760
ты просто вызываешь функцию

19:14.760 --> 19:16.760
и не паришься.

19:16.760 --> 19:18.760
Но ты при

19:18.760 --> 19:20.760
компиляции специальным образом

19:20.760 --> 19:22.760
замечаешь, что вот эту библиотеку

19:22.760 --> 19:24.760
я хочу

19:24.760 --> 19:26.760
иметь в виде

19:26.760 --> 19:28.760
отложенного импорта.

19:28.760 --> 19:30.760
То есть это специальный ключик

19:30.760 --> 19:32.760
к линкеру, что вот эту

19:32.760 --> 19:34.760
библиотеку, таблицу импорта

19:34.760 --> 19:36.760
сгенерировать

19:36.760 --> 19:38.760
в специальной форме

19:38.760 --> 19:40.760
отложенного импорта.

19:40.760 --> 19:42.760
И системный загрузчик

19:42.760 --> 19:44.760
не только не будет

19:44.760 --> 19:46.760
зарезовывать

19:46.760 --> 19:48.760
эту таблицу импорта,

19:48.760 --> 19:50.760
он даже вообще не будет

19:50.760 --> 19:52.760
пытаться загрузить адрес

19:52.760 --> 19:54.760
пока ты не обратишься.

19:54.760 --> 19:56.760
Вот я обращусь и...

19:56.760 --> 19:58.760
Вот когда ты обратишься,

19:58.760 --> 20:00.760
тогда он загрузит эту библиотеку

20:00.760 --> 20:02.760
и зарезовывает конкретно

20:02.760 --> 20:04.760
вот это обращение.

20:04.760 --> 20:06.760
А как, типа, мы пытаемся

20:06.760 --> 20:08.760
обратиться, а происходит...

20:08.760 --> 20:10.760
Как здесь.

20:10.760 --> 20:12.760
У тебя происходит обращение

20:12.760 --> 20:14.760
сквозь табличку.

20:14.760 --> 20:16.760
Ведь это же импортированная функция.

20:16.760 --> 20:18.760
Поэтому происходит обращение

20:18.760 --> 20:20.760
сквозь табличку.

20:20.760 --> 20:22.760
И в этой табличке

20:22.760 --> 20:24.760
стоит указатель

20:24.760 --> 20:26.760
на кусок твоего кода,

20:26.760 --> 20:28.760
который занимается

20:28.760 --> 20:30.760
резолвингом.

20:30.760 --> 20:32.760
Либо стандартные

20:32.760 --> 20:34.760
у тебя в компилиции,

20:34.760 --> 20:36.760
либо ты можешь свой указать.

20:36.760 --> 20:38.760
То есть вызывается

20:38.760 --> 20:40.760
не та функция,

20:40.760 --> 20:42.760
которая должен

20:42.760 --> 20:44.760
определить, где эта функция,

20:44.760 --> 20:46.760
найти ее и заменить

20:46.760 --> 20:48.760
в таблице

20:48.760 --> 20:50.760
для будущего вызова

20:50.760 --> 20:52.760
это значение на настоящий адрес

20:52.760 --> 20:54.760
ну и перейти на эту функцию.

20:56.760 --> 20:58.760
Понятно?

20:58.760 --> 21:00.760
То есть здесь такая особенность,

21:00.760 --> 21:02.760
что этот отложенный импорт

21:02.760 --> 21:04.760
он даже не будет грузить.

21:06.760 --> 21:08.760
Плюс, что оно работоспособно

21:08.760 --> 21:10.760
даже при отсутствии

21:10.760 --> 21:12.760
желтки.

21:12.760 --> 21:14.760
Минус, что если вы таки

21:14.760 --> 21:16.760
воплётесь туда,

21:16.760 --> 21:18.760
то скорее всего оно

21:18.760 --> 21:20.760
в этом месте и покрашется.

21:20.760 --> 21:22.760
Так, это было

21:22.760 --> 21:24.760
про библиотеки

21:24.760 --> 21:26.760
проблему номер один.

21:26.760 --> 21:28.760
Проблема номер два.

21:30.760 --> 21:32.760
Называется пик.

21:32.760 --> 21:34.760
Как я вам говорил,

21:34.760 --> 21:36.760
динамические библиотеки

21:36.760 --> 21:38.760
вообще у них все возникли

21:38.760 --> 21:40.760
не от рождения.

21:40.760 --> 21:42.760
А в Linux

21:42.760 --> 21:44.760
не от рождения.

21:44.760 --> 21:46.760
И исходно

21:46.760 --> 21:48.760
их там реализовали

21:48.760 --> 21:50.760
вот так, несколько убого,

21:50.760 --> 21:52.760
что эти динамические библиотеки,

21:52.760 --> 21:54.760
где они располагаются в памяти,

21:54.760 --> 21:56.760
они должны были между собой

21:56.760 --> 21:58.760
договориться.

21:58.760 --> 22:00.760
То есть эти библиотеки,

22:00.760 --> 22:02.760
они были неперемещаемыми.

22:02.760 --> 22:04.760
Если они правильно

22:04.760 --> 22:06.760
прописали свои стартовые адреса,

22:06.760 --> 22:08.760
то все хорошо.

22:08.760 --> 22:10.760
Если какие-то библиотеки между собой

22:10.760 --> 22:12.760
перекрылись или перекрылись

22:12.760 --> 22:14.760
вашим взвешникам,

22:14.760 --> 22:16.760
ну и удачи.

22:16.760 --> 22:18.760
Пока библиотек

22:18.760 --> 22:20.760
штук пять, все норм.

22:20.760 --> 22:22.760
Когда библиотек куча,

22:22.760 --> 22:24.760
и там ваши,

22:24.760 --> 22:26.760
и не ваши, и там системные

22:26.760 --> 22:28.760
обновляются, понятно, что это

22:28.760 --> 22:30.760
не жизнеспособно.

22:30.760 --> 22:32.760
Поэтому

22:32.760 --> 22:34.760
необходимо иметь возможность

22:34.760 --> 22:36.760
как-то эти библиотеки

22:36.760 --> 22:38.760
перемещать в памяти,

22:38.760 --> 22:40.760
не ломая работоспособность.

22:40.760 --> 22:42.760
Как это работает

22:42.760 --> 22:44.760
под линдой, я вам рассказал.

22:44.760 --> 22:46.760
Есть механизм релокации,

22:46.760 --> 22:48.760
которые перемещают,

22:48.760 --> 22:50.760
ну вернее,

22:50.760 --> 22:52.760
которые позволяют

22:52.760 --> 22:54.760
системному загрузчику

22:54.760 --> 22:56.760
вправить адреса абсолютные

22:56.760 --> 22:58.760
внутри вашей программы

22:58.760 --> 23:00.760
в соответствии с тем,

23:00.760 --> 23:02.760
куда ваш файл переместился.

23:04.760 --> 23:06.760
Исходно это нужно было

23:06.760 --> 23:08.760
для только DLL,

23:08.760 --> 23:10.760
но сегодня

23:10.760 --> 23:12.760
это модно и для экзешников.

23:12.760 --> 23:14.760
Почему?

23:14.760 --> 23:16.760
Да, security.

23:16.760 --> 23:18.760
Штука называется

23:18.760 --> 23:20.760
ASLR.

23:20.760 --> 23:22.760
А-С-Л-Р.

23:22.760 --> 23:24.760
Адрес space

23:24.760 --> 23:26.760
вариант organization.

23:26.760 --> 23:28.760
То есть

23:28.760 --> 23:30.760
загрузка

23:30.760 --> 23:32.760
исполняемого файла

23:32.760 --> 23:34.760
по псевдослучайному адресу,

23:34.760 --> 23:36.760
который заранее

23:36.760 --> 23:38.760
трудно предсказать.

23:38.760 --> 23:40.760
И вот по такому

23:40.760 --> 23:42.760
рандомизированному адресу

23:42.760 --> 23:44.760
можно загружать и экзешники,

23:44.760 --> 23:46.760
необходимости в этом нет.

23:48.760 --> 23:50.760
Экзешник отображается

23:50.760 --> 23:52.760
в адресное пространство первым,

23:52.760 --> 23:54.760
поэтому он может

23:54.760 --> 23:56.760
почти где угодно быть,

23:56.760 --> 23:58.760
кроме перекрыться

23:58.760 --> 24:00.760
со системными какими-то структурами,

24:00.760 --> 24:02.760
которые имеют фиксированное положение.

24:02.760 --> 24:04.760
Вы можете почти куда угодно

24:04.760 --> 24:06.760
запихать экзешник.

24:06.760 --> 24:08.760
Необходимости перемещать экзешник

24:08.760 --> 24:10.760
можно, типа добавляя безопасность.

24:10.760 --> 24:12.760
А как линкер

24:12.760 --> 24:14.760
узнает, куда переместился

24:14.760 --> 24:16.760
этот экзешник?

24:16.760 --> 24:18.760
Через ростовый вектор будет

24:18.760 --> 24:20.760
таблица KTBase,

24:20.760 --> 24:22.760
а это адрес линкера,

24:22.760 --> 24:24.760
а не экзешника.

24:24.760 --> 24:26.760
Под линдой

24:26.760 --> 24:28.760
ядро грузит куда хочет.

24:28.760 --> 24:30.760
Ядро определяет,

24:30.760 --> 24:32.760
как работает ASLR.

24:32.760 --> 24:34.760
Но

24:34.760 --> 24:36.760
как линкер

24:36.760 --> 24:38.760
узнает, к какому адресу

24:38.760 --> 24:40.760
ядро загрузило.

24:40.760 --> 24:42.760
А что мешает ему ядро спросить?

24:44.760 --> 24:46.760
Я не знаю, как это сделано,

24:46.760 --> 24:48.760
но казалось бы, что мешает ему спросить ядро.

24:48.760 --> 24:50.760
Если есть текущий процесс,

24:50.760 --> 24:52.760
скажи мне,

24:52.760 --> 24:54.760
где в текущем процессе

24:54.760 --> 24:56.760
начинается исполняемый файл?

24:56.760 --> 24:58.760
То есть смотреть

24:58.760 --> 25:00.760
М-мапы?

25:00.760 --> 25:02.760
Не знаю.

25:02.760 --> 25:04.760
Не обязательно смотреть М-мапы.

25:04.760 --> 25:06.760
Можно просто вызвать именно информацию

25:06.760 --> 25:08.760
о процессе.

25:08.760 --> 25:10.760
Информация о текущем процессе.

25:10.760 --> 25:12.760
А для меня это может быть

25:12.760 --> 25:14.760
еще аналогично.

25:16.760 --> 25:18.760
Так вот.

25:18.760 --> 25:20.760
А в файле же указано,

25:20.760 --> 25:22.760
как грузить?

25:22.760 --> 25:24.760
В файле же указаны

25:24.760 --> 25:26.760
экзешники тоже указаны.

25:26.760 --> 25:28.760
Но сегодня модно

25:28.760 --> 25:30.760
забить на то, что указано

25:30.760 --> 25:32.760
и куда-то к чертям

25:32.760 --> 25:34.760
все переместить.

25:34.760 --> 25:36.760
Даже исполняемый файл,

25:36.760 --> 25:38.760
даже экзешник,

25:38.760 --> 25:40.760
что-то нафиг не надо,

25:40.760 --> 25:42.760
не требуется для работоспособности.

25:42.760 --> 25:44.760
Потому что модно.

25:44.760 --> 25:46.760
Модное слово ASLR.

25:46.760 --> 25:48.760
А как память тогда читать нормально?

25:48.760 --> 25:50.760
Ну как читать?

25:50.760 --> 25:52.760
Принести?

25:52.760 --> 25:54.760
Вот еще раз.

25:54.760 --> 25:56.760
Под виндой

25:56.760 --> 25:58.760
с этим проблем никаких.

25:58.760 --> 26:00.760
Потому что вам нужно

26:00.760 --> 26:02.760
просто не стрипать релокации

26:02.760 --> 26:04.760
у исполняемого файла.

26:04.760 --> 26:06.760
Давным-давно

26:06.760 --> 26:08.760
линкеры, они вот эти релокации

26:08.760 --> 26:10.760
экзешники просто не строили.

26:10.760 --> 26:12.760
Типа, а нафига ему эти релокации?

26:12.760 --> 26:14.760
Все равно они не используются.

26:14.760 --> 26:16.760
Сейчас по дефолту

26:16.760 --> 26:18.760
линкеры эти релокации

26:18.760 --> 26:20.760
оставляют, но вы можете

26:20.760 --> 26:22.760
сказать линкеру ключик,

26:22.760 --> 26:24.760
вы выкинете релокации,

26:24.760 --> 26:26.760
тогда у вас получится

26:26.760 --> 26:28.760
неперемещаемый файл.

26:28.760 --> 26:30.760
По дефолту у вас и DLL,

26:30.760 --> 26:32.760
и экзешник перемещаемый.

26:32.760 --> 26:34.760
Они там куда-то переместятся в памяти,

26:34.760 --> 26:36.760
куда не переместятся решает

26:36.760 --> 26:38.760
файлы.

26:38.760 --> 26:40.760
И когда файл переместился,

26:40.760 --> 26:42.760
то вот эти вот таблицы

26:42.760 --> 26:44.760
релокаций позволяют вам

26:44.760 --> 26:46.760
вправить

26:46.760 --> 26:48.760
образ, чтобы

26:48.760 --> 26:50.760
абсолютные адреса внутри файлика

26:50.760 --> 26:52.760
остались правильными и чтобы оно работало.

26:52.760 --> 26:54.760
Да.

26:54.760 --> 26:56.760
Какой вопрос?

26:56.760 --> 26:58.760
Ну, наверняка не очень относящийся

26:58.760 --> 27:00.760
к нижней теме, но если

27:00.760 --> 27:02.760
линкер может просто взять

27:02.760 --> 27:04.760
и спросить у его персоны

27:04.760 --> 27:06.760
по какому адресу забрать. Не-не-не.

27:06.760 --> 27:08.760
Он имеет в среду

27:08.760 --> 27:10.760
системный загрузчик.

27:10.760 --> 27:12.760
Потому что под Linux системный загрузчик

27:12.760 --> 27:14.760
не очень системный.

27:14.760 --> 27:16.760
То есть там загрузчик это

27:16.760 --> 27:18.760
такой

27:18.760 --> 27:20.760
исполняемый файл

27:20.760 --> 27:22.760
обычного юзерспейса.

27:22.760 --> 27:24.760
То есть он не особо выделен.

27:26.760 --> 27:28.760
То есть там системный прям загрузчик

27:28.760 --> 27:30.760
это то, что способно

27:30.760 --> 27:32.760
загрузить только файлик,

27:32.760 --> 27:34.760
который не имеет никаких импортов.

27:36.760 --> 27:38.760
Который полностью

27:38.760 --> 27:40.760
самодостаточный и никаких

27:40.760 --> 27:42.760
динамических библиотек не использует.

27:44.760 --> 27:46.760
А если твой исполняемый файл

27:46.760 --> 27:48.760
использует, то есть какую-то

27:48.760 --> 27:50.760
динамическую библиотеку,

27:50.760 --> 27:52.760
то вот такой прямо вот системный

27:52.760 --> 27:54.760
загрузчик, ядро,

27:54.760 --> 27:56.760
оно не умеет это грузить.

27:56.760 --> 27:58.760
Поэтому есть

27:58.760 --> 28:00.760
такой

28:00.760 --> 28:02.760
пользовательский юзерспейс

28:02.760 --> 28:04.760
исполняемый файликом,

28:04.760 --> 28:06.760
который

28:06.760 --> 28:08.760
ядро загружает

28:08.760 --> 28:10.760
для того, чтобы

28:10.760 --> 28:12.760
вот этот исполняемый

28:12.760 --> 28:14.760
файлик, он из библиотеки

28:14.760 --> 28:16.760
SO оформлен,

28:16.760 --> 28:18.760
чтобы вот он разобрался,

28:18.760 --> 28:20.760
что там нужно этому файлу

28:20.760 --> 28:22.760
и как ему там эти библиотеки загрузить,

28:22.760 --> 28:24.760
зализовывать таблицы импорта и прочее.

28:24.760 --> 28:26.760
То есть там это выброшено

28:26.760 --> 28:28.760
из ядра полностью в юзерспейс.

28:30.760 --> 28:32.760
Вот как он фиксирует.

28:32.760 --> 28:34.760
А под Windows

28:34.760 --> 28:36.760
все это

28:36.760 --> 28:38.760
относится к системным функциям.

28:38.760 --> 28:40.760
То есть там, в принципе, есть

28:40.760 --> 28:42.760
NTDLL, DLL, но NTDLL, DLL

28:42.760 --> 28:44.760
это такая

28:44.760 --> 28:46.760
неразрывная часть системы,

28:46.760 --> 28:48.760
хоть она и находится в юзерспейсе,

28:48.760 --> 28:50.760
что там происходит внутри не

28:50.760 --> 28:52.760
специфицируется.

28:52.760 --> 28:54.760
То есть там есть, конечно, какие-то

28:54.760 --> 28:56.760
экспортированные функции,

28:56.760 --> 28:58.760
которые вы можете вызывать,

28:58.760 --> 29:00.760
но внутреннее устройство, что оно там делает,

29:00.760 --> 29:02.760
по большому счету это как бы черный ящик.

29:02.760 --> 29:04.760
То есть

29:04.760 --> 29:06.760
поэтому под Windows это называется

29:06.760 --> 29:08.760
системный загрузчик.

29:08.760 --> 29:10.760
И это такая, ну,

29:10.760 --> 29:12.760
непоколебимая часть системы.

29:12.760 --> 29:14.760
Там, конечно, кое-что тоже

29:14.760 --> 29:16.760
можно навесить своими аддонами,

29:16.760 --> 29:18.760
но это вообще мало известная информация,

29:18.760 --> 29:20.760
хотя и...

29:22.760 --> 29:24.760
Некоторые различия

29:24.760 --> 29:26.760
в том,

29:26.760 --> 29:28.760
насколько процесс загрузки файлов

29:28.760 --> 29:30.760
он вот такой

29:30.760 --> 29:32.760
системно стандартизирован

29:32.760 --> 29:34.760
и наоборот отдан на

29:34.760 --> 29:36.760
усмотрение

29:36.760 --> 29:38.760
юзерспейса.

29:42.760 --> 29:44.760
Так.

29:44.760 --> 29:46.760
В общем, под Windows оно релаксируется

29:46.760 --> 29:48.760
и норм.

29:48.760 --> 29:50.760
Никаких проблем.

29:50.760 --> 29:52.760
Что происходит под Linux?

29:52.760 --> 29:54.760
Под Linux адвокации тоже существуют.

29:54.760 --> 29:56.760
Они тоже

29:56.760 --> 29:58.760
работают, но их народ

29:58.760 --> 30:00.760
почему-то панически боится.

30:00.760 --> 30:02.760
Видимо,

30:02.760 --> 30:04.760
с тех самых времен, когда вот эти вот

30:04.760 --> 30:06.760
библиотеки были неперемещаемы,

30:06.760 --> 30:08.760
вот с тех

30:08.760 --> 30:10.760
самых времен,

30:10.760 --> 30:12.760
релокация это нечто ужасное.

30:12.760 --> 30:14.760
Притом,

30:14.760 --> 30:16.760
нечто ужасное и не совсем.

30:16.760 --> 30:18.760
Ну, понимаете, что совсем

30:18.760 --> 30:20.760
от них отказаться невозможно.

30:20.760 --> 30:22.760
Например, если вы

30:22.760 --> 30:24.760
завели себе

30:24.760 --> 30:26.760
какой-то массивчик,

30:26.760 --> 30:28.760
такой глобальный массивчик,

30:28.760 --> 30:30.760
который содержит адреса ваших функций,

30:30.760 --> 30:34.760
то здесь без релокации

30:34.760 --> 30:36.760
взяться некуда.

30:36.760 --> 30:38.760
То есть у вас данные,

30:38.760 --> 30:40.760
которые содержат просто

30:40.760 --> 30:42.760
сырые адреса функций.

30:42.760 --> 30:44.760
И если ваш файл куда-то перемещается,

30:44.760 --> 30:46.760
эти адреса становятся неправильными.

30:48.760 --> 30:50.760
Как эти данные будут использоваться,

30:50.760 --> 30:52.760
ни компилятор, ни линкер

30:52.760 --> 30:54.760
в принципе не знает, знать не может.

30:54.760 --> 30:56.760
Поэтому единственное, что можно

30:56.760 --> 30:58.760
с этой табличкой сделать,

30:58.760 --> 31:00.760
это про нее написать релокацию.

31:00.760 --> 31:02.760
И они будут написаны.

31:02.760 --> 31:04.760
Вот что

31:04.760 --> 31:06.760
под линуксом считается

31:06.760 --> 31:08.760
прям вот какая-то

31:08.760 --> 31:10.760
смертельная

31:10.760 --> 31:12.760
такая

31:12.760 --> 31:14.760
не знаю как это сказать

31:14.760 --> 31:16.760
оплошность,

31:16.760 --> 31:18.760
это пытаться делать релокации

31:18.760 --> 31:20.760
по коду.

31:20.760 --> 31:22.760
То есть по данным

31:22.760 --> 31:24.760
релокации есть,

31:24.760 --> 31:26.760
про них тихо никто не вспоминает,

31:26.760 --> 31:28.760
потому что все равно деваться некуда.

31:28.760 --> 31:30.760
А вот

31:30.760 --> 31:32.760
для кода

31:32.760 --> 31:34.760
под виндой, для кода, для данных

31:34.760 --> 31:36.760
релокации просто работают

31:36.760 --> 31:38.760
под линуксом

31:38.760 --> 31:40.760
очень не модно делать

31:40.760 --> 31:42.760
релокации для кода.

31:42.760 --> 31:44.760
Считается, что код нужно написать

31:44.760 --> 31:46.760
в таком разрешенном виде,

31:46.760 --> 31:48.760
чтобы он был position independent.

31:50.760 --> 31:52.760
Да, я вам в прошлый раз приводил примеры,

31:52.760 --> 31:54.760
как нужно трансформировать ваш код,

31:54.760 --> 31:56.760
чтобы оно стало position independent.

31:56.760 --> 31:58.760
Особенно фигово

31:58.760 --> 32:00.760
с этим под x86

32:00.760 --> 32:02.760
рассылал видно.

32:02.760 --> 32:04.760
Почему?

32:04.760 --> 32:06.760
Потому что даже те же самые обращения в код

32:06.760 --> 32:08.760
suprise

32:08.760 --> 32:10.760
они не position independent.

32:10.760 --> 32:12.760
Когда вы пишете

32:12.760 --> 32:14.760
какую-нибудь

32:14.760 --> 32:16.760
командочку

32:16.760 --> 32:18.760
call

32:18.760 --> 32:20.760
вот так вот,

32:20.760 --> 32:22.760
вот здесь у вас

32:22.760 --> 32:24.760
абсолютный адрес.

32:24.760 --> 32:26.760
Поэтому

32:26.760 --> 32:28.760
вы не можете так писать.

32:28.760 --> 32:30.760
Вам нужно вот эту штуку

32:30.760 --> 32:32.760
трансформировать

32:32.760 --> 32:34.760
в извращение в n

32:34.760 --> 32:36.760
линий кода.

32:36.760 --> 32:38.760
И еще оно супер забавно

32:38.760 --> 32:40.760
в образом взаимодействует с plt.

32:40.760 --> 32:42.760
plt тоже выглядит не вот так вот,

32:42.760 --> 32:44.760
не в одну строчку.

32:44.760 --> 32:46.760
Там тоже вот так вот.

32:46.760 --> 32:48.760
Набор страданий и мучений

32:48.760 --> 32:50.760
ради того, чтобы сделать код

32:50.760 --> 32:52.760
position independent.

32:52.760 --> 32:54.760
Под 64-мя битвами

32:54.760 --> 32:56.760
ситуация сильно лучше,

32:56.760 --> 32:58.760
потому что у вас здесь есть

32:58.760 --> 33:00.760
значительная адресация.

33:00.760 --> 33:02.760
Поэтому

33:02.760 --> 33:04.760
по крайней мере в год

33:04.760 --> 33:06.760
вы можете ходить прям вот так вот

33:06.760 --> 33:08.760
и оно будет position independent.

33:10.760 --> 33:12.760
Вот.

33:12.760 --> 33:14.760
То есть

33:14.760 --> 33:16.760
как бы вот эта вся картина

33:16.760 --> 33:18.760
с библиотеками, она еще

33:18.760 --> 33:20.760
умножается на вот эту.

33:20.760 --> 33:22.760
Это про другое,

33:22.760 --> 33:24.760
но оно

33:24.760 --> 33:26.760
умножает сложность кода

33:26.760 --> 33:28.760
в

33:28.760 --> 33:30.760
вот этом.

33:30.760 --> 33:32.760
Все.

33:32.760 --> 33:34.760
Вы становитесь еще смешнее,

33:34.760 --> 33:36.760
особенно в 3D.

33:36.760 --> 33:38.760
Теперь,

33:38.760 --> 33:40.760
почему так религиозно страшно

33:40.760 --> 33:42.760
position independent код?

33:42.760 --> 33:44.760
Потому что

33:44.760 --> 33:46.760
ядро линукса не умеет

33:46.760 --> 33:48.760
шарить

33:48.760 --> 33:50.760
библиотеки,

33:50.760 --> 33:52.760
если они были перемещены.

33:52.760 --> 33:54.760
Потому что

33:54.760 --> 33:56.760
когда вы перемещаете библиотеку,

33:56.760 --> 33:58.760
вам

33:58.760 --> 34:00.760
что нужно сделать?

34:00.760 --> 34:02.760
Вам нужно вот вправить

34:02.760 --> 34:04.760
те места, куда попали релокации.

34:04.760 --> 34:06.760
То есть

34:06.760 --> 34:08.760
ваш образ

34:08.760 --> 34:10.760
библиотеки

34:10.760 --> 34:12.760
или исполняемого файла

34:12.760 --> 34:14.760
в памяти

34:14.760 --> 34:16.760
не то же самое, что на диске.

34:16.760 --> 34:18.760
И здесь работает

34:18.760 --> 34:20.760
штука в духе

34:20.760 --> 34:22.760
copy and write.

34:22.760 --> 34:24.760
То есть вот оно загрузилось

34:24.760 --> 34:26.760
и когда вы вправляете,

34:26.760 --> 34:28.760
это вот системный загрузчик,

34:28.760 --> 34:30.760
то вот это изменение

34:30.760 --> 34:32.760
это write.

34:32.760 --> 34:34.760
И оно приводит к тому,

34:34.760 --> 34:36.760
что создается как бы такая

34:36.760 --> 34:38.760
приватная копия страничек,

34:38.760 --> 34:40.760
которые соответствуют измененным данным.

34:42.760 --> 34:44.760
И, соответственно, про

34:44.760 --> 34:46.760
динамические библиотеки,

34:46.760 --> 34:48.760
если вот они так были

34:48.760 --> 34:50.760
перемещены,

34:50.760 --> 34:52.760
то вот эти вот вправленные странички

34:52.760 --> 34:54.760
они не шарятся.

34:56.760 --> 34:58.760
Понятно?

34:58.760 --> 35:00.760
Потом еще раз напоминаю,

35:00.760 --> 35:02.760
те странички данных,

35:02.760 --> 35:04.760
которые были перемещены,

35:04.760 --> 35:06.760
они тоже не шарятся.

35:06.760 --> 35:08.760
Но это почему-то никого не волнует.

35:08.760 --> 35:10.760
Почему-то очень важно, чтобы код пошарился.

35:14.760 --> 35:16.760
Вот.

35:16.760 --> 35:18.760
И поэтому

35:18.760 --> 35:20.760
так много страданий с этим пиком.

35:20.760 --> 35:22.760
Как эта картина

35:22.760 --> 35:24.760
работает под виндой?

35:24.760 --> 35:26.760
То есть,

35:26.760 --> 35:28.760
несколько процессоров

35:28.760 --> 35:30.760
загрузили эту библиотеку.

35:30.760 --> 35:32.760
Вот место,

35:32.760 --> 35:34.760
занимаемое этой библиотекой,

35:34.760 --> 35:36.760
вот кодом этой библиотеки в памяти.

35:36.760 --> 35:38.760
Сколько раз

35:38.760 --> 35:40.760
будет использовано в физической памяти?

35:40.760 --> 35:42.760
Мы немножко не дошли до этого.

35:42.760 --> 35:44.760
Там про страничную адресацию

35:44.760 --> 35:46.760
мы позже дойдем. Пока в двух словах.

35:46.760 --> 35:48.760
Если у тебя

35:48.760 --> 35:50.760
вот все хорошо случилось,

35:50.760 --> 35:52.760
то операционная система

35:52.760 --> 35:54.760
может потратить в физической памяти

35:54.760 --> 35:56.760
один раз,

35:56.760 --> 35:58.760
на все экземпляры,

35:58.760 --> 36:00.760
почти все экземпляры

36:00.760 --> 36:02.760
динамической библиотеки в разных процессах.

36:08.760 --> 36:10.760
Можно еще раз?

36:10.760 --> 36:12.760
Еще раз.

36:12.760 --> 36:14.760
Для понимания тебе,

36:14.760 --> 36:16.760
если ты не понимаешь то, что я говорю,

36:16.760 --> 36:18.760
тебе не хватает знаний.

36:18.760 --> 36:20.760
Да, вот мы об этом поговорим.

36:20.760 --> 36:22.760
Просто попозже.

36:22.760 --> 36:24.760
Просто я вижу, что здесь народ очень об этом понимает.

36:24.760 --> 36:26.760
И поэтому сейчас об этом рассказываю.

36:26.760 --> 36:28.760
То есть то, что ты сейчас

36:28.760 --> 36:30.760
не понимаешь то, что я говорю,

36:30.760 --> 36:32.760
это норма.

36:32.760 --> 36:34.760
Я вам действительно не рассказываю.

36:34.760 --> 36:36.760
Это знания из других предметов

36:36.760 --> 36:38.760
вообще это пересекается

36:38.760 --> 36:40.760
с курсом операционных систем.

36:40.760 --> 36:42.760
Поэтому кто там прошел осень,

36:42.760 --> 36:44.760
они надо с курсом.

36:44.760 --> 36:46.760
Потому что ты не прошел,

36:46.760 --> 36:48.760
не страшно, я расскажу эти знания

36:48.760 --> 36:50.760
просто попозже в курсе.

36:50.760 --> 36:52.760
Настя, мы реализовывали копенгайф

36:52.760 --> 36:54.760
для шарить страницы между

36:54.760 --> 36:56.760
разными процессами.

36:56.760 --> 36:58.760
Идею происходящего

36:58.760 --> 37:00.760
не страшно, если ты не до конца понимаешь.

37:00.760 --> 37:02.760
Я расскажу попозже.

37:04.760 --> 37:06.760
Так вот.

37:06.760 --> 37:08.760
В общем, еще раз обратите внимание,

37:08.760 --> 37:10.760
порции данных,

37:10.760 --> 37:12.760
на которые падают релокации,

37:12.760 --> 37:14.760
они не шарятся.

37:14.760 --> 37:16.760
В любом случае.

37:16.760 --> 37:18.760
Даже резонные данные,

37:18.760 --> 37:20.760
на которые падают релокации,

37:20.760 --> 37:22.760
не шарятся.

37:22.760 --> 37:24.760
Почему-то очень критично,

37:24.760 --> 37:26.760
чтобы он пошарился.

37:26.760 --> 37:28.760
Ну, окей.

37:28.760 --> 37:30.760
Такая мода.

37:30.760 --> 37:32.760
Но еще раз, я лично считаю,

37:32.760 --> 37:34.760
что мода какая-то необоснованная.

37:34.760 --> 37:36.760
Потому что выиграть по скорости

37:36.760 --> 37:38.760
за счет более короткого,

37:38.760 --> 37:40.760
более простого кода,

37:40.760 --> 37:42.760
с моей точки зрения,

37:42.760 --> 37:44.760
сегодня более актуально,

37:44.760 --> 37:46.760
чем потратить на 100 мегабайт

37:46.760 --> 37:48.760
меньше физической оперативки.

37:48.760 --> 37:50.760
Ну вот честно, что вам лучше,

37:50.760 --> 37:52.760
на 100 метрах меньше оперативки

37:52.760 --> 37:54.760
или работать на 5% быстрее?

37:54.760 --> 37:56.760
Мне кажется, почти все

37:56.760 --> 37:58.760
выберут на 5% быстрее.

37:58.760 --> 38:00.760
Потому что, ну,

38:00.760 --> 38:02.760
это не только оперативки.

38:02.760 --> 38:04.760
Пошарился он там, пошарился.

38:04.760 --> 38:06.760
Он все равно там, если он копирует плюсы,

38:06.760 --> 38:08.760
он несколько гигов сожрет.

38:08.760 --> 38:10.760
И вот это никак вообще

38:10.760 --> 38:12.760
не коррелирует с тем,

38:12.760 --> 38:14.760
пошарился он или не пошарился.

38:14.760 --> 38:16.760
Вот. Теперь, что происходит

38:16.760 --> 38:18.760
под виндой.

38:18.760 --> 38:20.760
Под виндой, как я уже сказал,

38:20.760 --> 38:22.760
сейчас очень моден АСЛР,

38:22.760 --> 38:24.760
и под виндой оно работает

38:24.760 --> 38:26.760
следующим образом.

38:26.760 --> 38:28.760
Независимо от того,

38:28.760 --> 38:30.760
куда там сказано в длке или экзечнике,

38:30.760 --> 38:32.760
что у него родная позиция,

38:32.760 --> 38:34.760
родная позиция памяти,

38:34.760 --> 38:36.760
система говорит,

38:36.760 --> 38:38.760
я считаю, что тебе нужно

38:38.760 --> 38:40.760
находиться по этому адресу.

38:40.760 --> 38:42.760
И пытается загрузить его по этому адресу.

38:42.760 --> 38:44.760
Притом этот адрес

38:44.760 --> 38:46.760
система выбирает не от балды,

38:46.760 --> 38:48.760
а у нее есть списочек,

38:48.760 --> 38:50.760
куда она там,

38:50.760 --> 38:52.760
в библиотеке распределила,

38:52.760 --> 38:54.760
поэтому шансов в этом списке

38:54.760 --> 38:56.760
пересечься очень мало.

38:56.760 --> 38:58.760
То есть этот список

38:58.760 --> 39:00.760
система строит на основе

39:00.760 --> 39:02.760
текущего распределения библиотек.

39:02.760 --> 39:04.760
В отличие от того,

39:04.760 --> 39:06.760
что вы на этапе линковки

39:06.760 --> 39:08.760
что-то указываете наобум,

39:08.760 --> 39:10.760
система видит, что у нее

39:10.760 --> 39:12.760
происходит в пространстве,

39:12.760 --> 39:14.760
и она строит вот этот список,

39:14.760 --> 39:16.760
кого она хочет куда-то загрузить,

39:16.760 --> 39:18.760
на основе текущих представлений

39:18.760 --> 39:20.760
и когда система

39:20.760 --> 39:22.760
грузит там дллку или экзешник

39:22.760 --> 39:24.760
и

39:24.760 --> 39:26.760
делает релокации,

39:26.760 --> 39:28.760
она вот

39:28.760 --> 39:30.760
по этому адресу

39:30.760 --> 39:32.760
данную

39:32.760 --> 39:34.760
дллку или экзешник

39:34.760 --> 39:36.760
будет и в других процессах

39:36.760 --> 39:38.760
пытаться загрузить.

39:38.760 --> 39:40.760
Соответственно,

39:40.760 --> 39:42.760
по этим адресам

39:42.760 --> 39:44.760
если ей удалось загрузить,

39:44.760 --> 39:46.760
то вот эти

39:46.760 --> 39:48.760
загруженные по тому,

39:48.760 --> 39:50.760
по которому она хотела адресу

39:50.760 --> 39:52.760
участки кода,

39:52.760 --> 39:54.760
они полностью шарятся между

39:54.760 --> 39:56.760
всеми процессами.

39:56.760 --> 39:58.760
На самом деле

39:58.760 --> 40:00.760
система, она делает релокации

40:00.760 --> 40:02.760
чуть по-другому.

40:02.760 --> 40:04.760
Она делает релокации

40:04.760 --> 40:06.760
в момент загрузки

40:06.760 --> 40:08.760
вот этих данных

40:08.760 --> 40:10.760
дллки из

40:10.760 --> 40:12.760
диска.

40:12.760 --> 40:14.760
То есть она не вначале грузит,

40:14.760 --> 40:16.760
а потом применяет

40:16.760 --> 40:18.760
релокацию.

40:18.760 --> 40:20.760
Она грузит и применяет

40:20.760 --> 40:22.760
релокации в момент загрузки.

40:22.760 --> 40:24.760
Поэтому, если данные

40:24.760 --> 40:26.760
вот эта дллка находится по тому адресу,

40:26.760 --> 40:28.760
по которому хочет ISLF,

40:28.760 --> 40:30.760
то с точки зрения винды

40:30.760 --> 40:32.760
это данные, которые никем не

40:32.760 --> 40:34.760
менялись и не надо делать

40:34.760 --> 40:36.760
copyright, потому что write не было.

40:36.760 --> 40:38.760
Оно было

40:38.760 --> 40:40.760
загружено в таком состоянии.

40:40.760 --> 40:42.760
И то, что он в диске не в таком

40:42.760 --> 40:44.760
состоянии, неважно.

40:44.760 --> 40:46.760
То есть оно в памяти первый раз

40:46.760 --> 40:48.760
оказалось сразу же в таком виде

40:48.760 --> 40:50.760
и это неизмененные данные.

40:50.760 --> 40:52.760
Linux так, похоже, не умеет.

40:52.760 --> 40:54.760
Я не специалист по Linux,

40:54.760 --> 40:56.760
но вот эти все заморочки с пиком

40:56.760 --> 40:58.760
говорят о том, что, похоже, он так не умеет делать.

41:02.760 --> 41:04.760
Ну, может быть, да.

41:04.760 --> 41:06.760
То есть там это делает ядро.

41:06.760 --> 41:08.760
То есть ядро, оно так грузит дллки,

41:08.760 --> 41:10.760
что оно знает, что вот дллки

41:10.760 --> 41:12.760
они вот в неизменном виде.

41:14.760 --> 41:16.760
Поэтому оно, как там

41:16.760 --> 41:18.760
ASLR их расставил,

41:18.760 --> 41:20.760
они находятся в таком как бы

41:20.760 --> 41:22.760
неизменном виде, если вы

41:22.760 --> 41:24.760
их как-то специально

41:24.760 --> 41:26.760
оттуда не передвинули. То есть, например,

41:26.760 --> 41:28.760
вы загрузили дллку в одном процессе

41:28.760 --> 41:30.760
по какому-то адресу, узнали этот

41:30.760 --> 41:32.760
адрес, в другом процессе

41:32.760 --> 41:34.760
специально в этом адресе

41:34.760 --> 41:36.760
что-то выделили, а потом попросили

41:36.760 --> 41:38.760
дллку загрузить в память, но чтобы

41:38.760 --> 41:40.760
она никак не могла загрузиться по одному адресу.

41:40.760 --> 41:42.760
Тогда она

41:42.760 --> 41:44.760
будет перемещена, ну и, конечно,

41:44.760 --> 41:46.760
эти странички перемещенные, они не будут

41:46.760 --> 41:48.760
пошарены, потому что там другие данные.

41:50.760 --> 41:52.760
Вот. Поэтому вот эта

41:52.760 --> 41:54.760
заморочка с пиком для меня лично выглядит

41:54.760 --> 41:56.760
очень дико под линуксом. То есть там

41:56.760 --> 41:58.760
прям везде написано

41:58.760 --> 42:00.760
динамические библиотеки должны быть пик.

42:00.760 --> 42:02.760
Не должны.

42:02.760 --> 42:04.760
Иначе они

42:04.760 --> 42:06.760
не шарятся. Не забыть добавить

42:06.760 --> 42:08.760
под линукс.

42:10.760 --> 42:12.760
То есть, в принципе, можно сделать динамические

42:12.760 --> 42:14.760
библиотеки сильно лучше и сильно

42:14.760 --> 42:16.760
проще. По-моему, вот эта вся картина

42:16.760 --> 42:18.760
выглядит супер монструозно.

42:20.760 --> 42:22.760
То есть там есть такие, да, полезные

42:22.760 --> 42:24.760
штучки, но в целом

42:24.760 --> 42:26.760
он бьет по скорости.

42:28.760 --> 42:30.760
Ну, сложно сказать.

42:30.760 --> 42:32.760
В каких местах конкретно?

42:32.760 --> 42:34.760
Это бьет по скорости,

42:34.760 --> 42:36.760
особенно больно по скорости

42:36.760 --> 42:38.760
динамические библиотеки.

42:38.760 --> 42:40.760
Вот, например, если пытаться

42:40.760 --> 42:42.760
LLBL

42:42.760 --> 42:44.760
сделать динамические библиотеки.

42:44.760 --> 42:46.760
Вот им здесь сразу плохеет.

42:46.760 --> 42:48.760
Потому что

42:48.760 --> 42:50.760
все обращения

42:50.760 --> 42:52.760
к их личным функциям

42:52.760 --> 42:54.760
они начинают ходить сквозь вот этот год,

42:54.760 --> 42:56.760
что

42:56.760 --> 42:58.760
дополнительный, то есть

42:58.760 --> 43:00.760
стоимость примерно как стоимость

43:00.760 --> 43:02.760
виртуальной функции.

43:02.760 --> 43:04.760
Представляете стоимость

43:04.760 --> 43:06.760
виртуальной функции? Вот это

43:06.760 --> 43:08.760
тоже самое. Плюс одна

43:08.760 --> 43:10.760
индирекция.

43:10.760 --> 43:12.760
Вместо обычного вызова функции

43:12.760 --> 43:14.760
у вас как бы вызов, как бы

43:14.760 --> 43:16.760
все ваши функции стоят виртуально.

43:16.760 --> 43:18.760
Вот такая стоимость.

43:18.760 --> 43:20.760
Это стоимость года.

43:20.760 --> 43:22.760
А стоимость пика

43:22.760 --> 43:24.760
это еще плюс к этому

43:24.760 --> 43:26.760
дополнительный код,

43:26.760 --> 43:28.760
у которого меньше под

43:28.760 --> 43:30.760
64 битами и больше

43:30.760 --> 43:32.760
под 37.

43:32.760 --> 43:34.760
Это уже, ну, не знаю,

43:34.760 --> 43:36.760
причем профессионалов, потому что такого прямого

43:36.760 --> 43:38.760
она уже нет.

43:38.760 --> 43:40.760
Вот. Но, как бы,

43:40.760 --> 43:42.760
идеи ничего не имеем.

43:42.760 --> 43:44.760
Под всеми операционками есть какая-то

43:44.760 --> 43:46.760
такая своя фигня. Под Windows я сказал

43:46.760 --> 43:48.760
там прям такой огромный такой

43:48.760 --> 43:50.760
ляп в конвенции вызова,

43:50.760 --> 43:52.760
что они там про

43:52.760 --> 43:54.760
xml-регистры сказали полный бред.

43:54.760 --> 43:56.760
Теперь с этим ничего не поделать.

43:56.760 --> 43:58.760
Под Linux вот такая

43:58.760 --> 44:00.760
заморочка с библиотеками, которая

44:00.760 --> 44:02.760
как-то, ну, пытается

44:02.760 --> 44:04.760
привестись к цивилизованному

44:04.760 --> 44:06.760
виду, но это далеко не дефолт.

44:06.760 --> 44:08.760
Оно так медленно

44:08.760 --> 44:10.760
ползет в ту сторону и

44:10.760 --> 44:12.760
общая картина не

44:12.760 --> 44:14.760
начинается.

44:22.760 --> 44:24.760
Если у тебя

44:24.760 --> 44:26.760
нет вообще никаких

44:26.760 --> 44:28.760
библиотек,

44:28.760 --> 44:30.760
от которых зависит твой файл,

44:30.760 --> 44:32.760
тогда

44:32.760 --> 44:34.760
твой файл способен загрузить

44:34.760 --> 44:36.760
вот в системный загрузчик

44:36.760 --> 44:38.760
в смысле Hydro.

44:42.760 --> 44:44.760
То есть, если у тебя есть

44:44.760 --> 44:46.760
библиотека с статическими библиотеками,

44:46.760 --> 44:48.760
вот эта вся тема с списками

44:48.760 --> 44:50.760
импортов и

44:50.760 --> 44:52.760
она вся

44:52.760 --> 44:54.760
резовывается во время веков.

44:54.760 --> 44:56.760
И там уже написано.

44:56.760 --> 44:58.760
Вот ты говоришь про

44:58.760 --> 45:00.760
экзешник, да?

45:00.760 --> 45:02.760
Экзешник, и он зависит только

45:02.760 --> 45:04.760
от статических библиотек.

45:04.760 --> 45:06.760
Вот экзешник. Он зависит только

45:06.760 --> 45:08.760
от статических библиотек, когда у него

45:08.760 --> 45:10.760
все это резовывается.

45:10.760 --> 45:12.760
Если экзешник зависит от какой-то функции

45:12.760 --> 45:14.760
от динамической библиотеки,

45:14.760 --> 45:16.760
то по дефолту

45:16.760 --> 45:18.760
современные линкеры

45:18.760 --> 45:20.760
они делают такую оптимизацию,

45:20.760 --> 45:22.760
что через вот эту таблицу

45:22.760 --> 45:24.760
год проходит только

45:24.760 --> 45:26.760
одна эта функция.

45:26.760 --> 45:28.760
То есть в экзешнике

45:28.760 --> 45:30.760
вреда от этой картины

45:30.760 --> 45:32.760
минимум.

45:32.760 --> 45:34.760
Но тоже, правда,

45:34.760 --> 45:36.760
зависит от того, какими ключиками ты

45:36.760 --> 45:38.760
скомпилируешь свой экзешник.

45:38.760 --> 45:40.760
Но с более-менее дефолтными

45:40.760 --> 45:42.760
ключиками. Твой экзешник

45:42.760 --> 45:44.760
будет сквозь вот эти таблички ходить

45:44.760 --> 45:46.760
только действительно в динамические библиотеки.

45:46.760 --> 45:48.760
Если у него есть своя функция

45:48.760 --> 45:50.760
pull, он напрямую в нее пройдет

45:50.760 --> 45:52.760
без табличек.

45:52.760 --> 45:54.760
То есть

45:54.760 --> 45:56.760
экзешники, они по минимуму

45:56.760 --> 45:58.760
страдают от этой картины.

46:00.760 --> 46:02.760
А вот

46:02.760 --> 46:04.760
динамические библиотеки страдают

46:04.760 --> 46:06.760
по комнатке.

46:08.760 --> 46:10.760
И потенциально для экзешника

46:10.760 --> 46:12.760
ты даже можешь пик отключить.

46:12.760 --> 46:14.760
Но тогда ты

46:14.760 --> 46:16.760
будешь несовместим с SLR.

46:18.760 --> 46:20.760
Да, кстати говоря, вот этот пик

46:20.760 --> 46:22.760
для экзешника называется

46:22.760 --> 46:24.760
PE.

46:26.760 --> 46:28.760
PE это такая

46:28.760 --> 46:30.760
специфическая версия пика,

46:30.760 --> 46:32.760
которая годится только для экзешника.

46:34.760 --> 46:36.760
Я не помню, что там происходит. Мне кажется,

46:36.760 --> 46:38.760
как раз вот про то, что не надо

46:38.760 --> 46:40.760
гнать через год таблицу

46:40.760 --> 46:42.760
импортера.

46:42.760 --> 46:44.760
В чем

46:44.760 --> 46:46.760
отвечает?

46:46.760 --> 46:48.760
Я не помню.

46:48.760 --> 46:50.760
Понятно.

46:54.760 --> 46:56.760
То есть ваш экзешник,

46:56.760 --> 46:58.760
если вы хотите быть модным,

46:58.760 --> 47:00.760
то нужно

47:00.760 --> 47:02.760
компилировать вот с таким ключом.

47:02.760 --> 47:04.760
А он, кстати, по дефолту так.

47:04.760 --> 47:06.760
Ну или даже по дефолту.

47:06.760 --> 47:08.760
Я недавно его отключал.

47:08.760 --> 47:10.760
Ну вот, да.

47:10.760 --> 47:12.760
Если вы хотите быть модным,

47:12.760 --> 47:14.760
то нужно компилировать вот

47:14.760 --> 47:16.760
с таким ключом.

47:18.760 --> 47:20.760
Но потенциально,

47:20.760 --> 47:22.760
потенциально по биноксам

47:22.760 --> 47:24.760
есть релокации.

47:24.760 --> 47:26.760
Поэтому, наверное,

47:26.760 --> 47:28.760
можно скомпилировать динамическую библиотеку

47:28.760 --> 47:30.760
как перемещаемую, но не пик.

47:32.760 --> 47:34.760
И, наверное, если еще добавить

47:34.760 --> 47:36.760
по символику,

47:36.760 --> 47:38.760
наверное, оно будет почти прям как по биндой

47:38.760 --> 47:40.760
по скорости.

47:40.760 --> 47:42.760
Ну еще раз, это надо

47:42.760 --> 47:44.760
экспериментировать

47:44.760 --> 47:46.760
и иметь вначале проблему,

47:46.760 --> 47:48.760
которую вы решаете,

47:48.760 --> 47:50.760
а не решать, вот у меня есть решение,

47:50.760 --> 47:52.760
я хочу найти проблему.

48:02.760 --> 48:04.760
Ну вот это вот

48:04.760 --> 48:06.760
происходящее с динамическими

48:06.760 --> 48:08.760
библиотеками.

48:08.760 --> 48:10.760
Причем мы там все время сажали,

48:10.760 --> 48:12.760
да.

48:12.760 --> 48:14.760
Еще раз,

48:14.760 --> 48:16.760
если мы будем ставить f-визибилити,

48:16.760 --> 48:18.760
hidden, будем поставлять везде

48:18.760 --> 48:20.760
type of visibility, будем

48:20.760 --> 48:22.760
использовать b-символик, у нас будет, наверное,

48:22.760 --> 48:24.760
то же самое, что на b-динамике, по скорости.

48:24.760 --> 48:26.760
А не совсем.

48:26.760 --> 48:28.760
У тебя все равно этот

48:28.760 --> 48:30.760
resolving, то, что у тебя

48:30.760 --> 48:32.760
проходит сквозь импорт,

48:32.760 --> 48:34.760
оно все равно оставляет тебе марксовок.

48:34.760 --> 48:36.760
Вот этот resolving, он

48:36.760 --> 48:38.760
все равно неизбежно будет медленным.

48:38.760 --> 48:40.760
Потому что ты импортируешь

48:40.760 --> 48:42.760
не из библиотеки,

48:42.760 --> 48:44.760
а из пространства.

48:44.760 --> 48:46.760
Но, по крайней мере,

48:46.760 --> 48:48.760
вот внутренние вызовы всякие,

48:48.760 --> 48:50.760
они не будут медленными.

48:50.760 --> 48:52.760
И твоя таблица экспорта,

48:52.760 --> 48:54.760
вот эта огромная

48:54.760 --> 48:56.760
штука, где нужно искать,

48:56.760 --> 48:58.760
она будет меньше.

48:58.760 --> 49:00.760
То есть это будет не совсем как под винтой,

49:00.760 --> 49:02.760
потому что у тебя нет вот этой вот

49:02.760 --> 49:04.760
прямой связи.

49:04.760 --> 49:06.760
Но оно будет максимально близко,

49:06.760 --> 49:08.760
что ты можешь получить, как я понимаю,

49:08.760 --> 49:10.760
под линуксом с адаптными способами.

49:10.760 --> 49:12.760
То есть это, наверное,

49:12.760 --> 49:14.760
юникс-подобные системы,

49:14.760 --> 49:16.760
где пытались вот такую штуку строить,

49:16.760 --> 49:18.760
но я не настолько специалист

49:18.760 --> 49:20.760
по юникс-подобному миру,

49:20.760 --> 49:22.760
чтобы рассказать, что там происходит.

49:22.760 --> 49:24.760
То есть я читал, что кое-кто что-то делал.

49:24.760 --> 49:26.760
Но, по крайней мере,

49:26.760 --> 49:28.760
линукс обошелся.

49:28.760 --> 49:30.760
Знаешь еще что делает

49:30.760 --> 49:32.760
басимволик?

49:32.760 --> 49:34.760
Что?

49:34.760 --> 49:36.760
Басимволик говорит

49:36.760 --> 49:38.760
вести себя

49:38.760 --> 49:40.760
в динамической библиотеке

49:40.760 --> 49:42.760
так же, как ведет себя

49:42.760 --> 49:44.760
экзешник.

49:44.760 --> 49:46.760
Еще раз, экзешники,

49:46.760 --> 49:48.760
если у тебя происходит вызов

49:48.760 --> 49:50.760
функции,

49:50.760 --> 49:52.760
то у тебя есть функция.

49:52.760 --> 49:54.760
Нет, это

49:54.760 --> 49:56.760
все это про проблемы линукса.

49:56.760 --> 49:58.760
Под винтой вот никаких этих проблем

49:58.760 --> 50:00.760
просто нет.

50:00.760 --> 50:02.760
Там вам нужно

50:02.760 --> 50:04.760
из проблем в своем коде

50:04.760 --> 50:06.760
указывать,

50:06.760 --> 50:08.760
если вы пишете в динамическую библиотеку,

50:08.760 --> 50:10.760
что вот это DLL export.

50:10.760 --> 50:12.760
Вы не укажете,

50:12.760 --> 50:14.760
ваши функции не экспортируются,

50:14.760 --> 50:16.760
у вас потом нифига не слимкуется.

50:16.760 --> 50:18.760
То есть вы прям сразу видите,

50:18.760 --> 50:20.760
что я что-то делаю не так.

50:20.760 --> 50:22.760
Если вы не указываете

50:22.760 --> 50:24.760
под винтой DLL import,

50:24.760 --> 50:26.760
тогда у вас возникнет

50:26.760 --> 50:28.760
вот подобная заглушка.

50:28.760 --> 50:30.760
Вам линкер ставят,

50:30.760 --> 50:32.760
то есть оно работать будет,

50:32.760 --> 50:34.760
но через дополнительный переход.

50:34.760 --> 50:36.760
Ну, то есть тоже чуть медленнее,

50:36.760 --> 50:38.760
но не очень критично.

50:38.760 --> 50:40.760
Если вы DLL import тоже пишете,

50:40.760 --> 50:42.760
тогда у вас будет прям вот сразу

50:42.760 --> 50:44.760
прямой красивый вызов

50:44.760 --> 50:46.760
минимум кода.

50:46.760 --> 50:48.760
А DLL import,

50:48.760 --> 50:50.760
если не указывать,

50:50.760 --> 50:52.760
можно отключить влогинг на это?

50:52.760 --> 50:54.760
То есть чтобы он не ставил заглушку?

50:54.760 --> 50:56.760
Нет.

50:56.760 --> 50:58.760
И еще раз, DLL import,

50:58.760 --> 51:00.760
он критичен только для данных.

51:00.760 --> 51:02.760
Для кода

51:02.760 --> 51:04.760
это незначительная потеря

51:04.760 --> 51:06.760
по скорости.

51:06.760 --> 51:08.760
Переход прямой.

51:08.760 --> 51:10.760
То есть там ничего предсказывать не надо.

51:10.760 --> 51:12.760
Оно не очень дорого.

51:12.760 --> 51:14.760
То есть оно немножко портит тебе кэш,

51:14.760 --> 51:16.760
что ты переходишь

51:16.760 --> 51:18.760
кто-то узнает куда.

51:18.760 --> 51:20.760
Но не очень дорого.

51:22.760 --> 51:24.760
Да, вот здесь у вас вызов фу.

51:26.760 --> 51:28.760
Да, и вот здесь

51:28.760 --> 51:30.760
будет прямой вызов.

51:30.760 --> 51:32.760
Почему?

51:32.760 --> 51:34.760
Потому что, конечно, потенциально

51:34.760 --> 51:36.760
нужно построить таблицу год.

51:40.760 --> 51:42.760
Но, так как в этих глобальных

51:42.760 --> 51:44.760
правилах, вы

51:44.760 --> 51:46.760
в язычниках абсолютно всегда

51:46.760 --> 51:48.760
смотрите на первом месте.

51:48.760 --> 51:50.760
Поэтому, если у вас

51:50.760 --> 51:52.760
эта функция здесь есть,

51:52.760 --> 51:54.760
то гарантированно

51:54.760 --> 51:56.760
здесь будет ровно она.

51:56.760 --> 51:58.760
Поэтому современно...

52:00.760 --> 52:02.760
Да.

52:02.760 --> 52:04.760
Поэтому нет необходимости гнать

52:04.760 --> 52:06.760
поиск год, потому что мы

52:06.760 --> 52:08.760
точно пойдем в это место.

52:08.760 --> 52:10.760
Поэтому

52:10.760 --> 52:12.760
линкер может тебе сделать

52:12.760 --> 52:14.760
прямой вызов, а не

52:14.760 --> 52:16.760
ПЛТ на год и бла-бла-бла.

52:18.760 --> 52:20.760
Но так можно

52:20.760 --> 52:22.760
сделать только с экзешн.

52:22.760 --> 52:24.760
А бейсимволик

52:24.760 --> 52:26.760
говорит, а так же

52:26.760 --> 52:28.760
делай мне

52:28.760 --> 52:30.760
с эсошкой.

52:30.760 --> 52:32.760
То есть это не

52:32.760 --> 52:34.760
стандартное поведение, никак принято.

52:34.760 --> 52:36.760
Типа с библиотечными

52:36.760 --> 52:38.760
правилами. Да.

52:38.760 --> 52:40.760
То есть вот в таком же режиме,

52:40.760 --> 52:42.760
если у меня есть функция,

52:42.760 --> 52:44.760
так сделай мне прямой вызов,

52:44.760 --> 52:46.760
не надо сквозь год это гнать.

52:48.760 --> 52:50.760
То есть это ближе к тому,

52:50.760 --> 52:52.760
как работают виндовые функции.

52:54.760 --> 52:56.760
То есть еще раз, если вы говорите

52:56.760 --> 52:58.760
вот это и вот это,

52:58.760 --> 53:00.760
вы получаете максимально

53:00.760 --> 53:02.760
похожую картину на эту,

53:02.760 --> 53:04.760
но с точностью только до того, что у вас

53:04.760 --> 53:06.760
есть пространство, а не стереотип.

53:06.760 --> 53:08.760
В случае,

53:08.760 --> 53:10.760
если у нас включен левый голый,

53:10.760 --> 53:12.760
бейсимволик и бейсбит хитом,

53:12.760 --> 53:14.760
у нас левый голый будет только на этапе

53:14.760 --> 53:16.760
запуска.

53:16.760 --> 53:18.760
Ну и что у вас будет

53:18.760 --> 53:20.760
обращаться за пик?

53:24.760 --> 53:26.760
В остальном обращение

53:26.760 --> 53:28.760
к функциям, которые

53:28.760 --> 53:30.760
в других эсошках лежат,

53:30.760 --> 53:32.760
они будут по стоимости

53:32.760 --> 53:34.760
ровно один и девять джамп.

53:34.760 --> 53:36.760
Нет, два джампа.

53:36.760 --> 53:38.760
У тебя будет джамп на PLT,

53:38.760 --> 53:40.760
и здесь будет джамп

53:40.760 --> 53:42.760
вот этот косвенный.

53:42.760 --> 53:44.760
Вот такой будет джамп.

53:44.760 --> 53:46.760
Она не может поставить тебя сюда,

53:46.760 --> 53:48.760
потому что у тебя нет атрибута

53:48.760 --> 53:50.760
DLL-импорт.

53:50.760 --> 53:52.760
То есть ты можешь

53:52.760 --> 53:54.760
не говорить, и тогда будет

53:54.760 --> 53:56.760
такая же картина, а можешь сказать

53:56.760 --> 53:58.760
атрибут DLL-импорт,

53:58.760 --> 54:00.760
и у тебя будет сразу вот так.

54:00.760 --> 54:02.760
Но под линуксом вроде

54:02.760 --> 54:04.760
такого атрибута не существует.

54:04.760 --> 54:06.760
Поэтому ты можешь сказать,

54:06.760 --> 54:08.760
либо компилятор всегда все функции

54:08.760 --> 54:10.760
гонит в таком виде,

54:10.760 --> 54:12.760
либо все функции гонит в таком виде.

54:12.760 --> 54:14.760
То есть, насколько я понимаю,

54:14.760 --> 54:16.760
он не умеет различать,

54:16.760 --> 54:18.760
какие функции импортируются,

54:18.760 --> 54:20.760
а какие не импортируются.

54:20.760 --> 54:22.760
Ну это уже косяк компилятора.

54:22.760 --> 54:24.760
Ну это недостаточная информация.

54:24.760 --> 54:26.760
Может у них есть какие-то логические атрибуты,

54:26.760 --> 54:28.760
я просто не в курсе.

54:28.760 --> 54:30.760
Атрибуты в VCC, я думаю,

54:30.760 --> 54:32.760
я уже сколько-то знаю.

54:32.760 --> 54:34.760
Можно еще раз по мнемонике

54:34.760 --> 54:36.760
кола понять, у нас VCC-related

54:36.760 --> 54:38.760
или VCC-related?

54:38.760 --> 54:40.760
Есть секретное знание,

54:40.760 --> 54:42.760
что вот такой кол

54:42.760 --> 54:44.760
это относительный вызов.

54:44.760 --> 54:46.760
А если кол-фу?

54:46.760 --> 54:48.760
Без разницы.

54:48.760 --> 54:50.760
Когда ты здесь пишешь

54:50.760 --> 54:52.760
число,

54:52.760 --> 54:54.760
то компилится

54:54.760 --> 54:56.760
не число,

54:56.760 --> 54:58.760
а

54:58.760 --> 55:00.760
разница между

55:00.760 --> 55:02.760
следующей командой

55:02.760 --> 55:04.760
и твоим числом.

55:04.760 --> 55:06.760
То есть обычный кол,

55:06.760 --> 55:08.760
кол-константа

55:08.760 --> 55:10.760
или кол-метка,

55:10.760 --> 55:12.760
то же самое.

55:12.760 --> 55:14.760
Он выглядит, как будто

55:14.760 --> 55:16.760
он переходит по абсолютному марку.

55:16.760 --> 55:18.760
Но на самом деле

55:18.760 --> 55:20.760
это

55:20.760 --> 55:22.760
относительный переход.

55:26.760 --> 55:28.760
Условные переходы,

55:28.760 --> 55:30.760
они тоже все относительные.

55:30.760 --> 55:32.760
Абсолютные переходы

55:32.760 --> 55:34.760
это либо

55:34.760 --> 55:36.760
кол-регистр,

55:36.760 --> 55:38.760
очевидно, ты переходишь по значению регистра,

55:38.760 --> 55:40.760
либо

55:40.760 --> 55:42.760
кол с квадратными скобками,

55:42.760 --> 55:44.760
где внутри не риг.

55:48.760 --> 55:50.760
Тогда это тоже абсолютный...

55:50.760 --> 55:52.760
Да оно и число написали.

55:52.760 --> 55:54.760
И метку.

55:54.760 --> 55:56.760
Метка и число это одно и то же.

55:56.760 --> 55:58.760
Я понял.

56:00.760 --> 56:02.760
Еще вопросы?

56:02.760 --> 56:04.760
Просто я чувствую,

56:04.760 --> 56:06.760
что, наверное,

56:06.760 --> 56:08.760
синт сегодня.

56:08.760 --> 56:10.760
А можно еще

56:10.760 --> 56:12.760
тогда вопрос тоже про

56:12.760 --> 56:14.760
анимоники про Лея?

56:14.760 --> 56:16.760
Вот если у нас Лея

56:16.760 --> 56:18.760
эра икс, запятая,

56:18.760 --> 56:20.760
и топка Эрбуринс там,

56:20.760 --> 56:22.760
и тоже эра икс,

56:22.760 --> 56:24.760
как понять, что у нас боится,

56:24.760 --> 56:26.760
что офсет?

56:26.760 --> 56:28.760
А почему тебе это важно?

56:28.760 --> 56:30.760
Потому что

56:30.760 --> 56:32.760
это разная кодировка.

56:32.760 --> 56:34.760
Но как бы

56:34.760 --> 56:36.760
а в чем ты увидишь разницу?

56:36.760 --> 56:38.760
Ну и в чем? Ну просто кодировки разные.

56:38.760 --> 56:40.760
Не, на самом деле там есть некая разница,

56:40.760 --> 56:42.760
но

56:42.760 --> 56:44.760
не про Лея.

56:44.760 --> 56:46.760
Ну мы еще немножко

56:46.760 --> 56:48.760
не дошли до того.

56:48.760 --> 56:50.760
Я вас так берегу пока

56:50.760 --> 56:52.760
и не говорю такое

56:52.760 --> 56:54.760
с того как сегменты.

56:54.760 --> 56:56.760
На самом деле с сегментами

56:56.760 --> 56:58.760
там может быть разница,

56:58.760 --> 57:00.760
хотя в твоем примере разницы не будет.

57:00.760 --> 57:02.760
То есть что у тебя а икс,

57:02.760 --> 57:04.760
что у тебя в икс база,

57:04.760 --> 57:06.760
оно будет работать везде одинаково.

57:06.760 --> 57:08.760
И от того,

57:08.760 --> 57:10.760
что ты закодируешь так или иначе,

57:10.760 --> 57:12.760
вот это вообще ни на что не влияет.

57:12.760 --> 57:14.760
Ну,

57:14.760 --> 57:16.760
анализ может повлиять как-то

57:16.760 --> 57:18.760
на какое-то.

57:18.760 --> 57:20.760
Нет, то есть конечно

57:20.760 --> 57:22.760
некоторые разные

57:22.760 --> 57:24.760
битники кодируют эту команду,

57:24.760 --> 57:26.760
но поведение абсолютно одинаковое.

57:26.760 --> 57:28.760
Вообще такое встречается нередко.

57:28.760 --> 57:30.760
У тебя,

57:30.760 --> 57:32.760
например,

57:32.760 --> 57:34.760
есть разные способы

57:34.760 --> 57:36.760
закодировать одну команду.

57:36.760 --> 57:38.760
Нередко это способы

57:38.760 --> 57:40.760
разной длины.

57:40.760 --> 57:42.760
Но есть даже и

57:42.760 --> 57:44.760
одинаковые длинные способы,

57:44.760 --> 57:46.760
которые позволяют вам

57:46.760 --> 57:48.760
совсем то же самое выразить.

57:48.760 --> 57:50.760
Ну да, у вас как бы соотношение

57:50.760 --> 57:52.760
между басендером и машинным кодом

57:52.760 --> 57:54.760
не совсем одинаковое.

57:54.760 --> 57:56.760
То есть я по мнемонике не могу понять.

57:56.760 --> 57:58.760
Нет, у тебя просто неоднозначность.

57:58.760 --> 58:00.760
Они эквивалентны.

58:00.760 --> 58:02.760
А как понять, что компилятор

58:02.760 --> 58:04.760
будет использоваться?

58:04.760 --> 58:06.760
Что ему хочется, то и будет.

58:06.760 --> 58:08.760
А зачем?

58:08.760 --> 58:10.760
Не влияет на результат работы.

58:10.760 --> 58:12.760
И конкретный

58:12.760 --> 58:14.760
компилятор, он работает

58:14.760 --> 58:16.760
детерминированно. Он будет всегда

58:16.760 --> 58:18.760
генерировать одну и ту же форму.

58:20.760 --> 58:22.760
Поэтому

58:22.760 --> 58:24.760
вот еще раз скажу, ты можешь почувствовать

58:24.760 --> 58:26.760
эту разницу.

58:26.760 --> 58:28.760
То есть да, потенциально

58:28.760 --> 58:30.760
возможны разные

58:30.760 --> 58:32.760
байтовые

58:32.760 --> 58:34.760
результаты,

58:34.760 --> 58:36.760
но они

58:36.760 --> 58:38.760
абсолютно эквивалентны.

58:38.760 --> 58:40.760
Поэтому

58:40.760 --> 58:42.760
там, где абсолютно все эквивалентно,

58:42.760 --> 58:44.760
народ не заморачивается.

58:46.760 --> 58:48.760
Вот там, где у тебя есть разные

58:48.760 --> 58:50.760
варианты, например, вы пишете

58:50.760 --> 58:52.760
mov квадратные скобочки

58:52.760 --> 58:54.760
запятая ноль.

58:54.760 --> 58:56.760
В чем здесь

58:56.760 --> 58:58.760
неоднозначность?

58:58.760 --> 59:00.760
Размерность.

59:00.760 --> 59:02.760
Да, размерность.

59:02.760 --> 59:04.760
Вот здесь хорошие

59:04.760 --> 59:06.760
компиляторы, такие как NASA,

59:06.760 --> 59:08.760
вам скажут error, неоднозначность.

59:08.760 --> 59:10.760
То есть здесь по смыслу

59:10.760 --> 59:12.760
разное поведение.

59:12.760 --> 59:14.760
И есть способ его уточнить.

59:16.760 --> 59:18.760
А здесь

59:18.760 --> 59:20.760
может и можно как-то уточнить,

59:20.760 --> 59:22.760
но зачем, я не понимаю.

59:24.760 --> 59:26.760
Возможно,

59:26.760 --> 59:28.760
есть какие-то правила конкретного

59:28.760 --> 59:30.760
компилятора, что, например,

59:30.760 --> 59:32.760
первый репистор считается базой,

59:32.760 --> 59:34.760
если не может, второй

59:34.760 --> 59:36.760
индексом, если не может.

59:36.760 --> 59:38.760
Но

59:38.760 --> 59:40.760
это несущественный момент.

59:44.760 --> 59:46.760
Просто

59:46.760 --> 59:48.760
сразу думаете, а правда ли, что

59:48.760 --> 59:50.760
получается, может быть, такое, что

59:50.760 --> 59:52.760
мы компилируем

59:52.760 --> 59:54.760
основную версию компилятора и

59:54.760 --> 59:56.760
что-то другое.

59:56.760 --> 59:58.760
Ну и что?

59:58.760 --> 01:00:00.760
Ну а почему вообще разные

01:00:00.760 --> 01:00:02.760
компиляторы должны тебе по байту

01:00:02.760 --> 01:00:04.760
дать одинаковый ход?

01:00:04.760 --> 01:00:06.760
Это вообще непонятно.

01:00:06.760 --> 01:00:08.760
Один и тот же компилятор

01:00:08.760 --> 01:00:10.760
ходит в двух разных прогонах,

01:00:10.760 --> 01:00:12.760
спустя 5 секунд может дать

01:00:12.760 --> 01:00:14.760
разный по байту результат.

01:00:14.760 --> 01:00:16.760
Нет, оно есть, просто

01:00:16.760 --> 01:00:18.760
оно обычно отключается.

01:00:18.760 --> 01:00:20.760
Нет.

01:00:20.760 --> 01:00:22.760
Они стараются сделать, чтобы

01:00:22.760 --> 01:00:24.760
такого не было. Единственное, что может

01:00:24.760 --> 01:00:26.760
отключаться, это

01:00:26.760 --> 01:00:28.760
в исполняемом файле, не знаю, как подмутся,

01:00:28.760 --> 01:00:30.760
наверное, то же самое, просто под виндой

01:00:30.760 --> 01:00:32.760
в PE этого формата исполняемого

01:00:32.760 --> 01:00:34.760
файла, там есть поле

01:00:34.760 --> 01:00:36.760
время компиляции,

01:00:36.760 --> 01:00:38.760
которое по дефолту компилятор

01:00:38.760 --> 01:00:40.760
честно ставит в текущее

01:00:40.760 --> 01:00:42.760
время. Поэтому оно,

01:00:42.760 --> 01:00:44.760
конечно, будет отключаться.

01:00:44.760 --> 01:00:46.760
Но если вам совсем приспичило,

01:00:46.760 --> 01:00:48.760
например, вы

01:00:48.760 --> 01:00:50.760
хотите, чтобы ваш билд

01:00:50.760 --> 01:00:52.760
был полностью повторяемым,

01:00:52.760 --> 01:00:54.760
например, вы собираетесь его подписывать

01:00:54.760 --> 01:00:56.760
или еще чего-нибудь там,

01:00:56.760 --> 01:00:58.760
то вам может поставить специальный ключ

01:00:58.760 --> 01:01:00.760
от линкера, что это должен быть

01:01:00.760 --> 01:01:02.760
полностью повторяемый билд,

01:01:02.760 --> 01:01:04.760
и тогда отметки времени ставятся просто

01:01:04.760 --> 01:01:06.760
в ноль, и у вас получится

01:01:06.760 --> 01:01:08.760
полностью одинаковый файл,

01:01:08.760 --> 01:01:10.760
если вы одно и то же перекомпилируете.

01:01:10.760 --> 01:01:12.760
То, что отличается,

01:01:12.760 --> 01:01:14.760
только отметки времени могут отличаться.

01:01:16.760 --> 01:01:18.760
Никаких других отличий быть не должно.

01:01:18.760 --> 01:01:20.760
Компилятор эта штука не применима.

01:01:20.760 --> 01:01:22.760
А там можно использовать

01:01:22.760 --> 01:01:24.760
пирандомизацию в хешмапах, и за это можно

01:01:24.760 --> 01:01:26.760
сделать разный порядок.

01:01:26.760 --> 01:01:28.760
И что, они будут рандомизировать

01:01:28.760 --> 01:01:30.760
себе не от данных, а от времени?

01:01:30.760 --> 01:01:32.760
Я говорю, что такое может случаться,

01:01:32.760 --> 01:01:34.760
и с этим борются.

01:01:34.760 --> 01:01:36.760
Просто рандомизация от чего там происходит?

01:01:36.760 --> 01:01:38.760
Если у тебя рандомизируется

01:01:38.760 --> 01:01:40.760
от данных, то данные они

01:01:40.760 --> 01:01:42.760
не должны быть от меня.

01:01:42.760 --> 01:01:44.760
Рандомизацию можно использовать

01:01:44.760 --> 01:01:46.760
просто тупо ранд,

01:01:46.760 --> 01:01:48.760
инициализированный бэйбл.

01:01:48.760 --> 01:01:50.760
Ранд от чего?

01:01:50.760 --> 01:01:52.760
От времени или от данных?

01:01:52.760 --> 01:01:54.760
От времени – да.

01:01:54.760 --> 01:01:56.760
Не должен.

01:01:56.760 --> 01:01:58.760
И ранд от времени, он превращается в стабильный,

01:01:58.760 --> 01:02:00.760
если ты постулируешь, что у тебя

01:02:00.760 --> 01:02:02.760
время нужно.

01:02:02.760 --> 01:02:04.760
То есть, если ты не хочешь зависеть от времени,

01:02:04.760 --> 01:02:06.760
ты говоришь ключ, и у тебя

01:02:06.760 --> 01:02:08.760
время убирается.

01:02:10.760 --> 01:02:12.760
На самом деле, довольно прикольно,

01:02:12.760 --> 01:02:14.760
что это время копируется.

01:02:14.760 --> 01:02:16.760
Можно таки смотреть, я так часто делаю,

01:02:16.760 --> 01:02:18.760
а когда какую-то пробу собрали,

01:02:18.760 --> 01:02:20.760
потому что далеко не все

01:02:20.760 --> 01:02:22.760
пишут версию программы,

01:02:22.760 --> 01:02:24.760
даже если и пишут,

01:02:24.760 --> 01:02:26.760
бывает, что ее просто не обновляют,

01:02:26.760 --> 01:02:28.760
чтобы узнать, а вообще,

01:02:28.760 --> 01:02:30.760
когда это было создано.

01:02:30.760 --> 01:02:32.760
Обычно время

01:02:32.760 --> 01:02:34.760
никто не трогает.

01:02:34.760 --> 01:02:36.760
Вообще даже, мне кажется, мало кто знает,

01:02:36.760 --> 01:02:38.760
что это время копируется.

01:02:38.760 --> 01:02:40.760
И поэтому времени прям

01:02:40.760 --> 01:02:42.760
можно так оценивать,

01:02:42.760 --> 01:02:44.760
насколько давно это было.

01:02:44.760 --> 01:02:46.760
И на сколько времени?

01:02:46.760 --> 01:02:48.760
Ну, даже, например, сравнивать,

01:02:48.760 --> 01:02:50.760
у тебя есть две какие-то версии программы,

01:02:50.760 --> 01:02:52.760
вот какая из них новее?

01:02:52.760 --> 01:02:54.760
Они нигде не говорят,

01:02:54.760 --> 01:02:56.760
кто они.

01:02:56.760 --> 01:02:58.760
Абсолютно нигде.

01:02:58.760 --> 01:03:00.760
Четко отличаются.

01:03:00.760 --> 01:03:02.760
Кто новее?

01:03:02.760 --> 01:03:04.760
Ты смотришь на время,

01:03:04.760 --> 01:03:06.760
а он уже, наверное,

01:03:06.760 --> 01:03:08.760
приедет с новейшим.

01:03:10.760 --> 01:03:12.760
Вот.

01:03:14.760 --> 01:03:16.760
Ну, это я вам

01:03:16.760 --> 01:03:18.760
так вот сказал, на самом деле.

01:03:18.760 --> 01:03:22.760
Вершину айсберга.

01:03:22.760 --> 01:03:24.760
Во-первых,

01:03:24.760 --> 01:03:26.760
оно только про x86.

01:03:26.760 --> 01:03:28.760
Я там

01:03:28.760 --> 01:03:30.760
не рассматривал подробно там

01:03:30.760 --> 01:03:32.760
разные релокации,

01:03:32.760 --> 01:03:34.760
потому что по Linux там еще есть

01:03:34.760 --> 01:03:36.760
отдельный зоопарк с разными видами релокаций.

01:03:36.760 --> 01:03:38.760
Как я уже говорил,

01:03:38.760 --> 01:03:40.760
что если вы там импортируете данные,

01:03:40.760 --> 01:03:42.760
то это еще дополнительные проблемы

01:03:42.760 --> 01:03:44.760
себе на голове,

01:03:44.760 --> 01:03:46.760
как импортировать данные.

01:03:46.760 --> 01:03:48.760
То есть потенциально вы же можете сказать,

01:03:48.760 --> 01:03:50.760
что вот эта переменная,

01:03:50.760 --> 01:03:52.760
она находится в динамической библиотеке.

01:03:56.760 --> 01:03:58.760
И даже можно сделать,

01:03:58.760 --> 01:04:00.760
чтобы она действительно работала.

01:04:00.760 --> 01:04:02.760
Но нужно

01:04:02.760 --> 01:04:04.760
больше прилагать усилий,

01:04:04.760 --> 01:04:06.760
и комбинатор меньше может

01:04:06.760 --> 01:04:08.760
автоматически править.

01:04:08.760 --> 01:04:10.760
Вот.

01:04:10.760 --> 01:04:12.760
Потом там всякие security

01:04:12.760 --> 01:04:14.760
возвращения.

01:04:14.760 --> 01:04:16.760
Например,

01:04:16.760 --> 01:04:18.760
если вы посмотрите на этот самый PLT,

01:04:18.760 --> 01:04:20.760
в каком-нибудь современном

01:04:20.760 --> 01:04:22.760
дистрибутиве Linux,

01:04:22.760 --> 01:04:24.760
там будет, конечно, побольше

01:04:24.760 --> 01:04:26.760
командочек,

01:04:26.760 --> 01:04:28.760
что я вам написал.

01:04:28.760 --> 01:04:30.760
Там вот всякие

01:04:30.760 --> 01:04:32.760
mdbr64,

01:04:32.760 --> 01:04:34.760
repng,

01:04:34.760 --> 01:04:36.760
и прочие

01:04:36.760 --> 01:04:38.760
дикие

01:04:38.760 --> 01:04:40.760
аддоны,

01:04:40.760 --> 01:04:42.760
которые тоже

01:04:42.760 --> 01:04:44.760
аргументируются

01:04:44.760 --> 01:04:46.760
по security.

01:04:46.760 --> 01:04:48.760
И всяких там

01:04:48.760 --> 01:04:50.760
secure-заплаток,

01:04:50.760 --> 01:04:52.760
конечно, мы забрали

01:04:52.760 --> 01:04:54.760
довольно много.

01:04:54.760 --> 01:04:56.760
И они иногда

01:04:56.760 --> 01:04:58.760
довольно сильно влияют

01:04:58.760 --> 01:05:00.760
на что там у вас произойдет.

01:05:00.760 --> 01:05:02.760
Это такая базовая версия.

01:05:02.760 --> 01:05:04.760
Если вы отключите все эти

01:05:04.760 --> 01:05:06.760
security-заплатки,

01:05:06.760 --> 01:05:08.760
с ними там кода побольше.

01:05:12.760 --> 01:05:14.760
Ну что, нормально все, да?

01:05:14.760 --> 01:05:16.760
Я вас достаточно уничтожил.

01:05:18.760 --> 01:05:20.760
Кстати,

01:05:20.760 --> 01:05:22.760
вот этот вот ethno-institution hidden,

01:05:22.760 --> 01:05:24.760
он привязан именно к

01:05:24.760 --> 01:05:26.760
различным кандидатам.

01:05:26.760 --> 01:05:28.760
Могут ставить это все

01:05:28.760 --> 01:05:30.760
по-адекватному.

01:05:30.760 --> 01:05:32.760
Есть понятие,

01:05:32.760 --> 01:05:34.760
зависит от правил.

01:05:34.760 --> 01:05:36.760
Просто C,

01:05:36.760 --> 01:05:38.760
Linux, это вещи такие

01:05:38.760 --> 01:05:40.760
очень тесно связанные,

01:05:40.760 --> 01:05:42.760
поэтому это происходит

01:05:42.760 --> 01:05:44.760
с C,

01:05:44.760 --> 01:05:46.760
Linux,

01:05:46.760 --> 01:05:48.760
но, конечно,

01:05:48.760 --> 01:05:50.760
любые языки

01:05:50.760 --> 01:05:52.760
вполне могут объявить,

01:05:52.760 --> 01:05:54.760
что давайте у нас на все

01:05:54.760 --> 01:05:56.760
система

01:05:56.760 --> 01:05:58.760
вот такое поведение.

01:05:58.760 --> 01:06:00.760
И это будет, конечно,

01:06:00.760 --> 01:06:02.760
немного более современное

01:06:02.760 --> 01:06:04.760
поведение.

01:06:04.760 --> 01:06:06.760
Но это точно правильно,

01:06:06.760 --> 01:06:08.760
что оно будет

01:06:08.760 --> 01:06:10.760
менее системно зависимым.

01:06:10.760 --> 01:06:12.760
Сейчас.

01:06:12.760 --> 01:06:14.760
А A-bit, это как бы воздание

01:06:14.760 --> 01:06:16.760
к люксовому ядру, у нас только

01:06:16.760 --> 01:06:18.760
то, что у нас нету,

01:06:18.760 --> 01:06:20.760
и нельзя нормально сделать

01:06:20.760 --> 01:06:22.760
дедупликацию сошек,

01:06:22.760 --> 01:06:24.760
а все остальное можно

01:06:24.760 --> 01:06:26.760
линкеров LBSO

01:06:26.760 --> 01:06:28.760
реализовать.

01:06:28.760 --> 01:06:30.760
Можно

01:06:30.760 --> 01:06:32.760
не народ,

01:06:32.760 --> 01:06:34.760
можно

01:06:34.760 --> 01:06:36.760
руку тебя сломать.

01:06:36.760 --> 01:06:38.760
Если

01:06:38.760 --> 01:06:40.760
ты будешь пытаться

01:06:40.760 --> 01:06:42.760
делать неудобную систему,

01:06:42.760 --> 01:06:44.760
где у тебя символы

01:06:44.760 --> 01:06:46.760
привязаны к библиотеке,

01:06:46.760 --> 01:06:48.760
ты абсолютно уверен,

01:06:48.760 --> 01:06:50.760
что у тебя в куче

01:06:50.760 --> 01:06:52.760
все сломается.

01:06:52.760 --> 01:06:54.760
Нет,

01:06:54.760 --> 01:06:56.760
когда ты перепишешь линки,

01:06:56.760 --> 01:06:58.760
перекомпилируешь,

01:06:58.760 --> 01:07:00.760
я абсолютно уверен,

01:07:00.760 --> 01:07:02.760
что у тебя в куче

01:07:02.760 --> 01:07:04.760
все не заработает.

01:07:04.760 --> 01:07:06.760
Потому что кто-то что-то

01:07:06.760 --> 01:07:08.760
не использует.

