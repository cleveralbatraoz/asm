# Lecture Notes on Assembly

## 1. Control Structures

### Example: `switch` in C
```c
switch (value) {
    case 1:
    case 2:   X;
    case 3:   { Y; break; }
    case 5:   Z;
    default:  D;
}
```

### Compilation to ASM
```asm
; sub eax, 1
cmp eax, 5
ja  L4
jmp [eax * 4 + table]

L1: X
L2: Y
    jmp L5
L3: Z
L4: D
L5:

table dd L4, L1, L1, L2, L4, L3
        0   1   2   3   4   5
```
üëâ `eax * 4` because addresses are stored in 4‚Äëbyte cells.

---

## 2. Function Organization

### General Function Structure
```asm
push ebp
mov  ebp, esp
sub  esp, <locals>
...
mov  esp, ebp
pop  ebp
ret
```

### Role of EBP
- Used as a **base pointer** (reference point for locals and arguments).
- Helpful for debugging and profiling.
- Can be disabled (`omit frame pointer`) to save a register.

### ENTER / LEAVE
| Instruction | Equivalent | Notes |
|--------------|-------------|--------|
| `enter` | Complex logic | Slow, compilers rarely use it |
| `leave` | `mov esp, ebp; pop ebp` | Performance depends on CPU |

---

## 3. Local Memory and Stack

### Allocating Local Variables
- Stack grows downward.
- Use `sub esp, N` to allocate locals.
- Align ESP to multiples of **4 or 8 bytes**.

### `alloca()`
- Similar to `malloc`, but allocates **on the stack**.
- In C: `alloca(size)`
- Memory is automatically freed on function exit.
- Using `alloca` forces the compiler to create a stack frame.

### Stack Limits
- Safe up to about **1 MB**.
- Default on Linux ‚âà 8 MB.
- Can be increased through thread or executable settings.

---

## 4. Calling Conventions (x86, 32-bit)

### Comparison Table
| Convention | Arguments | Stack Cleanup | Notes |
|-------------|------------|----------------|--------|
| **cdecl** | On stack (reverse order) | **Caller** | Supports `vararg` |
| **stdcall** | On stack (reverse order) | **Callee** | No `vararg` |
| **fastcall** | First args in registers (`ecx`, `edx`), rest on stack | Varies | Not standardized |
| **thiscall** | `this` in `ecx`, rest as in fastcall | **Callee** | For class methods |

### Examples

#### cdecl
```asm
push e
push b
push a
call f
add  esp, 12 ; cleanup
```

#### stdcall
```asm
push e
push b
push a
call f
; cleanup inside function
ret  12
```

---

## 5. Return Values

| Return Type | Register |
|--------------|-----------|
| `int` (4 bytes) | `eax` |
| `bool` (1 byte) | `al` |
| `long long` (8 bytes) | `edx:eax` |

### When Result Doesn't Fit a Register
- The **caller** allocates memory.
- Function receives a pointer to the buffer (as the ‚Äúzeroth argument‚Äù).
- Order may differ between MSVC and Unix conventions.

---

## 6. Saved and Volatile Registers

| Category | Registers |
|-----------|------------|
| **Callee-saved** (must be preserved) | `ebx`, `ebp`, `esi`, `edi` |
| **Caller-saved** (may be destroyed) | `eax`, `ecx`, `edx` |

---

## 7. Practical Tips

- Design APIs so that return values **fit into one register**.
- Use pointers for large structures.
- Consider stack limits for recursion or large locals.
- Recommended reading: **Agner Fog ‚Äì ‚ÄúCalling Conventions‚Äù (agner.org)**

---

## 8. Additional Notes

### Alignment
- On x86, unaligned accesses are often free unless crossing a cache line.
- Still, aligned data improves predictability and performance.

### Specialized Instructions
- Modern CPUs add new instructions for efficiency.
- Example: `CRC32` for checksums.
