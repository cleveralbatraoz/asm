# Dynamic Linking Lecture Notes

The lecture covered **Linux/UNIX dynamic linking** and **Windows DLL linking**, then compared them.

---

## Part 1: UNIX/Linux (ELF) Dynamic Linking

### Core Concepts

| Term | Meaning | Role |
|---|---|---|
| `.so` | Shared library file on Linux | Provides functions to programs |
| ELF | Executable & Linkable Format | Binary format for Linux executables/libraries |
| GOT (Global Offset Table) | Table storing resolved symbol addresses | Updated once resolution happens |
| PLT (Procedure Linkage Table) | Jump stubs used to call external functions | Triggers resolver on first call |
| Dynamic Linker (`ld.so`) | Loads `.so` files and resolves symbols | Can lazy-bind on demand |

### How Lazy Binding Works

```
call foo()
    |
    v
foo@plt  ---> checks GOT entry
    |         |
    |         if resolved -> jump to real foo
    |
    v
plt stub pushes relocation index
jumps to dynamic linker
dynamic linker finds "foo" in .so export table
updates GOT entry with real address
next call: direct jump via GOT
```

The PLT is like a receptionist who looks up the room number the first time you ask, then writes it on your hand so you walk straight there next time.

### Pseudocode Structure

```
plt0:
    push [got+4]      ; relocation index
    jmp  [got+8]      ; call dynamic resolver

foo@plt:
    jmp  [foo@got]    ; if resolved, jump directly
foo@plt+2:
    push relocation_index
    jmp plt0
```

### Why Lazy Binding Exists

- Speeds startup
- Only resolves symbols actually called
- Enables symbol interposition (e.g., `LD_PRELOAD` tricks)

### Criticisms/Concerns Mentioned

- Harder to debug than static linking
- Security issue: GOT overwrite possible without proper protections (old exploit path)
- Can introduce performance jitter on first call
- Indirection layers complicate disassembly & reverse engineering

---

## Part 2: Windows DLL Dynamic Linking

### Core Concepts

| Term | Meaning | Purpose |
|---|---|---|
| `.dll` | Dynamic Link Library | Shared library on Windows |
| Import Table (IAT) | List of functions executable expects | Loader fills with real addresses at startup |
| Export Table | Functions a DLL exposes | Loader uses this to locate symbols |
| Loader | Part of Windows runtime | Resolves DLL functions before main program runs |

### Load-Time Binding Flow

```
EXE starts
  |
  v
OS loader reads Import Table
  |
  v
loads DLLs into memory
  |
  v
Finds exported function addresses
  |
  v
Writes them into IAT
  |
  v
Program calls functions directly through IAT
```

Think of the loader as assigning every contact in your phone to a number before you start calling people. No lookup later.

### DLL Linking Notes

- Resolution happens **before** code runs (not lazy by default)
- Calls go through IAT entries
- Thunks may be involved but simpler than PLT/GOT
- Delay-loading exists but uncommon in practice

### Lecturer Concerns

- DLL hell: version mismatches, ABI breaks
- Relocation cost if DLL loaded at a different base
- Static analysis sometimes easier, but runtime hooking trickier

---

## Part 3: Comparison

| Topic | Linux/UNIX ELF | Windows DLL |
|---|---|---|
| Linking style | Lazy by default | Eager by default |
| Indirection | PLT + GOT | IAT |
| Resolver call | First time a function is called | App startup |
| Security history | GOT overwrite attacks | DLL hijacking risks |
| Flexibility | High (LD_PRELOAD, interposition) | Lower without custom hooks |
| Startup cost | Faster startup | More up-front work |
| Reverse engineering complexity | PLT/GOT indirection | More direct call layout |

### Small ASCII Diagram Comparison

Linux:

```
call foo -> foo@plt -> resolver -> GOT updated -> real foo
```

Windows:

```
startup: loader fills IAT
call foo -> IAT -> real foo
```

### Lecture Emphasis

- Linux: optimized flexibility, delayed resolution, hackable dynamic linker behavior
- Windows: simpler, predictable import resolution, but version/ABI headaches and DLL hijacking concerns

---

## Key Exam-Style Understanding

- PLT is a trampoline table
- GOT stores the real target addresses once known
- Windows stores resolved addresses in IAT from the start
- Dynamic linker behavior differs greatly between systems
- Security and debugging implications are not identical

